<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>STLAlgorithme | Léo`s Blog</title>
  <meta name="author" content="Zhang WENG">
  
  <meta name="description" content="15 Nov 2016
使用模版算法需要 #include 
STL中的算法大致可以分为以下七类:
不变序列算法 
变值算法
删除算法
变序算法
排序算法
有序区间算法 
数值算法

大多重载的算法都是有两个版本的,用“==”判断元素是否相等,或用“&amp;lt;”来比较大小 多出一个类型参数“Pred”和函数形参“Predop”:通过表达式 “op(x,y)” 的返回值: ture/false,判断x是否 “等于” y，或者x是否 “小于” y">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="STLAlgorithme"/>
  <meta property="og:site_name" content="Léo`s Blog"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/favicon.ico" rel="icon">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/css/themes/flatly.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight-default.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/comment.css" media="screen" type="text/css">
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.9/es5-shim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.7/es5-sham.min.js"></script>
  <![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>
  
  <!-- analytics -->
  



</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
       <a class="navbar-brand" href="/">Léo`s Blog</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header page-header-inverse ">		
			<h1 class="title title-inverse "> STLAlgorithme</h1>
		</div>		
	






<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <p><code>15 Nov 2016</code></p>
<p>使用模版算法需要 #include <algorithme></algorithme></p>
<h1 id="STL中的算法大致可以分为以下七类"><a href="#STL中的算法大致可以分为以下七类" class="headerlink" title="STL中的算法大致可以分为以下七类:"></a>STL中的算法大致可以分为以下七类:</h1><ul>
<li>不变序列算法 </li>
<li>变值算法</li>
<li>删除算法</li>
<li>变序算法</li>
<li>排序算法</li>
<li>有序区间算法 </li>
<li>数值算法</li>
</ul>
<p>大多重载的算法都是有两个版本的,用“==”判断元素是否相等,或用“&lt;”来比较大小 多出一个类型参数“Pred”和函数形参“Predop”:<br>通过表达式 “op(x,y)” 的返回值: ture/false,判断x是否 “等于” y，或者x是否 “小于” y<br><a id="more"></a></p>
<h1 id="不变序列算法"><a href="#不变序列算法" class="headerlink" title="不变序列算法"></a>不变序列算法</h1><p>该类算法不会修改算法所作用的容器或对象,适用于顺序容器和关联容器,时间复杂度都是O(n)</p>
<ul>
<li>min:求两个对象中较小的(可自定义比较器)</li>
<li>max:求两个对象中较大的(可自定义比较器)</li>
<li>find:在区间中查找等于某值的元素<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InIt</span> <span class="title">find</span>(<span class="title">InIt</span> <span class="title">first</span>, <span class="title">InIt</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">val</span>);</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>返回区间 [first,last) 中的迭代器 i ,使得 * i == val.</p>
<ul>
<li>count:计算区间中等于某值的元素个数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">size_t</span> <span class="title">count</span>(<span class="title">InIt</span> <span class="title">first</span>, <span class="title">InIt</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">val</span>);</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>计算[first, last) 中等于val的元素个数(x==y为true算等于)</p>
<ul>
<li>for_each:对区间中的每个元素都做某种操作<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt</span>, <span class="title">class</span> <span class="title">Fun</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Fun</span> <span class="title">for_each</span>(<span class="title">InIt</span> <span class="title">first</span>, <span class="title">InIt</span> <span class="title">last</span>, <span class="title">Fun</span> <span class="title">f</span>);</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>对[first, last)中的每个元素e, 执行f(e), 要求 f(e)不能改变e.</p>
<ul>
<li>min_element:求区间中的最小值(可自定义比较器)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">FwdIt</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">FwdIt</span> <span class="title">min_element</span>(<span class="title">FwdIt</span> <span class="title">first</span>, <span class="title">FwdIt</span> <span class="title">last</span>);</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>返回[first,last) 中最小元素的迭代器, 以 “&lt;” 作比较器,最小指没有元素比它小, 而不是它比别的不同元素都小 因为即便a!= b, a&lt;b 和b&lt;a有可能都不成立.</p>
<ul>
<li>max_element:求区间中的最大值(可自定义比较器)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">FwdIt</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">FwdIt</span> <span class="title">max_element</span>(<span class="title">FwdIt</span> <span class="title">first</span>, <span class="title">FwdIt</span> <span class="title">last</span>);</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>返回[first,last) 中最大元素(不小于任何其他元素)的迭代器 以 “&lt;” 作比较器.</p>
<ul>
<li>count_if:计算区间中符合某种条件的元素个数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt</span>, <span class="title">class</span> <span class="title">Pred</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">size_t</span> <span class="title">count_if</span>(<span class="title">InIt</span> <span class="title">first</span>, <span class="title">InIt</span> <span class="title">last</span>, <span class="title">Pred</span> <span class="title">pr</span>);</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>计算[first, last) 中符合pr(e) == true 的元素e的个数</p>
<ul>
<li>find_if:在区间中查找符合某条件的元素<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt</span>, <span class="title">class</span> <span class="title">Pred</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InIt</span> <span class="title">find_if</span>(<span class="title">InIt</span> <span class="title">first</span>, <span class="title">InIt</span> <span class="title">last</span>, <span class="title">Pred</span> <span class="title">pr</span>);</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>返回区间 [first,last) 中的迭代器 i, 使得 pr(*i) == true.</p>
<ul>
<li>find_end:在区间中查找另一个区间最后一次出现的位 置(可自定义比较器)</li>
<li>find_first_of:在区间中查找第一个出现在另一个区间中的元素 (可自定义比较器)</li>
<li>adjacent_find:在区间中寻找第一次出现连续两个相等元素的位置(可自定义比较器)</li>
<li>search:在区间中查找另一个区间第一次出现的位置(可自定义比较器)</li>
<li>search_n:在区间中查找第一次出现等于某值的连续n个元 素(可自定义比较器)</li>
<li>equal:判断两区间是否相等(可自定义比较器)</li>
<li>mismatch:逐个比较两个区间的元素，返回第一次发生不相等的两个元素的位置(可自定义比较器)</li>
</ul>
<h1 id="变值算法"><a href="#变值算法" class="headerlink" title="变值算法"></a>变值算法</h1><p>此类算法会修改源区间或目标区间元素的值,值被修改的那个区间, 不可以是属于关联容器的。</p>
<ul>
<li>for_each:对区间中的每个元素都做某种操作</li>
<li>copy:复制一个区间到别处<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt</span>, <span class="title">class</span> <span class="title">OutIt</span>&gt; <span class="title">OutIt</span> <span class="title">copy</span>(<span class="title">InIt</span> <span class="title">first</span>, <span class="title">InIt</span> <span class="title">last</span>, <span class="title">OutIt</span> <span class="title">x</span>);</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>本函数对每个在区间[0, last - first)中的N执行一次 <em>(x+N) = </em>(first + N), 返回 x + </p>
<ul>
<li>copy_backward:复制一个区间到别处, 但目标区前是从后往前被修改的</li>
<li>transform:将一个区间的元素变形后拷贝到另一个区间<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt</span>, <span class="title">class</span> <span class="title">OutIt</span>, <span class="title">class</span> <span class="title">Unop</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutIt</span> <span class="title">transform</span>(<span class="title">InIt</span> <span class="title">first</span>, <span class="title">InIt</span> <span class="title">last</span>, <span class="title">OutIt</span> <span class="title">x</span>, <span class="title">Unop</span> <span class="title">uop</span>);</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>对[first,last)中的每个迭代器I,执行 uop( <em> I ); 并将结果依次放入从 x 开始的地方,要求 uop( </em> I ) 不得改变 * I 的值.<br>本模板返回值是个迭代器, 即 x + (last-first) • x可以和 first相等.</p>
<ul>
<li>swap_ranges:交换两个区间内容</li>
<li>fill:用某个值填充区间</li>
<li>fill_n:用某个值替换区间中的n个元素</li>
<li>generate:用某个操作的结果填充区间</li>
<li>generate_n:用某个操作的结果替换区间中的n个元素</li>
<li>replace:将区间中的某个值替换为另一个值</li>
<li>replace_if:将区间中符合某种条件的值替换成另一个值</li>
<li>replace_copy:将一个区间拷贝到另一个区间，拷贝时某个值 要换成新值拷过去</li>
<li>replace_copy_if:将一个区间拷贝到另一个区间，拷贝时符合某条件的值要换成新值拷过去</li>
</ul>
<h1 id="删除算法"><a href="#删除算法" class="headerlink" title="删除算法"></a>删除算法</h1><p>删除一个容器里的某些元素<br>删除不会使容器里的元素减少<br>删除算法不应作用于关联容器<br>算法复杂度都是O(n)的</p>
<ul>
<li>将所有应该被删除的元素看做空位子</li>
<li>用留下的元素从后往前移, 依次去填空位子</li>
<li>元素往前移后, 它原来的位置也就算是空位子</li>
<li>也应由后面的留下的元素来填上</li>
<li><p>最后, 没有被填上的空位子, 维持其原来的值不变</p>
</li>
<li><p>remove:删除区间中等于某个值的元素</p>
</li>
<li>remove_if:删除区间中满足某种条件的元素</li>
<li>remove_copy:拷贝区间到另一个区间. 等于某个值的元素不拷贝</li>
<li>remove_copy_if:拷贝区间到另一个区间. 符合某种条件的元素不拷贝</li>
<li>unique:删除区间中连续相等的元素, 只留下一个(可自定义比较器)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">FwdIt</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">FwdIt</span> <span class="title">unique</span>(<span class="title">FwdIt</span> <span class="title">first</span>, <span class="title">FwdIt</span> <span class="title">last</span>);</span></span><br><span class="line"><span class="comment">//用 == 比较是否等</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">FwdIt</span>, <span class="title">class</span> <span class="title">Pred</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">FwdIt</span> <span class="title">unique</span>(<span class="title">FwdIt</span> <span class="title">first</span>, <span class="title">FwdIt</span> <span class="title">last</span>, <span class="title">Pred</span> <span class="title">pr</span>);</span></span><br><span class="line"><span class="comment">//用 pr (x,y)为 true说明x和y相等</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>对[first,last) 这个序列中连续相等的元素, 只留下第一个,返回值是迭代器, 指向元素删除后的区间的最后一个元 素的后面</p>
<ul>
<li>unique_copy:拷贝区间到另一个区间. 连续相等的元素, 只拷贝第一个到目 标区间 (可自定义比较器)</li>
</ul>
<h1 id="变序算法"><a href="#变序算法" class="headerlink" title="变序算法"></a>变序算法</h1><p>变序算法改变容器中元素的顺序,是不改变元素的值,变序算法不适用于关联容器,算法复杂度都是O(n)的.</p>
<ul>
<li>reverse:颠倒区间的前后次序</li>
<li>reverse_copy:把一个区间颠倒后的结果拷贝到另一个区间,源区间不变</li>
<li>rotate:将区间进行循环左移</li>
<li>rotate_copy:将区间以首尾相接的形式进行旋转后的结果,拷贝到另一个区间，源区间不变</li>
<li>next_permutation:将区间改为下一个排列(可自定义比较器)</li>
<li>prev_permutation:将区间改为上一个排列(可自定义比较器)</li>
<li>random_shuffle:随机打乱区间内元素的顺序</li>
<li>partition:把区间内满足某个条件的元素移到前面，不满足该条件的移到后面</li>
</ul>
<h1 id="有序区间算法"><a href="#有序区间算法" class="headerlink" title="有序区间算法"></a>有序区间算法</h1><p>要求所操作的区间是已经从小到大排好序的 需要随机访问迭代器的支持 有序区间算法不能用于关联容器和list</p>
<ul>
<li><p>binary_search:判断区间中是否包含某个元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">FwdIt</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">binary_search</span>(<span class="title">FwdIt</span> <span class="title">first</span>, <span class="title">FwdIt</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">val</span>);</span></span><br><span class="line"><span class="comment">//上面这个版本, 比较两个元素x, y 大小时, 看 x &lt; y template&lt;class FwdIt, class T, class Pred&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">binary_search</span><span class="params">(FwdIt first, FwdIt last, <span class="keyword">const</span> T&amp; val, Pred pr)</span></span>;</span><br><span class="line"><span class="comment">//上面这个版本, 比较两个元素x, y 大小时, 若 pr(x,y) 为true, 则 认为x小于y</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>includes:判断是否一个区间中的每个元素，都在另一个区间中</p>
</li>
<li><p>lower_bound:查找最后一个不小于某值的元素的位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">FwdIt</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">FwdIt</span> <span class="title">lower_bound</span>(<span class="title">FwdIt</span> <span class="title">first</span>, <span class="title">FwdIt</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">val</span>);</span></span><br><span class="line"><span class="comment">//要求[first,last)是有序的</span></span><br><span class="line"><span class="comment">//查找[first,last)中的, 最大的位置 FwdIt, 使得[first,FwdIt)中所有的元素都比 val 小</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>upper_bound:查找第一个大于某值的元素的位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">FwdIt</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">FwdIt</span> <span class="title">upper_bound</span>(<span class="title">FwdIt</span> <span class="title">first</span>, <span class="title">FwdIt</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">val</span>);</span></span><br><span class="line"><span class="comment">//要求[first,last)是有序的</span></span><br><span class="line"><span class="comment">//查找[first,last)中的, 最小的位置 FwdIt, 使得[FwdIt,last)中所有的元素都比 val 大</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>equal_range:同时获取lower_bound和upper_bound</p>
</li>
<li><p>merge:合并两个有序区间到第三个区间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt1</span>, <span class="title">class</span> <span class="title">InIt2</span>, <span class="title">class</span> <span class="title">OutIt</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutIt</span> <span class="title">merge</span>(<span class="title">InIt1</span> <span class="title">first1</span>, <span class="title">InIt1</span> <span class="title">last1</span>, <span class="title">InIt2</span> <span class="title">first2</span>, <span class="title">InIt2</span> <span class="title">last2</span>, <span class="title">OutIt</span> <span class="title">x</span>);</span></span><br><span class="line"><span class="comment">//用 &lt; 作比较器</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt1</span>, <span class="title">class</span> <span class="title">InIt2</span>, <span class="title">class</span> <span class="title">OutIt</span>, <span class="title">class</span> <span class="title">Pred</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutIt</span> <span class="title">merge</span>(<span class="title">InIt1</span> <span class="title">first1</span>, <span class="title">InIt1</span> <span class="title">last1</span>, <span class="title">InIt2</span> <span class="title">first2</span>, <span class="title">InIt2</span> <span class="title">last2</span>, <span class="title">OutIt</span> <span class="title">x</span>, <span class="title">Pred</span> <span class="title">pr</span>);</span></span><br><span class="line"><span class="comment">//用 pr 作比较器把[first1,last1), [ first2,last2) 两个升序序列合并, 形成第 3 个升序序列, 第3个升序序列以 x 开头</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>set_union:将两个有序区间的并拷贝到第三个区间</p>
</li>
<li>set_intersection:将两个有序区间的交拷贝到第三个区间</li>
<li>set_difference:将两个有序区间的差拷贝到第三个区间</li>
<li>set_symmetric_difference:将两个有序区间的对称差拷贝到第三个区间</li>
<li>inplace_merge:将两个连续的有序区间原地合并为一个有序区间</li>
</ul>
	  
	</div>

	<!-- recommended posts -->
	

	<div>
  	<center>
	<div class="pagination">
<ul class="pagination">
	 
				
    	<li class="prev"><a href="/2016/11/16/UBiOnlineTest/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>Prev</a></li>
  		

        <li><a href="/archives"><i class="fa fa-archive"></i>Archive</a></li>

		
		   <li class="next"><a href="/2016/11/11/StandardTemplateLibrary-STL/" class="alignright next">Next<i class="fa fa-arrow-circle-o-right"></i></a></li>         
        
	
</ul>
</div>

    </center>
	</div>

    <!-- share -->
    
        

        

    
	
	<!-- comment -->
	
<section id="comment">
  <h2 class="title">Comments</h2>
  
  	 <div id="disqus_thread">
     <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  	 </div>
  
</section>


	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2016-11-15 
	</div>
	

	<!-- categories -->
    

	<!-- tags -->
	

	<!-- toc -->
	<div class="meta-widget">
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>
		

</div><!-- row -->

<script type="text/javascript">
var disqus_shortname = 'leoweng';
(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2018 Zhang WENG
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>


<!-- syntax highlighting -->


</body>
   </html>

<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>MIT6.006_DataStructureAndAlgorithms | Léo`s Blog</title>
  <meta name="author" content="Léo WENG">
  
  <meta name="description" content="lecture 2:Document  distance problem : d(D1,D2)?-document = sequence of words.-word = string of chars.distance : look at the shared words
lecture3:binary search4.Heap and heap sortHeap also called priority queue , its the implementation of a priority queue,and by putting the elements of this queue into a tree we have heap, the relation of array index in the tree is as follow:     1.root :first element     2.parent(i)  = floor(i/2);//index of is parent
     3.left(i) = 2i + 1; right(i) = 2i;     //index of is children
heap property:

Max heap: for every node i : A[parent(i)] &amp;gt;= A[i] ;
Min heap: for every node i: A[parent(i)] &amp;lt;= A[i] ;

Max_heapify(A,i):Assume that the tree rooted at left(i) and right(i) are maxheap check the value of element i and left(i) right(i) exchange the largest with element i
max Heap:the key of a node is &amp;gt;= the keys of its childrenbuild max-Heap(A):
for i =n/2 down to 1      
//here [n/2 - n] is all leaves as is tree`s property
do max_heapify(A,i);
heap sort:1.build max_heap from unordered array2.find A[i] which is the top element3.swap element A[n] with A[1] and the max element is at the end of the array4.discard node A[n] from the heap by decrementing heap size5.new root may violate max property but its children are max heap so run max_heapify the tree6.goto step 2">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="MIT6.006_DataStructureAndAlgorithms"/>
  <meta property="og:site_name" content="Léo`s Blog"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/favicon.icon" rel="icon">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/css/themes/flatly.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight-default.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/comment.css" media="screen" type="text/css">
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.9/es5-shim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.7/es5-sham.min.js"></script>
  <![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>
  
  <!-- analytics -->
  



</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
       <a class="navbar-brand" href="/">Léo`s Blog</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header page-header-inverse ">		
			<h1 class="title title-inverse "> MIT6.006_DataStructureAndAlgorithms</h1>
		</div>		
	






<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <h4 id="lecture-2"><a href="#lecture-2" class="headerlink" title="lecture 2:"></a>lecture 2:</h4><p>Document  distance problem : d(D1,D2)?<br>-document = sequence of words.<br>-word = string of chars.<br>distance : look at the shared words</p>
<h4 id="lecture3-binary-search"><a href="#lecture3-binary-search" class="headerlink" title="lecture3:binary search"></a>lecture3:binary search</h4><h4 id="4-Heap-and-heap-sort"><a href="#4-Heap-and-heap-sort" class="headerlink" title="4.Heap and heap sort"></a>4.Heap and heap sort</h4><p>Heap also called priority queue , its the implementation of a priority queue,and by putting the elements of this queue into a tree we have heap, the relation of array index in the tree is as follow:<br>     1.root :first element<br>     2.parent(i)  = floor(i/2);//index of i<code>s parent
     3.left(i) = 2i + 1; right(i) = 2i;     //index of i</code>s children</p>
<p>heap property:</p>
<ul>
<li>Max heap: for every node i : <code>A[parent(i)] &gt;= A[i] ;</code></li>
<li>Min heap: for every node i: <code>A[parent(i)] &lt;= A[i] ;</code></li>
</ul>
<h5 id="Max-heapify-A-i"><a href="#Max-heapify-A-i" class="headerlink" title="Max_heapify(A,i):"></a>Max_heapify(A,i):</h5><p>Assume that the tree rooted at left(i) and right(i) are maxheap check the value of element i and left(i) right(i) exchange the largest with element i</p>
<h5 id="max-Heap"><a href="#max-Heap" class="headerlink" title="max Heap:"></a>max Heap:</h5><p>the key of a node is &gt;= the keys of its children<br>build max-Heap(A):</p>
<pre><code>for i =n/2 down to 1      
//here [n/2 - n] is all leaves as is tree`s property
do max_heapify(A,i);
</code></pre><h5 id="heap-sort"><a href="#heap-sort" class="headerlink" title="heap sort:"></a>heap sort:</h5><p>1.build max_heap from unordered array<br>2.find A[i] which is the top element<br>3.swap element A[n] with A[1] and the max element is at the end of the array<br>4.discard node A[n] from the heap by decrementing heap size<br>5.new root may violate max property but its children are max heap so run max_heapify the tree<br>6.goto step 2<br><a id="more"></a></p>
<h4 id="5-Binary-Search-Tree-BST-in-order-by-building-the-tree-from-array"><a href="#5-Binary-Search-Tree-BST-in-order-by-building-the-tree-from-array" class="headerlink" title="5.Binary Search Tree:BST in order by building the tree from array"></a>5.Binary Search Tree:BST in order by building the tree from array</h4><h5 id="PROPERTY"><a href="#PROPERTY" class="headerlink" title="PROPERTY:"></a>PROPERTY:</h5><p>For all node x, if y is in the left subtree of x then val(y) &lt;= val(x);<br>If y is in the right subtree of x then val(y) &gt;= val(x);</p>
<h5 id="INSERTION-with-check-o-h-time-with-h-equals-to-the-hight-of-the-tree"><a href="#INSERTION-with-check-o-h-time-with-h-equals-to-the-hight-of-the-tree" class="headerlink" title="INSERTION with check: o(h) time with h equals to the hight of the tree"></a>INSERTION with check: o(h) time with h equals to the hight of the tree</h5><p>Operations:<br>     find-min():go to the left with o(h);<br>     find-max():go to the right with o(h);                             </p>
<p>5.recitation:Augment the BTS structure:<br>data structure: a bunch of algorithms that help you store and retrieve information          </p>
<p>queries : MAX,Min,Next-larger,Search  //ask questions to the data structure and it dose not change<br>updates: Insert,Delete  </p>
<p>check RI(representation invariant):check the entire data structure and make sure the RI holds, if it dose not it raise an exception                                                      </p>
<p>Next-Larger:given a node find the next node which is just larger then this node but smaller then any other node<br>1.go to the right node of the given node.<br>2.go all the way left in this sub tree to find the smallest<br>3.if the given node does not have a right sub tree then the next-larger will be:<br>if given node is the left child of his parent then his parent node  will be<br>if given node is the right child then no next-larger          </p>
<p>Deletion:to delete one node ,first the the next-larger of this node, then replace the node you want to delete with the next-larger node. //1.set the value of node to delete to the value of the next larger, 2. delete the next larger.</p>
<h4 id="lecture-6-ALV-tree-ALV-sort"><a href="#lecture-6-ALV-tree-ALV-sort" class="headerlink" title="lecture 6. ALV tree,ALV sort"></a>lecture 6. ALV tree,ALV sort</h4><p>hight of BST:length of the longest path,in a balanced tree o(log n);<br>hight of a node:length of the longest path from it down to a leaf;<br>Compute the length of a node : Max(length(node.left),length(node.right)) + 1;</p>
<p>AVL Trees<br>AVL property：require hight of left and right children of every node to differ by at most 1;</p>
<p>Nh = min. #nodes in an AVL tree of hight h;<br>Nh = 1 + Nh-1(number of nodes in the right sub tree)+ Nh-2( number of nodes in the left sub tree)<br>Nh = 1 + Nh-1 + Nh-2 &gt;1 + 2<em>Nh-2 &gt; 2</em>Nh-2 = o(2^(h/2))<br>so =&gt; h &lt; 2 <em>lgN and the exact result is 1.44 </em> lgN calculated by the fibonacci series bound</p>
<p>AVL Insertion</p>
<ul>
<li>simple  BST insertion</li>
<li><p>fix AVL property from change node up</p>
</li>
<li><p>suppose x is lowest node violating AVL</p>
</li>
<li>assume x.right higher</li>
<li>if x`s right child is right-heavy or balanced right rotate x</li>
<li>else if right child is left-heavy right rotate x`s right child ad left rotate x;</li>
</ul>
<p>Rotation:<br>left rotate:roof goes to the left<br>right rotate:roof goes to the right</p>
<p>AVL sort:</p>
<ul>
<li>do AVL insert to insert the n items of the array which needs to be sorted; o(n*log n )</li>
<li>do inorder traverse to get the sorted array;   ;o(n)</li>
</ul>
<p>AVL rep invariant:</p>
<ul>
<li>BST</li>
<li>for any node  | hr - hl|&lt;=1;</li>
</ul>
<h4 id="lecture-7"><a href="#lecture-7" class="headerlink" title="lecture : 7"></a>lecture : 7</h4><ul>
<li>comparison model</li>
<li>lower bounds<ul>
<li>searching: o(lgn)</li>
<li>sorting : o(n * lgn)</li>
</ul>
</li>
<li>o(n) sorting algorithms<ul>
<li>counting sort</li>
<li>radix sort</li>
</ul>
</li>
</ul>
<p>Comparison Model</p>
<ul>
<li>all input items are black boxes (abstract data structure )</li>
<li>only operation allowed are comparisons</li>
<li>time cost = # comparison</li>
</ul>
<p>Decision Tree<br>     any comparison algorithm can be viewed as a tree of all possible comparisons and their outcomes and resulting answers,for any particular n item<br>e.g. binary search algorithm with n =3</p>
<table>
<thead>
<tr>
<th>decision tree</th>
<th>algorithm</th>
</tr>
</thead>
<tbody>
<tr>
<td>internal node</td>
<td>binary decisions</td>
</tr>
<tr>
<td>leaf</td>
<td>found answer</td>
</tr>
<tr>
<td>root to leaf</td>
<td>algo execution</td>
</tr>
<tr>
<td>length of path</td>
<td>running time</td>
</tr>
<tr>
<td>the hight of the tree</td>
<td>worst running time</td>
</tr>
</tbody>
</table>
<p>Searching lower bound<br> n preprocessed items , finding a given item among them in comparison model require  o(lgn) in worst case,for lgn<br>is the tree which have the lowest hight and maximum nodes when you look at the decision tree.</p>
<p>Sorting lower bound<br>  number of  leaves &gt;= number of  possible answers n!<br>     hight &gt;= n! &gt;= n *lgn</p>
<p>Counting Sort : o(n+k)</p>
<ol>
<li>initialize an array with length the maximum value +1 of the ints you want to sort</li>
<li>iterate all the values of the ints increment the array with the subscription identical to the values of the ints</li>
<li><p>output the values of the array,output value is the subscription of the array and number of value equals to the value of the specific value of</p>
<pre><code>L:array of K empty lists
for i in range(n);
     L(key(A[j])).append(A[j]);
outPut = [];
for i in range(K);
     outPut.extend(L[i]);
</code></pre></li>
</ol>
<p>counting sort:with position array</p>
<pre><code>sum = k // length of the original array which is the ints to be sorted;
for i =k-1 to 0
     pos[i] = sum - pos[i];//in place changing from the counting array got above to the position array , start with pass0
     sum = pos[i]       //end with pass1
out = [  ];
for i = 0 to k-1
     out[pos[a[i]]] = a[i]; // a[i] is the array needs to be sorted ,basically a[i] value refers to pos`s index and pos`s value refer to out[]`s index
     pos[a[i]] = pos[a[i]] + 1; //by incrementing pos[]
</code></pre><p>property stable: counting sort will items to be sorted the same way as they are unsorted if the items are identical, it does not break the relative relationship  between items if they are the same. stable algorithm is important because in some context,some complex obj will be mapped to numbers and maybe two different obj have the same number. So we want to keep the relative order of the object the same after sorting, if they are mapped to the same numbers.</p>
<p>Radix Sort: d rounds of counting sort             </p>
<ul>
<li>imagine each integer as  base b</li>
<li>#digits = d = logb K</li>
<li>sort ints by  the least significant digit using counting sort<br>……</li>
<li>sort  by the least significant digit  to the most significant digit using counting sort<br>total time : o(n* logn K);</li>
</ul>
<h5 id="lecture-8-Hashing"><a href="#lecture-8-Hashing" class="headerlink" title="lecture 8 Hashing"></a>lecture 8 Hashing</h5><ul>
<li>Dictionary</li>
<li>Motivation</li>
<li>Prehashing</li>
<li>Hashing</li>
<li>Chaining</li>
<li>Simple Uniforme Hashing</li>
<li>Good Hash Function</li>
</ul>
<h6 id="Dictionary-abstract-data-type"><a href="#Dictionary-abstract-data-type" class="headerlink" title="Dictionary : abstract data type"></a>Dictionary : abstract data type</h6><p>maintain a set of items with each item mapped with a key</p>
<ul>
<li><code>insert(item);</code> :will overwrite any existing key</li>
<li><code>delete(item);</code></li>
<li><code>search(key);</code> : return the item of the given key or report error</li>
</ul>
<h6 id="python-dict"><a href="#python-dict" class="headerlink" title="python: dict"></a>python: dict</h6><p>D[key] ~ search<br>D[key] = val ~ insert<br>dele D[key] ~ deletion          </p>
<p>item = ( key, val )</p>
<h6 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h6><ul>
<li>docDict</li>
<li>database</li>
<li>interpreter</li>
</ul>
<h6 id="simple-approach"><a href="#simple-approach" class="headerlink" title="simple approach:"></a>simple approach:</h6><p>Direct - access table:store items in an array, index by key</p>
<h6 id="prehasing"><a href="#prehasing" class="headerlink" title="prehasing"></a>prehasing</h6><ul>
<li>map keys to none negative integers</li>
</ul>
<h6 id="hasing"><a href="#hasing" class="headerlink" title="hasing"></a>hasing</h6><ul>
<li>reduce universe of all keys down to a small set of integers<br>idea :  space m = o(n) ; m is the size of hash table and n is number of keys<br>collision : h(ki) = h(kj) while ki != kj</li>
</ul>
<h6 id="chaining"><a href="#chaining" class="headerlink" title="chaining"></a>chaining</h6><p>linked list of colliding elements in each slot of hash table</p>
<h6 id="hash-functions"><a href="#hash-functions" class="headerlink" title="hash functions"></a>hash functions</h6><ul>
<li>division method: hash(key)  = key mod m ; m is the size of your hash table</li>
<li>multiplication: hash(key) = [(a*key) mod 2^w]&gt;&gt; ( w - r ); w is the number of bits of key which means key has w bits , a is a random integer; m = 2^r;</li>
<li>universal hashing:  hash(key) = [(a*key + b) mod p] mod m; a and b are random numbers {0 …. p-1} ,p is the prime number which is bigger than the universe</li>
</ul>
<h5 id="lecture-9-Table-Doubling-Karp-Rabin"><a href="#lecture-9-Table-Doubling-Karp-Rabin" class="headerlink" title="lecture 9 Table Doubling, Karp-Rabin"></a>lecture 9 Table Doubling, Karp-Rabin</h5><ul>
<li><p>Rolling hash:<br>is a hash function where the input is hashed in a window that moves through the input. One of the main application is Rabin-Karp String search algorithm.</p>
<ul>
<li>r.append(c) : add char c to the end of x</li>
<li>r.skip(c) : delete first char of x</li>
<li>r() :  hash value of x r() = h(x);<br>ps: through the operation above,  we can move the sliding window of rolling hash through out the text we want to hash and get the hash result fast.</li>
</ul>
</li>
<li><p>Karp - Rabin algorithm<br>using hash function in string matching , using rolling hash to quickly compute the hash of strings to match, if the target and the sample`s hash results matches then check the two strings is the same or not, if not continue otherwise return result.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function RabinKarp(string s[<span class="number">1.</span>.n], string pattern[<span class="number">1.</span>.m])</span><br><span class="line">  hpattern := hash(pattern[<span class="number">1.</span>.m]);  hs := hash(s[<span class="number">1.</span>.m]) //预处理两个hash值</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">from</span> <span class="number">1</span> to n-m+<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> hs = hpattern</span><br><span class="line">      <span class="keyword">if</span> s[i..i+m<span class="number">-1</span>] = pattern[<span class="number">1.</span>.m] // 如果hash值相同且字符串相同则返回结果</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    hs := hash(s[i+<span class="number">1.</span>.i+m]) //否则rolling hash到下一个字节</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">not</span> found</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="lecture-10-Open-Addressing-cryptographic-Hashing"><a href="#lecture-10-Open-Addressing-cryptographic-Hashing" class="headerlink" title="lecture 10 Open Addressing cryptographic Hashing"></a>lecture 10 Open Addressing cryptographic Hashing</h4><ul>
<li>Open Addressing</li>
<li>Uniform hashing analysis</li>
<li>Cryptographic hashing</li>
</ul>
<h5 id="Open-Addressing"><a href="#Open-Addressing" class="headerlink" title="Open Addressing"></a>Open Addressing</h5><p>no chaining to deal with collision<br>M ( slot in the hash table using array) N( numbers of elements)<br>M &gt;= N</p>
<ul>
<li>Probing</li>
</ul>
<p>meaning when do hashing trying to insert each item to the table,if it fails which means the given key`s item array is full, then recompute the hash using a different hash function.</p>
<p>Hash function specifies order of slots to probe a key. hash will take U(universe of keys) and C(trial count) to produce keys{1- m-1}</p>
<p>arbitrary K h(k,1),h(k,2)…….h(k,m-1) to be the permutation of 0 , 1 , 2 ,….m-1 which is the slot in the hash table</p>
<ul>
<li><p>Insert(k,v)</p>
<p>   keep probing until an empty slot is founded including delete me flag and none,insert item when found</p>
</li>
<li><p>Search(k)</p>
<p>   As long as the slots probing encountered are occupied by keys != k ,keep probing until encounter k or find an empty slot which means fails to find k in the keys. If encountered delete me keep on probing.</p>
</li>
<li><p>Delete(k)</p>
<p>   As long as the slots probing encountered are not k, keep probing until encounter k and replace the slot with “delete me”.If encounter empty slot then fails to delete.</p>
</li>
</ul>
<h5 id="Probing-strategies"><a href="#Probing-strategies" class="headerlink" title="Probing strategies"></a>Probing strategies</h5><ul>
<li><p>linear probing: h(k,i) = ( h<code>(k) + i ) mod m; h</code>(k) is an ordinary hash function<br>problems: not random and cluster. once there is a cluster you have to do more operations that works for nothing</p>
</li>
<li><p>double hashing : h(k,i ) = ( h1(k) + i* h2(k) ) mod m;<br>If h2(k) is relatively prime to m then we are certain that h(k,i) will have a permutation</p>
</li>
</ul>
<h4 id="lecture-11-Integer-arithmetic-Karatsuba-Multiplication"><a href="#lecture-11-Integer-arithmetic-Karatsuba-Multiplication" class="headerlink" title="lecture 11. Integer arithmetic , Karatsuba Multiplication"></a>lecture 11. Integer arithmetic , Karatsuba Multiplication</h4><ul>
<li>Irrationals</li>
<li>Newton`s Method</li>
<li>High Precision Multiplication</li>
</ul>
<h5 id="Irrationals"><a href="#Irrationals" class="headerlink" title="Irrationals"></a>Irrationals</h5><ul>
<li><p>Catalan numbers<br>Set P of balanced parentheses strings</p>
</li>
<li><p>λ ∈ P (λ is the empty string)</p>
</li>
<li>If α ,β ∈ P , then (α)β ∈P</li>
</ul>
<h5 id="Newton-s-Method"><a href="#Newton-s-Method" class="headerlink" title="Newton`s Method"></a>Newton`s Method</h5><p>－ Root of f(x) = 0 through successive approximation<br><code>xi+1 = xi  - f(xi) / f</code> (xi) ;`</p>
<ul>
<li><p>High precision  multiplication<br>2 n-digits numbers  ( radix r = 2 , 10)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0&lt;= x, y &lt;= r^n ;</span><br><span class="line"></span><br><span class="line">x = x1 * r^(n/2) + x0;     //x1:high half , x0: low half</span><br><span class="line">y = y1 * r^(n/2) + y0;</span><br><span class="line"></span><br><span class="line">0 &lt;= x0,x1 &lt;  r^(n/2);</span><br><span class="line">0 &lt;= y0,y1 &lt;  r^(n/2);</span><br><span class="line"></span><br><span class="line">let</span><br><span class="line">z0 = x0 * y0;</span><br><span class="line">z1 = ( x0*y1 + x1*y0 );</span><br><span class="line">z2 = x2 * y2 ;</span><br><span class="line"></span><br><span class="line">z = x*y = x1*y1*r^n + (x0*y1 + x1*y0) * r^(n/2) + x0*y0</span><br></pre></td></tr></table></figure>
</li>
<li><p>karatsuba algorithm<br>for improving the multiplication process<br>z0 = x0 <em> y0;<br>z2 = x2 </em> y2;<br>z1 = (x0 + x1 )* ( y0 + y1) - z0 - z1;</p>
</li>
</ul>
<h4 id="recitation-11-Principal-of-Algorithm-Design"><a href="#recitation-11-Principal-of-Algorithm-Design" class="headerlink" title="recitation 11 Principal of Algorithm Design"></a>recitation 11 Principal of Algorithm Design</h4><ul>
<li><p>Given a shifted sorted array, find the K element where the biggest mets the smallest number in binary search tree.<br>example:<br>   7, 8 , 9, 1 , 2 , 3 , 4 , 5 , 6</p>
</li>
<li><p>the first element, here is 7,is the most important find the first element in binary search.</p>
</li>
<li><p>if middle is bigger ,search recursively right,otherwise on the left.(if big find bigger , if small find smaller) to find the point where two subarray joined.</p>
</li>
<li><p>Find Kth smallest element in a minimum heap.</p>
</li>
</ul>
<ol>
<li>because of minimum heap, we can use heap property. Because the root is the smallest element, we use:</li>
</ol>
<p><code>A.pop(root);</code></p>
<p>Kth times to get the element we want in O(K * logN) time because retain heap property requires logN time.</p>
<ol start="2">
<li>First chop heap from root to height K,because all paths of length K end to K level and beyond K the element will always be bigger than K because its a min heap.Then find Kth smallest in the heap recursively. Second, set up a augmented heap called horizon which is the container to do the iteration, each time extract-min from it , fill in the min`s children to replace min for that these are the element to find the next min.</li>
</ol>
<p>pseudo code:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">H &lt;- minheap ;</span><br><span class="line">Z &lt;- minheap ; //augmented <span class="keyword">with</span> index of each element to store the min k element</span><br><span class="line">Z.insert( H[<span class="number">1</span>] , <span class="number">1</span> ) ;  //</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>…k)</span><br><span class="line">     (value,index) = Z.extract-min // get out the min element <span class="keyword">and</span> replace <span class="keyword">with</span> its children to compare</span><br><span class="line">     Z.insert( H[<span class="number">2j</span>] , <span class="number">2j</span> );</span><br><span class="line">     Z.insert( H[<span class="number">2j</span> + <span class="number">1</span>] , <span class="number">2j</span> + <span class="number">1</span> );</span><br><span class="line"><span class="keyword">return</span> index;</span><br></pre></td></tr></table></figure></p>
<p>this gives you O(K * logK) running times.</p>
<h4 id="lecture-12-Square-Root-Newton-s-Method"><a href="#lecture-12-Square-Root-Newton-s-Method" class="headerlink" title="lecture 12 Square Root, Newton`s Method"></a>lecture 12 Square Root, Newton`s Method</h4><ul>
<li>Multiplication , Division</li>
<li>Algorithm Complexity</li>
</ul>
<h5 id="High-precision-Division"><a href="#High-precision-Division" class="headerlink" title="High-precision Division"></a>High-precision Division</h5><ul>
<li>set f(x) = 1/x - b/R ;<br>so when we trying to do f(x) = 0, we will get 1/x = b/R  so x = R/b;<br>applying Newton iteration:<br>Xi+1 = Xi - f(Xi)/f`(Xi) = 2Xi - (b*Xi^2)/R</li>
</ul>
<h4 id="Recitation"><a href="#Recitation" class="headerlink" title="Recitation"></a>Recitation</h4><h5 id="Karatsuba-Multiplication"><a href="#Karatsuba-Multiplication" class="headerlink" title="Karatsuba Multiplication"></a>Karatsuba Multiplication</h5><p>usually multiplication take a time of O(N^2) complexity whereas KM takes O( N * log2 3).<br>It takes 2 N numbers, split it into N/2 numbers and do 3 multiplications and addition then we have T(n) = 3T(N/2) + O(N).</p>
<h4 id="lecture-13-Breadth-First-Search-BFS"><a href="#lecture-13-Breadth-First-Search-BFS" class="headerlink" title="lecture 13 Breadth First Search (BFS)"></a>lecture 13 Breadth First Search (BFS)</h4><h5 id="Graph-Search"><a href="#Graph-Search" class="headerlink" title="Graph Search"></a>Graph Search</h5><p>graph G = ( V , E ); V is a set of vertices and E is a set of edges.<br>if the edges have directions then the G is directed graph otherwise is undirected graph.</p>
<p>Applications:</p>
<ul>
<li>web crawling</li>
<li>social networking</li>
<li>network broadcast</li>
<li>garbage collection</li>
<li>model checking</li>
<li>solve puzzles and games</li>
</ul>
<p>Graph representation:</p>
<ul>
<li>adjacent list:<br>array Adj of size |V|;<br>each element in the array is a pointer to link list;<br>the array is indexed by the vertex so for every vertex v,<br>Adj[v] = {one step accessible neighbours of v };</li>
</ul>
<h5 id="Breadth-first-search"><a href="#Breadth-first-search" class="headerlink" title="Breadth first search"></a>Breadth first search</h5><ul>
<li>visit all node s reachable from given set V</li>
<li>O (V + E ) time</li>
<li>look at nodes reachable in 1 moves , 2 moves ……</li>
<li>carefully avoid duplicates , not revisiting vertices.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">BFS(s,Adj):</span><br><span class="line">level = &#123;s:none&#125;;// dictionary <span class="keyword">with</span> key s <span class="keyword">and</span> value none;</span><br><span class="line">parent = &#123;s: none&#125;</span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line">frontier = [s];</span><br><span class="line"><span class="keyword">while</span>  frontier:</span><br><span class="line">     next = [];</span><br><span class="line">          <span class="keyword">for</span>  u <span class="keyword">in</span> frontier:</span><br><span class="line">               <span class="keyword">for</span> v <span class="keyword">in</span> Adj[u]:</span><br><span class="line">                    <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> level:</span><br><span class="line">                         leve[v] = i;</span><br><span class="line">                         parent[v] = u;</span><br><span class="line">                         next.append(v);</span><br><span class="line">frontier = next;</span><br><span class="line">i += <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="lecture-14-Depth-First-Search-DFS"><a href="#lecture-14-Depth-First-Search-DFS" class="headerlink" title="lecture 14 Depth First Search (DFS)"></a>lecture 14 Depth First Search (DFS)</h4><ul>
<li>recursively explore the graph,back tracking as necessary</li>
<li>careful not to repeat vertices</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">parent = &#123;s : none&#125;;<span class="comment">#dictionary to prevent repeat</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DFS</span> - <span class="title">Visit</span><span class="params">( V , Adj , s )</span>:</span> <span class="comment">#can visit vertices reachable from s</span></span><br><span class="line">          <span class="keyword">for</span> v <span class="keyword">in</span> Adj[s]:</span><br><span class="line">               <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> parent:</span><br><span class="line">                    parent[v] = s;</span><br><span class="line">                    DFS-Visit(V,Adj,v);</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DFS</span><span class="params">( V , Adj )</span>:</span> <span class="comment"># top level algorithm</span></span><br><span class="line">parent = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> V:</span><br><span class="line">     <span class="keyword">if</span> s <span class="keyword">not</span> <span class="keyword">in</span> parent:</span><br><span class="line">          parent[s] = <span class="keyword">None</span></span><br><span class="line">          DFS-Visit( V , Adj , s)</span><br></pre></td></tr></table></figure>
<p>Analysis: O (V + E );linear time</p>
<h5 id="Edge-Classification"><a href="#Edge-Classification" class="headerlink" title="Edge Classification:"></a>Edge Classification:</h5><ul>
<li>tree edge: (parent pointer) visit new vertex via edge</li>
<li>forward edges: node -&gt; descendent</li>
<li>backward edges: node -&gt; ancestor</li>
<li>crossward edges: all other edges beside the two above, between sibling vertices</li>
</ul>
<h5 id="Cycle-Detection"><a href="#Cycle-Detection" class="headerlink" title="Cycle Detection:"></a>Cycle Detection:</h5><p>G has a cycle &lt;=&gt; G has a back edge</p>
<h5 id="Topological-Sort"><a href="#Topological-Sort" class="headerlink" title="Topological Sort:"></a>Topological Sort:</h5><ul>
<li><p>Job scheduling:<br>given a undirected acyclic graph (DAG),order vertices so that all edges point from lower order to higher order.</p>
</li>
<li><p>sort:<br>run DFS , output the reverse of finish times of vertices</p>
</li>
</ul>
<h4 id="lecture-15-Single-Source-Shortest-Paths-Problem"><a href="#lecture-15-Single-Source-Shortest-Paths-Problem" class="headerlink" title="lecture 15 Single-Source Shortest Paths Problem"></a>lecture 15 Single-Source Shortest Paths Problem</h4><ul>
<li><p>Dijkstra: non-negative weight edges<br>complexity: O( v*(lg v) + E);</p>
</li>
<li><p>Bellman-Ford :+/- weight edges<br>complexity: O ( v*E ) ;<br>negative circle can make path weight to infinite</p>
</li>
</ul>
<h5 id="weighted-graphs"><a href="#weighted-graphs" class="headerlink" title="weighted graphs"></a>weighted graphs</h5><p>shortest path from u to v is :<br>delta(u,v) = min { path(u -&gt; v) } if path exist, else  infinite;<br>d(u) is the current weight represented in side vertices;<br>Pi[v] is the predecessor vertex on the best path to v; Pi[source] = nil</p>
<h5 id="general-structure-of-shortest-path-algorithm-none-negative-value"><a href="#general-structure-of-shortest-path-algorithm-none-negative-value" class="headerlink" title="general structure of shortest path algorithm // none negative value"></a>general structure of shortest path algorithm // none negative value</h5><p>initialise for all u ∈ V  , set d(V) = infinite , set Pi[V] = nil<br>d(source) = 0;<br>Repeat select edge(u,v): // somehow<br>     Relax edge(u,v):<br>          if d(v) &gt; d(u) + w(u,v):<br>               d(v) = d(u) + w(u,v);<br>               Pi(v) = u;<br> until all edges have d(v) &lt;= d(u) + w(u,v);</p>
<h5 id="optimum-substructure-property"><a href="#optimum-substructure-property" class="headerlink" title="optimum substructure property"></a>optimum substructure property</h5><ul>
<li>Subpaths of a shortest path are shortest paths</li>
</ul>
<h4 id="lecture-16-Dijkstra-s-Algorithm"><a href="#lecture-16-Dijkstra-s-Algorithm" class="headerlink" title="lecture 16    Dijkstra`s Algorithm"></a>lecture 16    Dijkstra`s Algorithm</h4><p>Relaxation:<br>d[v] : length of current vertex from source<br>w(s,v):length of a shortest path from s to v<br>π[v] : predecessor of v in the path from s to v<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Relax( u, v, w  )</span><br><span class="line">    <span class="keyword">if</span> d[v] &gt; d[u] + w(u,v)</span><br><span class="line">        d[v]  = d[u] + w(u,v)</span><br><span class="line">        π[v] = u</span><br></pre></td></tr></table></figure></p>
<p>Relaxation is safe</p>
<p>Dijkstra:</p>
<pre><code class="python">Dijkstra(G,w,s) // G graph, w weight, s source
    Initialise(G,s)  ;      S = NULL;    Q = V[G];   // S <span class="keyword">is</span> empty set, Q <span class="keyword">is</span> the set of all vertexes //initialise set d[s] = <span class="number">0</span>
    <span class="keyword">while</span> Q != NULL
        u = Extract_Min(Q);        //delete u <span class="keyword">from</span> q
        S = S + u;
        <span class="keyword">for</span> each vertex v belonging to Adjacent(u):
            Relax(u,v,w);
</code></pre>
	  
	</div>

	<!-- recommended posts -->
	

	<div>
  	<center>
	<div class="pagination">
<ul class="pagination">
	 
				
    	<li class="prev"><a href="/2016/07/06/OC编程全解读书笔记/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>Prev</a></li>
  		

        <li><a href="/archives"><i class="fa fa-archive"></i>Archive</a></li>

		
		   <li class="next"><a href="/2016/05/05/LintCode-LeetCode-algorithms-Easy/" class="alignright next">Next<i class="fa fa-arrow-circle-o-right"></i></a></li>         
        
	
</ul>
</div>

    </center>
	</div>

    <!-- share -->
    
        

        

    
	
	<!-- comment -->
	
<section id="comment">
  <h2 class="title">Comments</h2>
  
  	 <div id="disqus_thread">
     <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  	 </div>
  
</section>


	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2016-06-05 
	</div>
	

	<!-- categories -->
    

	<!-- tags -->
	

	<!-- toc -->
	<div class="meta-widget">
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>
		

</div><!-- row -->

<script type="text/javascript">
var disqus_shortname = 'leoweng';
(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2018 Léo WENG
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>


<!-- syntax highlighting -->


</body>
   </html>

<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Key Algorithms | Léo`s Blog</title>
  <meta name="author" content="Léo WENG">
  
  <meta name="description" content="[TOC]
Quick Sort
explain:Set a pivot point in the array,all bigger than pivot to the right and all smaller than pivot to the left.divide the array through the pivot point into two subarray and do the sorting recursively.

The steps are:1 Pick an element, called a pivot, from the array.2 Partitioning: reorder the array so that all elements with values less than the pivot come before the pivot, while all elements with values greater than the pivot come after it (equal values can go either way). After this partitioning, the pivot is in its final position. This is called the partition operation.3 Recursively apply the above steps to the sub-array of elements with smaller values and separately to the sub-array of elements with greater values.

分治法，快速排序

数组中找一个中心点，把大于中心点的放在右，小于中心点的放在左。在中心点左右两个子数组中迭代的使用快速排序再排列。伪代码给出的实现方法用双指针法，把数组最右边元素当做中心点，前一个指针遍历数组，后一个指针纪录比中心点小的元素子列头位置，一旦前面指针遍历到有比中心点小的元素，则后面指针自增一并与前指针交换元素，形成前大于中心点子数组和后小于中心点子数组。最后把最右边的中心点与后指针加一位置元素交换再对两个子数组迭代。
步骤：1 选中心点，一般为数组结尾元素。2 分隔：重新调整数组，使比中心点小的元素在数组左边，比中心点大的元素在数组右边。分隔之后中心点在两个子数组中间。3 在比中心点小的元素子数组和比中心大的子数组上迭代以上步骤，直到排序完成。

pseudo code:
123456789101112131415QuickSort(Array A,fistIndex p,lastIndex r) //p and r represent the range to sortif  p &amp;lt; r:     q = Partition(A,p,r);     QuickSort(A,p,q-1);     QuickSort(A,q+1,r);Partition(Array A,startIndex p,endIndex r)x = A[r];i = p - 1;for j = p to r -1:     if A[j] &amp;lt;= x :          i = i + 1;          exchange A[i] with A[j]; //if A[j] is smaller than pivot point,put into left subarrayexchange A[i + 1] with A[r]; // after iteration put pivot into where it divide the two subarrays.return i + 1; // return the index of the pivot point

runtime O( )worst case: O(n^2);best case: O(n  log n) or O(n);average case performance : O(n  log n);">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Key Algorithms"/>
  <meta property="og:site_name" content="Léo`s Blog"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/favicon.icon" rel="icon">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/css/themes/flatly.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight-default.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/comment.css" media="screen" type="text/css">
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.9/es5-shim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.7/es5-sham.min.js"></script>
  <![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>
  
  <!-- analytics -->
  



</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
       <a class="navbar-brand" href="/">Léo`s Blog</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header page-header-inverse ">		
			<h1 class="title title-inverse "> Key Algorithms</h1>
		</div>		
	






<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <p>[TOC]</p>
<h1 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h1><ul>
<li>explain:<br>Set a pivot point in the array,all bigger than pivot to the right and all smaller than pivot to the left.divide the array through the pivot point into two subarray and do the sorting recursively.</li>
</ul>
<p>The steps are:<br>1 Pick an element, called a pivot, from the array.<br>2 Partitioning: reorder the array so that all elements with values less than the pivot come before the pivot, while all elements with values greater than the pivot come after it (equal values can go either way). After this partitioning, the pivot is in its final position. This is called the partition operation.<br>3 Recursively apply the above steps to the sub-array of elements with smaller values and separately to the sub-array of elements with greater values.</p>
<ul>
<li>分治法，快速排序</li>
</ul>
<p>数组中找一个中心点，把大于中心点的放在右，小于中心点的放在左。在中心点左右两个子数组中迭代的使用快速排序再排列。伪代码给出的实现方法用双指针法，把数组最右边元素当做中心点，前一个指针遍历数组，后一个指针纪录比中心点小的元素子列头位置，一旦前面指针遍历到有比中心点小的元素，则后面指针自增一并与前指针交换元素，形成前大于中心点子数组和后小于中心点子数组。最后把最右边的中心点与后指针加一位置元素交换再对两个子数组迭代。</p>
<p>步骤：<br>1 选中心点，一般为数组结尾元素。<br>2 分隔：重新调整数组，使比中心点小的元素在数组左边，比中心点大的元素在数组右边。分隔之后中心点在两个子数组中间。<br>3 在比中心点小的元素子数组和比中心大的子数组上迭代以上步骤，直到排序完成。</p>
<ul>
<li><p>pseudo code:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">QuickSort(Array A,fistIndex p,lastIndex r) //p <span class="keyword">and</span> r represent the range to sort</span><br><span class="line"><span class="keyword">if</span>  p &lt; r:</span><br><span class="line">     q = Partition(A,p,r);</span><br><span class="line">     QuickSort(A,p,q<span class="number">-1</span>);</span><br><span class="line">     QuickSort(A,q+<span class="number">1</span>,r);</span><br><span class="line"></span><br><span class="line">Partition(Array A,startIndex p,endIndex r)</span><br><span class="line">x = A[r];</span><br><span class="line">i = p - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> j = p to r <span class="number">-1</span>:</span><br><span class="line">     <span class="keyword">if</span> A[j] &lt;= x :</span><br><span class="line">          i = i + <span class="number">1</span>;</span><br><span class="line">          exchange A[i] <span class="keyword">with</span> A[j]; //<span class="keyword">if</span> A[j] <span class="keyword">is</span> smaller than pivot point,put into left subarray</span><br><span class="line">exchange A[i + <span class="number">1</span>] <span class="keyword">with</span> A[r]; // after iteration put pivot into where it divide the two subarrays.</span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span>; // <span class="keyword">return</span> the index of the pivot point</span><br></pre></td></tr></table></figure>
</li>
<li><p>runtime O( )<br>worst case: O(n^2);<br>best case: O(n <em> log n) or O(n);<br>average case performance : O(n </em> log n);</p>
<a id="more"></a>
</li>
</ul>
<h1 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h1><ul>
<li><p>explanation:<br>Iterate from left of the array to the right of the array. For each iteration item, bubble sort left subarray to its  position.In place sort.<br>插入排序为原位排序，不需要多余空间复杂度。从数组左边遍历到右边，对于每一个遍历元素向左冒泡到其位置。</p>
</li>
<li><p>pseudo code:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">INSERTION-SORT(A)</span><br><span class="line"><span class="keyword">for</span> j = <span class="number">1</span> to A.length - <span class="number">1</span>:</span><br><span class="line">     key = A[ j ];// insert key to subarray A[<span class="number">0</span> … j - <span class="number">1</span>]</span><br><span class="line">     i = j - <span class="number">1</span> ;</span><br><span class="line">     <span class="keyword">while</span> i &gt;= <span class="number">0</span>  <span class="keyword">and</span> A[ i ] &gt; key: //bubble sort</span><br><span class="line">          A[i + <span class="number">1</span>] = A[ i ];     // <span class="keyword">if</span> <span class="keyword">not</span> shift right</span><br><span class="line">          i = i - <span class="number">1</span>;</span><br><span class="line">     A[i + <span class="number">1</span>] = key; // <span class="keyword">if</span> yes insert</span><br></pre></td></tr></table></figure>
</li>
<li><p>runtime:<br>worst case : O ( n <em> (n</em>(n+1))/2) = O(n^2);<br>best case : O(n) , with n*(n+1)/2 = 1;<br>average case : O (n^2);</p>
</li>
</ul>
<h1 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort:"></a>Merge Sort:</h1><p>Merge Sort algorithm follows the divide-and-conquer paradigm closely.<br>For each iteration we follow the instructions below:</p>
<ul>
<li>Divide:Divide the array into two n/2 subarray.</li>
<li>Conquer: Sort the two array recursively using merge sort</li>
<li>Combine: Merge the two sorted subarray</li>
</ul>
<p>对于每一次迭代，有3步走：</p>
<ul>
<li>切分为两部分，</li>
<li>对两部分迭代mergeSort算法</li>
<li>把排序过的两部分融合。</li>
</ul>
<p>通过把数列分解成单个元素，在融合单个元素的过程中在原位排序。</p>
<ul>
<li>pseudo code:</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">MergeSort(A, startIndex, endIndex)      //to initialise the sorting, MergeSort(A,<span class="number">0</span>,A.length)</span><br><span class="line"><span class="keyword">if</span> startIndex &lt; endIndex :</span><br><span class="line">     midIndex = Math.round((startIndex + endIndex) / <span class="number">2</span> ); //divide</span><br><span class="line">     MergeSort(A,startIndex , midIndex);     //conquer</span><br><span class="line">     MergeSort(A,midIndex + <span class="number">1</span> , endIndex);</span><br><span class="line">     Merge(A , startIndex, endIndex);     //combine</span><br><span class="line"></span><br><span class="line">Merge(A, startIndex , midIndex , endIndex)</span><br><span class="line">n1 = midIndex - startIndex +<span class="number">1</span>;</span><br><span class="line">n2 = endIndex - midIndex ;</span><br><span class="line">let L[n1 + <span class="number">1</span>],R[n2 + <span class="number">1</span>] be new arrays;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">0</span> to n1 - <span class="number">1</span>:     //<span class="keyword">from</span> starIndex to midIndex</span><br><span class="line">     L[ i ] = A[startIndex + i ];</span><br><span class="line"><span class="keyword">for</span> j = <span class="number">0</span> to n2 <span class="number">-1</span>:     //<span class="keyword">from</span> midIndex + <span class="number">1</span> to endIndex</span><br><span class="line">     R[ j ] = A[(midIndex + <span class="number">1</span>) + j ];</span><br><span class="line">L[n1] = infinite;      //here use two infinite so that the <span class="keyword">for</span> loop below don`t need to decide whether any subarray are iterate out</span><br><span class="line">R[n2] = infinite;</span><br><span class="line">i = <span class="number">0</span> ;</span><br><span class="line">j = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> k = startIndex to endIndex:</span><br><span class="line">     <span class="keyword">if</span> L[i] &lt;= R[j]:</span><br><span class="line">          A[k] = L[i];</span><br><span class="line">          i = i + <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">else</span>:</span><br><span class="line">          A[k] = R[j];</span><br><span class="line">          j = j + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h1 id="Binary-converter"><a href="#Binary-converter" class="headerlink" title="Binary converter"></a>Binary converter</h1><p>Convert a Decimal number to binary sequence by applying Decimal-Binary convert algorithm.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(x / <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">          convert(x / <span class="number">2</span>);     <span class="comment">//recursion to the bound</span></span><br><span class="line">          print(<span class="string">"%d"</span>,x%<span class="number">2</span>);</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          print(<span class="string">"%d"</span>,x);      <span class="comment">//print the last bit</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Tips-For-XOR"><a href="#Tips-For-XOR" class="headerlink" title="Tips For XOR(^)"></a>Tips For XOR(^)</h1><ol>
<li><p>to perform NOT(!) on certain bit<br>ex. a = 01111010(binary) , b = 00001111(binary);<br>  c = a^b;<br>result of c is 01110101, which means a^b performs a NOT operation on last 4bits of a.</p>
</li>
<li><p>exchange two values of two variable without defining a temp variable .</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">swapNoTemp</span>(<span class="title">T</span> &amp;<span class="title">a</span>,<span class="title">T</span> &amp;<span class="title">b</span>)&#123;</span></span><br><span class="line">     <span class="keyword">if</span> (a != b)&#123; <span class="comment">// if a == b or &amp;a == &amp;b; than no need to swap</span></span><br><span class="line">          a = a^b;</span><br><span class="line">          b = b^a;</span><br><span class="line">          a = a^b;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Tips-For-AND-amp-and-OR"><a href="#Tips-For-AND-amp-and-OR" class="headerlink" title="Tips For AND(&amp;) and OR(|)"></a>Tips For AND(&amp;) and OR(|)</h1><ol>
<li><p>In bit manipulation, <code>&amp;</code> AND can be used to set some bits to zero while other bits remain its value. Set the mask byte the bit zero where you want to erase, and set one where you want to maintain its value.<br>ex.  n &amp; = 0xffffff00;//set the last 8 bits to zero and others bits remain the same. </p>
</li>
<li><p>Often used to manipulate bits that you can set certain bits to 1 while keep other bits. Set the bits in the mask to 1 where you want to set to 1 in the byte to be set, and set bits in mask 0 to remain the value of corresponding bits in the bits which you want to set.<br>ex.  n | = 0xff;// set last 8 bits of n to all one</p>
</li>
</ol>
<h1 id="KMP-String-Match-Algorithm-KMP字符串算法"><a href="#KMP-String-Match-Algorithm-KMP字符串算法" class="headerlink" title="KMP String Match Algorithm KMP字符串算法"></a>KMP String Match Algorithm KMP字符串算法</h1><p>已知，匹配字符串P = p0p1p2……pj-1pj;<br>目标字符串T = t0t1t2…..tn-1;</p>
<ul>
<li>特征向量N：用了表示模式P字符分布特征,N有时也称next数组<br>N =    n0n1n2….nm-1 ​;<br>N[j] 当j=0时N[j] = -1; 其他时候N[j] 等于j位置之前P的收尾最长匹配串长度k(意为，头尾两个可重叠的相等的子串的长度)。</li>
</ul>
<p>做法：<br>顺序从头开始对比P和T字符串：</p>
<ol>
<li>如果出现了不同pj和ti，查表N[j] = k;</li>
<li>用P[k]和当前出错的位置对齐开始比较</li>
</ol>
<p>KMPMatching c++ 实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMPStrMatching</span><span class="params">(<span class="built_in">string</span> T, <span class="built_in">string</span> P, <span class="keyword">int</span> *N, <span class="keyword">int</span> start)</span> </span>&#123; 、</span><br><span class="line">    <span class="keyword">int</span> j= <span class="number">0</span>;<span class="comment">// 模式的下标变量</span></span><br><span class="line">    <span class="keyword">int</span> i = start; <span class="comment">// 目标的下标变量</span></span><br><span class="line">    <span class="keyword">int</span> pLen = P.length( );<span class="comment">// 模式的长度</span></span><br><span class="line">    <span class="keyword">int</span> tLen = T.length( );  <span class="comment">// 目标的长度</span></span><br><span class="line">    <span class="keyword">if</span> (tLen - start &lt; pLen)</span><br><span class="line">         <span class="keyword">return</span> (<span class="number">-1</span>);   <span class="comment">// 若目标比模式短，匹配无法成功 </span></span><br><span class="line">    <span class="keyword">while</span> ( j &lt; pLen &amp;&amp; i &lt; tLen) &#123; <span class="comment">// 反复比较，进行匹配</span></span><br><span class="line">        <span class="keyword">if</span> ( j == <span class="number">-1</span> ||T[i] == P[j])</span><br><span class="line">             i++, j++;       </span><br><span class="line">        <span class="keyword">else</span> j = N[j];    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span> (j &gt;= pLen)       </span><br><span class="line">        <span class="keyword">return</span> (i-pLen);    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> (<span class="number">-1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>求特征向量N(Next)的函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findNext</span><span class="params">(<span class="built_in">string</span> P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, k;</span><br><span class="line">    <span class="keyword">int</span> m = P.length( );    <span class="comment">// m为模式P的长度</span></span><br><span class="line">    <span class="keyword">int</span> *next = <span class="keyword">new</span> <span class="keyword">int</span>[m];  <span class="comment">//动态存储区开辟整数数组</span></span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;  </span><br><span class="line">    j=<span class="number">0</span>; k=<span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">while</span> (j &lt; m<span class="number">-1</span>)&#123;    <span class="comment">//写成   j &lt; m 会越界          </span></span><br><span class="line">        <span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; P[k] != P[j])  <span class="comment">//若不等，采用 KMP 找首尾子串</span></span><br><span class="line">            k = next[k]; <span class="comment">// k 递归地向前找</span></span><br><span class="line">        j++; </span><br><span class="line">        k++;</span><br><span class="line">    <span class="keyword">if</span> (P[k] == P[j])            </span><br><span class="line">        next[j] = next[k];       <span class="comment">// 前面找 k 值，没有受优化的影响  </span></span><br><span class="line">    <span class="keyword">else</span> next[j] = k;            <span class="comment">// 取消if判断，则不优化</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> next; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
	  
	</div>

	<!-- recommended posts -->
	

	<div>
  	<center>
	<div class="pagination">
<ul class="pagination">
	 
				
    	<li class="prev"><a href="/2016/08/27/LintCode-Medium-Java-Solution/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>Prev</a></li>
  		

        <li><a href="/archives"><i class="fa fa-archive"></i>Archive</a></li>

		
		   <li class="next"><a href="/2016/07/06/OC编程全解读书笔记/" class="alignright next">Next<i class="fa fa-arrow-circle-o-right"></i></a></li>         
        
	
</ul>
</div>

    </center>
	</div>

    <!-- share -->
    
        

        

    
	
	<!-- comment -->
	
<section id="comment">
  <h2 class="title">Comments</h2>
  
  	 <div id="disqus_thread">
     <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  	 </div>
  
</section>


	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2016-07-13 
	</div>
	

	<!-- categories -->
    

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/算法总结/">算法总结<span>1</span></a></li>
    </ul>
	</div>
	

	<!-- toc -->
	<div class="meta-widget">
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>
		

</div><!-- row -->

<script type="text/javascript">
var disqus_shortname = 'leoweng';
(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2018 Léo WENG
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>


<!-- syntax highlighting -->


</body>
   </html>

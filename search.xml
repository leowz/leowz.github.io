<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>JsTips</title>
      <link href="/2018/05/16/JsTips/"/>
      <url>/2018/05/16/JsTips/</url>
      <content type="html"><![CDATA[<h2 id="Data-types"><a href="#Data-types" class="headerlink" title="Data types"></a>Data types</h2><p>Primitive Data types</p><ul><li>string</li><li>number  </li><li>boolean (true| false lowercase)</li><li>undefined </li></ul><p>Complex Data types</p><ul><li>function (Function object)</li><li>object</li></ul><h2 id="Inheritance-and-the-prototype-chain"><a href="#Inheritance-and-the-prototype-chain" class="headerlink" title="Inheritance and the prototype chain"></a>Inheritance and the prototype chain</h2><p>Javascript uses the prototypal inheritance form. Object inherit directly from other objects. </p><p>Each object has a private property which holds a link to another object called its <code>prototype</code>. That prototype object has a prototype of its own and so on util an object is reached with <code>null</code> as its prototype. <code>null</code> here acts as the final link in this prototype chain.</p><p>Nearly, all object in JS are instances of <code>Object</code> which sits on the top of a prototype chain.</p><h3 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h3><p>JS objects are dynamic bags of properties. JS objects have a link to a prototype object. When trying to access a property of an object, the property will not only search the object but on the property of the object also, until either a property with a bathing name is found or the end of the prototype chain is reached.</p><p>ways to create the prototype chain:</p><ul><li>syntax constructs</li><li>constructor (new keyword)</li><li>Object.create</li><li>class, extends</li></ul><p>example:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = [<span class="string">"yo"</span>, <span class="string">"whadup"</span>, <span class="string">"?"</span>];</span><br><span class="line"><span class="comment">/* Arrays inherit from Array.prototype </span></span><br><span class="line"><span class="comment"> (which has methods indexOf, forEach, etc.)</span></span><br><span class="line"><span class="comment"> The prototype chain looks like:</span></span><br><span class="line"><span class="comment"> b ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; null;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Functions inherit from Function.prototype </span></span><br><span class="line"><span class="comment"> (which has methods call, bind, etc.)</span></span><br><span class="line"><span class="comment"> f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Graph</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.vertices = [];</span><br><span class="line">  <span class="keyword">this</span>.edges = [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = <span class="keyword">new</span> Graph();</span><br><span class="line"><span class="comment">/* g is an object with own properties 'vertices' and 'edges'.</span></span><br><span class="line"><span class="comment"> g.[[Prototype]] is the value of Graph.prototype when new Graph() is executed.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;; </span><br><span class="line"><span class="comment">// a ---&gt; Object.prototype ---&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.create(a);</span><br><span class="line"><span class="comment">// b ---&gt; a ---&gt; Object.prototype ---&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line"> …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="JavaScript-Functions"><a href="#JavaScript-Functions" class="headerlink" title="JavaScript Functions"></a>JavaScript Functions</h2><p>Every function in JS is a <code>Function</code> object, they have properties and methods just like any other object. However, functions can be called.</p><p>Properties:</p><ul><li>Function.arguments</li><li>Function.caller</li><li>Function.length</li><li>Function.name</li><li>Function.prototype</li></ul><p>Methods:</p><ul><li>Function.prototype.apply()</li><li>Function.prototype.bind()</li><li>Function.prototype.call()</li><li>Function.prototype.toString()</li></ul><h3 id="Create-functions"><a href="#Create-functions" class="headerlink" title="Create functions"></a>Create functions</h3><p>function declaration and function expression<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function1(width, height) &#123;</span><br><span class="line">    <span class="keyword">return</span> width * height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getRectArea = function2(width, height) &#123;</span><br><span class="line">    <span class="keyword">return</span> width * height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>arrow function expression<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">([param]) =&gt; &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="JavaScript-Objects"><a href="#JavaScript-Objects" class="headerlink" title="JavaScript Objects"></a>JavaScript Objects</h2><p>Objects are variable that contain many key value pars. Name and blues is spared by a colon(:) and each pair is separated by coma(,).<br>Object properties can be primitive values, other objects or functions.</p><p>Properties:</p><ul><li>Object.prototype</li><li>Object.prototype.constructor</li></ul><p>Methods:</p><ul><li>Object.assign() : Copies the values from one object to a targe object</li><li>Object.create() : Create object</li><li>Object.is() : compare two object are the same</li><li>Object.keys() : return an array of all key of the object</li><li>Object.values() : return an array of all values</li></ul><p>creating a JS object:</p><ol><li>object literal ({key1: val1, key2: val2})</li><li>using keyword new  (var person = new Object())</li></ol><p>Objects are mutable; they are addressed by reference.</p><h3 id="object-properties"><a href="#object-properties" class="headerlink" title="object properties"></a>object properties</h3><p>accessing the property of an object:</p><ul><li>objectName.property</li><li>objectName[“property”]</li></ul><p>adding new properties:<br>add new properties by simply giving it a value<br><code>person, nationality = “English”;</code></p><p>deleting properties:<br>use delete keyword<br><code>delete person.age;</code></p><h3 id="this-Keyword"><a href="#this-Keyword" class="headerlink" title="this Keyword"></a>this Keyword</h3><p>Every new function has its own this value, this is the new object in case of a constructor, undefined in strict mode function calls, this represents the context object if the function is called as an “object method” etc.</p><p>Note that, this holds the value of undefined in global functions and in anonymous functions that are not bound to any object.</p><h4 id="this-in-the-global-scope"><a href="#this-in-the-global-scope" class="headerlink" title="this in the global scope"></a>this in the global scope</h4><p>In the global scope, when the code is executing in the browser, a functions with this, this refers to the global <code>window</code> object(not in strict mode) that is the main container of the entire JS application.</p><h4 id="context"><a href="#context" class="headerlink" title="context"></a>context</h4><p>The object that invokes a function is in the context, we can change the context by invoking a function with another object, then this new object is in context.</p><h4 id="this-in-a-callback-function"><a href="#this-in-a-callback-function" class="headerlink" title="this in a callback function"></a>this in a callback function</h4><p>When we execute a method passed from another object as a callback function. This keyword refers to current object and not the original object that defines the callback function. It refers to the object where the method is invoked.<br>So if the callback function contains <code>this</code> key word. The behaviour of function will not be correct.</p><p><strong>fix:</strong><br>Use <code>Bind()</code> , <code>Apply()</code> or <code>Call()</code> method to specifically set the value of this.</p><h4 id="this-inside-closure"><a href="#this-inside-closure" class="headerlink" title="this inside closure"></a>this inside closure</h4><p>It is important to note that closures cannot access the outer function’s this variable by using <code>this</code> keyword. Inside an anonymous function, <code>this</code> is bound to the global window(or undefined in strict mode).</p><p><strong>fix:</strong><br>Just set <code>this</code> value to another variable so that closure can capture the variable.</p><p>example:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123; </span><br><span class="line">tournament:<span class="string">"The Masters"</span>,</span><br><span class="line">data :[ </span><br><span class="line">&#123;<span class="attr">name</span>:<span class="string">"T. Woods"</span>, <span class="attr">age</span>:<span class="number">37</span>&#125;, </span><br><span class="line">&#123;<span class="attr">name</span>:<span class="string">"P. Mickelson"</span>, <span class="attr">age</span>:<span class="number">43</span>&#125; </span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">clickHandler:<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> theUserObj = <span class="keyword">this</span>; </span><br><span class="line">    <span class="keyword">this</span>.data.forEach (<span class="function"><span class="keyword">function</span> (<span class="params">person</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log (person.name + <span class="string">" is playing at "</span> + theUserObj.tournament); </span><br><span class="line">        &#125;) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="this-passed-as-a-variable"><a href="#this-passed-as-a-variable" class="headerlink" title="this passed as a variable"></a>this passed as a variable</h4><p>When pass a method as a variable that contains <code>this</code>, it is the same case with the callback function.<br>The fix is by setting <code>this</code> value using <code>bind()</code> method.</p>]]></content>
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CssTips</title>
      <link href="/2018/05/12/CssTips/"/>
      <url>/2018/05/12/CssTips/</url>
      <content type="html"><![CDATA[<h2 id="Position-property"><a href="#Position-property" class="headerlink" title="Position property"></a>Position property</h2><ul><li>static (default)</li><li>relative</li><li>fixed</li><li>absolute</li><li>sticky</li></ul><p>elements are then positioned using the: top, bottom, left, right properties. However, position must be set first to let the others to work.</p><p><strong>relative</strong>:<br>    relative to its normal position<br>    top, right, bottom, left will cause it to be adjusted away from its original position</p><p><strong>fixed</strong>:<br>    stay relative to the viewport(the screen)<br>    will not move even the page is scrolled</p><p><strong>absolute</strong>:<br>    positioned relative to the nearest positioned ancestor</p><p><strong>sticky</strong>:<br>    is positioned based on the user’s scroll position. sticky when scroll to it.</p><a id="more"></a><h2 id="Overflow-property"><a href="#Overflow-property" class="headerlink" title="Overflow property"></a>Overflow property</h2><ul><li>visible: will render out side of element box</li><li>hidden: overflow clipped, the rest of the content will be invisible</li><li>scroll: a scroll bar is added to the overflow part</li><li>auto: </li></ul><p>When the content of an element is too big to display in the specified area, add scrollbar to this element. </p><p>overflow-x, overflow-y two specific properties for overflow</p><h2 id="Float-amp-Clear-property"><a href="#Float-amp-Clear-property" class="headerlink" title="Float &amp; Clear property"></a>Float &amp; Clear property</h2><ul><li>left</li><li>right</li><li>none (default)</li><li>inherit</li></ul><p>define how an element could float in its container</p><h3 id="clear"><a href="#clear" class="headerlink" title="clear:"></a>clear:</h3><ul><li>none</li><li>left: no floating allowed on the left side of the element</li><li>right: no floating allowed on the right side of the element</li><li>both: no floating allowed on the both side of the element</li><li>inherit</li></ul><h3 id="clear-fix"><a href="#clear-fix" class="headerlink" title="clear fix"></a>clear fix</h3><p>If an element is taller than the element containing it and it floats, it will overflow outside of its container<br>Add overflow property to the container to fix this problem.</p><ul><li>clear-fix::after<br>Another common used way to clear the float for the container, add empty string after the element to cancel the float.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.clearfix::after</span><br><span class="line">&#123;</span><br><span class="line">    content: &quot;&quot;&apos;;</span><br><span class="line">    clear: both;</span><br><span class="line">    display: table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="display-Inline-block-property"><a href="#display-Inline-block-property" class="headerlink" title="display: Inline-block property"></a>display: Inline-block property</h3><p>display: inline-block display the element as a block inline, meaning width and height properties will work. Where as the display: inline will not.<br>Difference between display: block and display: inline-block is that inline-block does not add a line-break after the element where as the block will.</p><ul><li>inline-block replace float:<br>The old way to create a grid of boxes layout is to use, float and clear property.<br>The new way. inline-block. clear is not needed for inline-block.  </li></ul><h2 id="CSS-Combinators"><a href="#CSS-Combinators" class="headerlink" title="CSS Combinators"></a>CSS Combinators</h2><p>4 combinators</p><ul><li>descendant (space)</li><li>child  (&gt;)    </li><li>adjacent sibling (+)</li><li>general sibling (~)</li></ul><p>descendant selector matches all elements that are descendants of an element</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// select all &lt;p&gt; elements inside &lt;div&gt;</span><br><span class="line"><span class="selector-tag">div</span>  <span class="selector-tag">p</span></span><br><span class="line">&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>child selector selects all elements that are the immediate children of an element</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// select all &lt;p&gt; that are immediate children of &lt;div&gt;</span><br><span class="line"><span class="selector-tag">div</span> &gt; <span class="selector-tag">p</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>adjacent sibling selector: select the element just after.<br>general sibling selector: select all elements that are siblings of an element.</p><h3 id="Pseudo-classes-amp-Pseudo-element"><a href="#Pseudo-classes-amp-Pseudo-element" class="headerlink" title="Pseudo-classes &amp; Pseudo-element"></a>Pseudo-classes &amp; Pseudo-element</h3><p>Pseudo-class is used to define a special state of an element</p><p>syntax:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">selector: pseudo-class</span><br><span class="line">&#123;</span><br><span class="line">    property:....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>examples:</p><ul><li>:active</li><li>:enabled</li><li>:hover</li></ul><p>pseudo-element if used to style specified parts of an element.<br>syntax:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">selector::pseudo-element</span><br><span class="line">&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>examples:</p><ul><li>::after</li><li>::before</li></ul><h2 id="opacity-property"><a href="#opacity-property" class="headerlink" title="opacity property"></a>opacity property</h2><p>opacity take a value from 0.0 - 1.0. The lower, the more transparent.</p><h2 id="Css-attribute-selector"><a href="#Css-attribute-selector" class="headerlink" title="Css attribute selector"></a>Css attribute selector</h2><p>Its is possible to style elements with specific attributes or attributes values.</p><p>The syntax is like using json object:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// styling anchor with target attribute</span><br><span class="line">a[target] // or a[target="value"] to select specific value</span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Css-shadow-effects"><a href="#Css-shadow-effects" class="headerlink" title="Css shadow effects"></a>Css shadow effects</h2><ul><li>text-shadow</li><li>box-shadow</li></ul><p>specify the horizontal diff and vertical diff and a blur and color<br>example:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">5px</span> red;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">2px</span> grey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="box-sizing-property"><a href="#box-sizing-property" class="headerlink" title="box-sizing property"></a>box-sizing property</h2><p>can add padding and border to the element’s total width and height</p><ul><li>border-box (add padding and border to total width and height)</li><li>content-box (default, width and height only affects content)</li></ul><h2 id="Flex-box-layout"><a href="#Flex-box-layout" class="headerlink" title="Flex box layout"></a>Flex box layout</h2><p>One dimension table views in either horizontal or vertical way. By using <code>flex-wrap</code>, can wrap it to two dimensional.<br>To use flexbox model, it needs a flex container and its items.</p><p>In flex container, setting the display property to flex to enable flex module.<br>In flex container, the following properties can be configured:</p><ul><li>flex-direction ([row| column])</li><li>flex-wrap       ([wrap| nowrap])</li><li>flex-flow         (shorthand for flex-dirction and flex-wrap)</li><li>justify-content (used to align flex item [center| flex-start| flex-end| stretch])</li><li>align-itmes       (align items vertically)</li><li>align-content     (align echo row of the flex items)</li></ul><p>example:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-container</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">    <span class="attribute">align-content</span>: sapce-between;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>For child elements:</p><ul><li>order            (specify the order of flex items)</li><li>flex-grow      (specify how much the item will grow relative to the rest of items)</li><li>flex-shrink     (specify how much the item will shrink)</li><li>flex-basis       (the length of the item)</li><li>flex                 (shorthand for flex-grow, flew-shrink, flex-basis)</li><li>align-self        (alignment of the item [auto | stretch | center | flex-start| flex-end])</li></ul><h2 id="Grid-layout-module"><a href="#Grid-layout-module" class="headerlink" title="Grid layout module"></a>Grid layout module</h2><p>grid layout consists of a parent element, the container and the child elements.<br>To use grid module, set the container display property to <code>grid</code> or <code>inline-grid</code></p><h3 id="Terminology"><a href="#Terminology" class="headerlink" title="Terminology:"></a>Terminology:</h3><ul><li>grid container:  containing a grid, with <code>display: grid</code></li><li>grid item : direct descendant of the grid container</li><li>grid line: horizontal and vertical line separating the grid into sections</li><li>grid cell: intersection between row and column, same as a table cell</li><li>grid track: row tracks or column tracks, strip of cells</li><li>grid area: arear between four grid lines, which covers more than one cell</li><li>grid gap: space between cells, gutters</li></ul><h3 id="How-to-use"><a href="#How-to-use" class="headerlink" title="How to use"></a>How to use</h3><ol><li>Define a grid</li><li>Place items within the grid</li></ol><h4 id="Defince-a-grid"><a href="#Defince-a-grid" class="headerlink" title="Defince a grid"></a>Defince a grid</h4><p>First configure the grid container by defining: </p><ol><li><code>display: grid</code></li><li>the template for the columns and rows</li></ol><p>In defining the columns and rows, we can use <code>fr</code> (fraction)  to denote how to divide the whole space.<br>After defining the grid, the gird will automatically place all items into the grid, from left to right, from top to bottom.</p><p>example:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.grid-container</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-columns: auto auto auto; // also can be 2fr 1fr 1fr</span><br><span class="line">    <span class="selector-tag">grid-template-rows</span>: 80<span class="selector-tag">px</span> 200<span class="selector-tag">px</span>; </span><br><span class="line">    <span class="selector-tag">grid-gap</span>: 10<span class="selector-tag">px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Grid-item"><a href="#Grid-item" class="headerlink" title="Grid item"></a>Grid item</h4><p>For each grid item, we can define how much space it will take.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grid-column: 2/4;</span><br><span class="line">grid-row: 2/3</span><br></pre></td></tr></table></figure><p>This specific this item to take column from line 2 to line 4, and row from line2 to line3</p><h4 id="Grid-template-areas"><a href="#Grid-template-areas" class="headerlink" title="Grid template areas"></a>Grid template areas</h4><p>A way to manage grid areas easily.<br><code>grid-template-areas</code> defines how each areas block should be placed in the grid.<br><code>grid-area</code> in items defines which item correspond to which area.</p><p>First, declare the template in the grid container:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.site</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    //defines a 3*2 grid</span><br><span class="line">    <span class="selector-tag">grid-template-rows</span>: <span class="selector-tag">auto</span> 1<span class="selector-tag">fr</span> 3<span class="selector-tag">fr</span>; </span><br><span class="line">    <span class="selector-tag">grid-template-columns</span>: 1<span class="selector-tag">fr</span> 1<span class="selector-tag">fr</span>;</span><br><span class="line">    //define the areas in the grid</span><br><span class="line">    <span class="selector-tag">grid-template-areas</span>:</span><br><span class="line">        “<span class="selector-tag">title</span> <span class="selector-tag">title</span>”</span><br><span class="line">        “<span class="selector-tag">main</span> <span class="selector-tag">header</span>”</span><br><span class="line">        “<span class="selector-tag">main</span> <span class="selector-tag">sidebar</span>”;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// give each item a corresponding name for area</span><br><span class="line"><span class="selector-class">.masthead</span> &#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: header;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.page-title</span> &#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: title;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main-content</span> &#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: main;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Test-support-grid"><a href="#Test-support-grid" class="headerlink" title="Test support grid"></a>Test support grid</h3><p>To test if the browser support the grid layout, in case of IE.<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">supports</span> (display: grid)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="CSS-grid-RWD-responsive-web-design-approach-for-today"><a href="#CSS-grid-RWD-responsive-web-design-approach-for-today" class="headerlink" title="CSS grid RWD(responsive web design) approach for today"></a>CSS grid RWD(responsive web design) approach for today</h3><ol><li>build accessible mobile-first layout without grid</li><li>use mobile-first layout as fallback for all browsers.</li><li>user @supports to detect gird support</li><li>At the appropriate point, create layout with grid and grid-areas.</li><li>export new layout as viewport widens</li></ol><h2 id="Css-Media-Queries"><a href="#Css-Media-Queries" class="headerlink" title="Css Media Queries"></a>Css Media Queries</h2><p>The <code>@media</code> rule made it possible to define different style for different media types.</p><p>syntax<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> [not| only] mediatype and (expressions)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NSURL Session Key Notes</title>
      <link href="/2017/05/09/NSURL-Session-Key-notes/"/>
      <url>/2017/05/09/NSURL-Session-Key-notes/</url>
      <content type="html"><![CDATA[<p><code>9 May 2017</code></p><p>Here I want to discuss about the cocoa networking api, mainly NSURLSession package, to have a clear point of view on networking. So that, even though we use mostly third part frameworks like alamoFire(at least in my case), we can have a decent knowledge of what is going on underneath the framwork. </p><h1 id="History"><a href="#History" class="headerlink" title="History"></a>History</h1><p>In the ancient time, when people dont even have smart phone(iphone in particular) or dont even have a phone, there is no much demand on the networking for any device or computer primarily. </p>]]></content>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Auto Layout iOS</title>
      <link href="/2017/05/02/Auto-Layout-iOS/"/>
      <url>/2017/05/02/Auto-Layout-iOS/</url>
      <content type="html"><![CDATA[<p><code>May 2 2017</code></p><p><img src="source/upload/image/constraintEquation.png" alt=""></p><p>Generally, there are two ways of layout views in iOS apps. The old way, frame based layout and the new way, auto Layout.<br>Before iOS 6 or so, we only have frame based layout system for iOS. In Frame based layout we have <em>programmatically set frame</em> and <em>autoresizing mask</em>.<br>At iOS 6 and more recently at iOS 9, we finally have auto layout, which is similar to relative layout, and anchors which is an easy way to define constraints in auto layout. In Auto Layout  we can define all the relative relations between views by a couple of constraint equations. we have three ways to implement these equations for any view, we can define the layout constrains by <em>ASCII String</em> or add the relationship by <em>NSLayoutConstraint</em> class or we can just set anchors from <em>NSLayoutAnchor</em> class for each view.</p><p>In this article, we focus on auto layout and especially on setting anchors to view to define constraints equation because its the most easy and recommended way at the moment.  </p><h1 id="Some-words-on-frame-based-layout"><a href="#Some-words-on-frame-based-layout" class="headerlink" title="Some words on frame based layout"></a>Some words on frame based layout</h1><p>Traditionally,especially before iOS 6, apps layout their subview by setting frame property directly. Because at early age, there are small arrange of screen size, so there is no much work on the layout view side. But this is a fairly original way to layout views.</p><h2 id="how-it-works"><a href="#how-it-works" class="headerlink" title="how it works"></a>how it works</h2><p>User can set frame property from the init time of view and also at runtime at any moment he likes.<br>In general, view are positioned by their frame property at the init time. However, we can also change the frame by override <code>layoutSubviews()</code> and by call <code>setNeedsLayout()</code> or <code>layoutIfNeeded()</code> to update layout changes. </p><p>However, in most cases,  a view’s frame should be the result of the Auto Layout process, not an input variable.</p><h1 id="Auto-Layout"><a href="#Auto-Layout" class="headerlink" title="Auto Layout"></a>Auto Layout</h1><p>After iOS 6, we have the auto layout system which is a similar version to Android relative layout. Here we can use a constraints equation to define a relation from the view it function on to another view it refers. So it needs at least 4 equations to define precisely the position and the scale of a view.<br>| <code>objectView.attribute1 =(&lt;,&gt;) multiplier * referedView.attribute2 + constant</code></p><h2 id="ASCII-String-auto-layout"><a href="#ASCII-String-auto-layout" class="headerlink" title="ASCII String auto layout"></a>ASCII String auto layout</h2><p>Use ASCII-art like string to define constraints. By using method:<br><code>NSLayoutConstraint.constraints(withVisualFormat: formatString, options: .alignAllTop, metrics: nil, views: views)</code></p><h2 id="NSLayoutConstraint-Class"><a href="#NSLayoutConstraint-Class" class="headerlink" title="NSLayoutConstraint Class"></a>NSLayoutConstraint Class</h2><p>Set a constraint by assigning all the params necessary.<br><code>NSLayoutConstraint(item: myView, attribute: .height, relatedBy: .equal, toItem: myView, attribute:.width, multiplier: 2.0, constant:0.0)</code></p><h2 id="Layout-Anchors"><a href="#Layout-Anchors" class="headerlink" title="Layout Anchors"></a>Layout Anchors</h2><p>Use NSLayoutAnchor class. It is a factory class for creating NSLayoutConstraint objects. We can set anchors directly on each view.<br><code>subview.leadingAnchor.constraint(equalTo: margins.leadingAnchor)</code></p><h2 id="UILayoutPriority"><a href="#UILayoutPriority" class="headerlink" title="UILayoutPriority"></a>UILayoutPriority</h2><p>Very instance of NSLayoutConstraint has a property of <code>UILayoutPriority</code> which is in fact a float value. <code>typealias UILayoutPriority = Float</code> from 0 to 1000. The bigger the higher in terms of priorty.</p><p>This property is used to determine the priority between different constraints.<br>When programmer set constraints for an object, if two constraints conflict with each other, the one with bigger priority preveils.<br>Programmer can also set multiple constraints that conflict with each other but with different priorities. And there will be no error, because of priority. In this way, if some views will be deleted in the future and the constraints with them will also be removed, and the rest of views will be working well because of contraints of lowere prioriy will be in effect.</p><h1 id="Auto-Resize"><a href="#Auto-Resize" class="headerlink" title="Auto Resize"></a>Auto Resize</h1><p>Auto resize is another auto resize layout technology that is exclusive to Auto Layout. They are enemies, not friends. However, auto resize is kinds of an easy and flexible solution to resolve layout problem.</p><p>The idea is to use an struct <code>UIViewAutoresizing</code> and the UIView hierarchy to solve the problem. Each view is flexible in terms of size and position to its parent view.</p><p>Just set each views <code>autoresizingMask</code> property to these values from <code>UIViewAutoresizing</code> struct.</p><h2 id="UIViewAutoResizing"><a href="#UIViewAutoResizing" class="headerlink" title="UIViewAutoResizing"></a>UIViewAutoResizing</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public struct UIViewAutoresizing : OptionSet &#123;</span><br><span class="line"></span><br><span class="line">    public init(rawValue: UInt)</span><br><span class="line"></span><br><span class="line">    public static var flexibleLeftMargin: UIViewAutoresizing &#123; get &#125;</span><br><span class="line"></span><br><span class="line">    public static var flexibleWidth: UIViewAutoresizing &#123; get &#125;</span><br><span class="line"></span><br><span class="line">    public static var flexibleRightMargin: UIViewAutoresizing &#123; get &#125;</span><br><span class="line"></span><br><span class="line">    public static var flexibleTopMargin: UIViewAutoresizing &#123; get &#125;</span><br><span class="line"></span><br><span class="line">    public static var flexibleHeight: UIViewAutoresizing &#123; get &#125;</span><br><span class="line"></span><br><span class="line">    public static var flexibleBottomMargin: UIViewAutoresizing &#123; get &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> autolayout, iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django</title>
      <link href="/2017/01/30/Django/"/>
      <url>/2017/01/30/Django/</url>
      <content type="html"><![CDATA[<p><code>Jan 30 2017</code></p><h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><a id="more"></a><h2 id="开始一个项目"><a href="#开始一个项目" class="headerlink" title="开始一个项目"></a>开始一个项目</h2><p>项目是Django实列的一系列设置集合，包括数据库，setting，和app的设置。<br>运行<code>django-admin.py startproject mysite</code> 会在当前目录下创建一个目录mysite。<br>这个目录包含4个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysite/</span><br><span class="line">    __init__.py</span><br><span class="line">    mange.py</span><br><span class="line">    settings.py</span><br><span class="line">    urls.py</span><br></pre></td></tr></table></figure><p>文件作用：</p><ul><li><strong>init</strong>.py: 让python把该目录当作一组模块的文件。一遍为空不需要改动。</li><li>manage.py: 命令行工具，方便与Django交互，<code>python mange.py help</code> 查看具体作用。</li><li>settings.py: 改Django项目的配置文件。</li><li>urls.py: Django的url设置。</li></ul><p>这些文件已经构成了一个可运行的Django应用。</p><h2 id="运行开发服务器"><a href="#运行开发服务器" class="headerlink" title="运行开发服务器"></a>运行开发服务器</h2><p><code>python manage.py runserver</code><br>默认下本地服务器地址与端口是<code>http://127.0.0.1:8000/</code>，也可以改变ip地址或端口运行。<br>改变端口：<br><code>python manage.py runserver 8080</code><br>改变ip：<br><code>python manage.py runserver 0.0.0.0:8000</code><br>完成这些设置之后，本地网络内其他终端就可以通过访问你的ip地址访问你的服务器了。</p><h1 id="视图与URL配置"><a href="#视图与URL配置" class="headerlink" title="视图与URL配置"></a>视图与URL配置</h1><h2 id="第一份视图"><a href="#第一份视图" class="headerlink" title="第一份视图"></a>第一份视图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(“Hello world”)</span><br></pre></td></tr></table></figure><p>一个视图就是python的一个函数。这个函数的第一个参数类型是HttpResponse；这个函数返回一个HttpResponse的实列。必须满足这两个条件的函数，才是一个Django可识别的视图。</p><h2 id="URLconf"><a href="#URLconf" class="headerlink" title="URLconf"></a>URLconf</h2><p>为了绑定视图函数和URL，我们使用URLconf。其本质是URL正则表达式pattern与此表达式需要调用的视图函数之间的映射表。以这种方式使Django明白哪一个url调用哪一个视图表达式。</p><h2 id="python-搜索路径"><a href="#python-搜索路径" class="headerlink" title="python 搜索路径"></a>python 搜索路径</h2><p>搜索路径就是<code>import</code> 语句执行时查找系统目录的名单。<br>可通过以下代码显示路径：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">print</span> sys.path</span><br></pre></td></tr></table></figure></p><p>通常不必关心搜索路径，python和Django会自动处理。</p><h2 id="Django是怎么处理请求的"><a href="#Django是怎么处理请求的" class="headerlink" title="Django是怎么处理请求的"></a>Django是怎么处理请求的</h2><p>当运行<code>python manage.py runserver</code>时，脚步将在于mange同一个目录下找setting.py文件。这个文件包涵了有关Django项目的配置信息，如<code>TEMPLATE_DIRS , DATABASE_NAME</code>等。最重要的是<code>ROOT_URLCONF</code> 它作为URLconf告诉Django哪些python模块将被用到。<br>自动创建的setting.py包含一个指向自动产生的urls.py的配置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ROOT_URLCONF = <span class="string">'mysite.urls'</span></span><br></pre></td></tr></table></figure><p>当服务器被访问时，Django根据ROOT_URLCONF的设置装载URLconf。然后按顺序逐个匹配URLconf里的URLpatterns，直到找到一个匹配的。然后调用这个匹配pattern的view函数，并把HttpRequest对象当作第一参数。这个view函数返回一个HttpResponse，Django将其转化成一个带有HTTP头和body的web Response。</p><p>总结:</p><ol><li>服务器收到访问hello/的请求。 </li><li>Django 过 ROOT_URLCONF配置来决定根URLconf. </li><li>Django在URLconf中的所有URL模式中查找第一个匹配hello/的条目。</li><li>如果找到，调用相应的视图函数。  </li><li>视图函数返回一个HttpResponse 。</li><li>Django转换HttpResponse为一个合适的HTTPresponse ，以Webpage显示出来。</li></ol><h1 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h1><h2 id="如何使用模版系统"><a href="#如何使用模版系统" class="headerlink" title="如何使用模版系统"></a>如何使用模版系统</h2><p>python中使用Django模版的最基本方法如下：</p><ol><li>创建一个template对象<code>template.Template()</code>;</li><li>调用模版对象的render方法，并且传入一套变量context。</li></ol><h2 id="创建模版对象"><a href="#创建模版对象" class="headerlink" title="创建模版对象"></a>创建模版对象</h2><p>Template类在django.template模块中，构造函数接受一个参数，原始模版代码字符串，也可以指定模版文件路径当作参数。<br>启动python交互解释：<br><code>python manage.py shell</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t = Template(<span class="string">'My name is &#123;&#123; name &#125;&#125;.'</span>)</span><br></pre></td></tr></table></figure></p><p>创建模版对象之后，可以用context来传递数据给他。一个context是一系列变量和它们值的集合。<br>context是一个django.template模块里的类。她的构造函数带一个可选参数，一个字典，映射便利和它们的值。调用Template对象的render()方法传递context来填充模版。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = Template(<span class="string">'My name is &#123;&#123; name &#125;&#125;.'</span>)</span><br><span class="line">c = Context(&#123;<span class="string">'name'</span>: <span class="string">'Stephane'</span>&#125;)</span><br><span class="line">t.render(c)</span><br></pre></td></tr></table></figure></p><p><code>t.render(c)</code>返回一个Unicode字符串对象。</p><h2 id="模版变量深度访问"><a href="#模版变量深度访问" class="headerlink" title="模版变量深度访问"></a>模版变量深度访问</h2><p>在Django模版中访问复杂的数据结构时用点运算符。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person = &#123;<span class="string">'name'</span>: <span class="string">'Sally'</span>, <span class="string">'age'</span>: <span class="string">'43'</span>&#125;</span><br><span class="line">t = Template(<span class="string">'&#123;&#123; person.name &#125;&#125; is &#123;&#123; person.age &#125;&#125; years old.'</span>)</span><br><span class="line">c = Context(&#123;<span class="string">'person'</span>: person&#125;)</span><br><span class="line"> t.render(c)</span><br></pre></td></tr></table></figure></p><p>点语法也可以用来调用对象方法。例如，每个python字符串都有upper()方法，可以在模版中使用它们。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t = Template(<span class="string">'&#123;&#123; var &#125;&#125; -- &#123;&#123; var.upper &#125;&#125; -- &#123;&#123; var.isdigit &#125;&#125;'</span>)</span><br></pre></td></tr></table></figure></p><p>注意这里调用方法时并没有使用圆括号，也无法给改方法传递参数。你只能调用不需参数的方法。</p><h2 id="基本模版标签"><a href="#基本模版标签" class="headerlink" title="基本模版标签"></a>基本模版标签</h2><p>if/else:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> today_is_weekend %&#125;</span><br><span class="line">       &lt;p&gt;Welcome to the weekend!&lt;/p&gt; </span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p>for:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">for</span> athlete <span class="keyword">in</span> athlete_list %&#125;</span><br><span class="line"> &lt;li&gt;&#123;&#123; athlete.name &#125;&#125;&lt;/li&gt; </span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">``` </span><br><span class="line">ifequal/ifnotequal:</span><br><span class="line">```python</span><br><span class="line">&#123;% ifequal user currentuser %&#125;</span><br><span class="line">       &lt;h1&gt;Welcome!&lt;/h1&gt;   </span><br><span class="line">&#123;% endifequal %&#125;</span><br></pre></td></tr></table></figure></p><h2 id="模版加载"><a href="#模版加载" class="headerlink" title="模版加载"></a>模版加载</h2><p>要使用模版加载api，首先必须将模版保存位置告诉Django。<br>打开settings.py找到TEMPLATE_DIRS。该设置告诉Django模版加载机制去哪里查找模版。添加模版存放目录。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TEMPLATE_DIRS = ( <span class="string">'/home/django/mysite/templates'</span>, )</span><br></pre></td></tr></table></figure></p><p>注意目录地址后面逗号不可缺少。</p><p>完成设置之后就可以使用模版加载功能了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.template.loader <span class="keyword">import</span> get_template </span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse </span><br><span class="line"><span class="keyword">import</span> datetime </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">current_date</span><span class="params">(request)</span>:</span></span><br><span class="line">    now = datetime.datetime.now() </span><br><span class="line">    t = get_template(<span class="string">'current_datetime.html'</span>) </span><br><span class="line">    html = t.render(Context(&#123;<span class="string">'current_date'</span>: now&#125;)) </span><br><span class="line">    <span class="keyword">return</span> HttpResponse(html)</span><br></pre></td></tr></table></figure></p><p>我们使用了<code>django.template.loader.get_template()</code>来加载模版而不是手动加载。该函数以模版名称为参数，在文件系统中找出模块的位置，打开并返回一个编译好的Template对象。</p><h2 id="render-to-response-render"><a href="#render-to-response-render" class="headerlink" title="render_to_response()/render()"></a>render_to_response()/render()</h2><p>这是django提供的一条捷径，一次性载入模版渲染并返回。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render_to_response   </span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">current_datetime</span><span class="params">(request)</span>:</span></span><br><span class="line">    now = datetime.datetime.now()</span><br><span class="line">    <span class="keyword">return</span> render_to_response(<span class="string">'current_datetime.html'</span>, &#123;<span class="string">'current_date'</span>: now&#125;)</span><br></pre></td></tr></table></figure></p><p><code>render_to_response()</code>的第一个参数必须是使用模版的名称，如果给第二个参数，则是context所使用的字典。</p><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><h2 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h2><p>Django遵循MVC模式，是一种MVC框架。以下是MVC在Django中的含义，</p><ul><li>M：数据存取部分，由django数据库层处理。</li><li>V：选择哪些数据展示和怎么展示数据，由视图和模版构成。</li><li>C：根据用户输入委派视图，由Django根据URLconf设置，对给的URL调用相应的函数。</li></ul><h2 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h2><p>要使用数据库首先我们要做初始配置。我们要告诉Django使用什么数据库以及如何连接数据库。<br>数据库的配置也是在settings.py里，打开这个文件找到：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DATABASE_ENGINE = ‘’ // 使用引擎</span><br><span class="line">DATABASE_NAME = ‘’   // 数据库名字</span><br><span class="line">DATABASE_USER = ‘’     </span><br><span class="line">DATABASE_PASSWORD = <span class="string">''</span> </span><br><span class="line">DATABASE_HOST = ‘’     //连接那一台主机的数据库服务器,如果是和Django同一台主机则留空</span><br><span class="line">DATABASE_PORT = ‘’    //端口号</span><br></pre></td></tr></table></figure></p><p>我们可以在项目目录下，用<code>python manage.py shell</code>来测试。此命令是以正确的配置启用python交互器的一种方法，使python知道加载那个配置文件获取数据库连接信息。<br>输入以下命令测试数据库是否有配置错误，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db <span class="keyword">import</span> connection</span><br><span class="line"> &gt;&gt;&gt; cursor = connection.cursor()</span><br></pre></td></tr></table></figure></p><h2 id="第一个APP"><a href="#第一个APP" class="headerlink" title="第一个APP"></a>第一个APP</h2><p>现在来创建一个包含模型，视图和Django代码的完整应用。<br>系统对app有一个约定，如果使用了Django的数据库层(模型)，你必须创建一个app。模型必须存放在apps中。<br>在项目目录下输入以下命令创建app：<br><code>python manage.py startapp books</code></p><p>这个命令创建了一个books目录生成了一些初始文件。</p><h2 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h2><p>Django模型是用python代码形式表述的数据在数据库中的定义。</p><p>我们看这一个模型的例子：书籍、作者、出版商<br>假定下面概念和关系：</p><ul><li>作者，有姓名、email</li><li>出版商，有名称、地址、所在城市、省份、国家、及网站</li><li>书籍，有书名、出版日期。它有一个或多个作者，有一个出版商。</li></ul><p>用代码描述上述信息，打开用startapp新建的文件夹，打开models.py文件，加入如下代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Publisher</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">    address = models.CharField(max_length=<span class="number">50</span>)     </span><br><span class="line">    city = models.CharField(max_length=<span class="number">60</span>)     </span><br><span class="line">    state_province = models.CharField(max_length=<span class="number">30</span>) </span><br><span class="line">    country = models.CharField(max_length=<span class="number">50</span>) </span><br><span class="line">    website = models.URLField() </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span><span class="params">(models.Model)</span>:</span> </span><br><span class="line">    first_name = models.CharField(max_length=<span class="number">30</span>) </span><br><span class="line">    last_name = models.CharField(max_length=<span class="number">40</span>) </span><br><span class="line">    email = models.EmailField() </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span><span class="params">(models.Model)</span>:</span> </span><br><span class="line">    title = models.CharField(max_length=<span class="number">100</span>)    </span><br><span class="line">    authors = models.ManyToManyField(Author) </span><br><span class="line">    publisher = models.ForeignKey(Publisher)        </span><br><span class="line">    publication_date = models.DateField()</span><br></pre></td></tr></table></figure></p><p>首先要注意的是每个数据模型都是<code>django.db.models.Model</code>的子类。它们的父类包含了所有必要的和数据库交互的方法，并提供了简洁漂亮的定义数据库字段的语法。<br>每个模型相当于单个数据库表，每个熟悉就是这个表中的一个字段。属性名就是字段名，她的类型相当于数据库的字段类型。</p><h2 id="模型安装"><a href="#模型安装" class="headerlink" title="模型安装"></a>模型安装</h2><p>完成代码之后，现在在数据库中创建这些表。第一步，在Django项目中激活这些模型，将book添加到配置文件的以安装应用列表中即可完成此步骤。<br>添加app到settings.py中的INSTALLED_APPS:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = ( </span><br><span class="line"> <span class="comment"># 'django.contrib.auth’, </span></span><br><span class="line"> <span class="comment"># 'django.contrib.contenttypes’, </span></span><br><span class="line"> <span class="comment"># 'django.contrib.sessions’, </span></span><br><span class="line"> <span class="comment"># 'django.contrib.sites’, </span></span><br><span class="line"> <span class="string">'mysite.books'</span>, </span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>现在可以创建数据库表了，首先用下面命令验证模型的有效性，<br><code>python manage.py validate</code></p><p>如果模型确认没有问题，通过以下命令可以生成相应的SQL代码<br><code>python manage.py sqlall books</code></p><p>sqlall命令根据模型生成相应SQL代码，可以把输出的语句复制到数据库客户端执行，或通过管道直接操作。Django也提供更简单的提交SQL语句到数据库的方法：<br><code>python manage.py syncdb</code></p><p>syndb是同步模型到数据库的一个简单方法。它根据INSTALLED_APPS里设置的app来检查数据库，如果表不存在久创建一个表。syndb不能修改或者删除数据库内容。</p><h2 id="插入和更新数据"><a href="#插入和更新数据" class="headerlink" title="插入和更新数据"></a>插入和更新数据</h2><p>使用定义的模型生成一个实例对象之后<code>p = Publisher(…)</code>，使用<code>save()</code>方法把这个对象储存到数据库中，如果数据已经储存过了，则实现对数据更新。</p><h2 id="选择对象"><a href="#选择对象" class="headerlink" title="选择对象"></a>选择对象</h2><p><code>Publisher.objects.all()</code>可以从给的到模型中取出所有记录。</p><p>可以通过filer()过滤出特定的表项数据,结果返回一个匹配到的数据列表：<br><code>Publisher.objects.filter(country=&quot;U.S.A.&quot;, state_province=&quot;CA”)</code></p><h2 id="数据排序"><a href="#数据排序" class="headerlink" title="数据排序"></a>数据排序</h2><p><code>Publisher.objects.order_by(&quot;name”)</code><br>使用<code>order_by()</code>方法实现根据字段值对返回结果排序。</p><h2 id="更新多个对象"><a href="#更新多个对象" class="headerlink" title="更新多个对象"></a>更新多个对象</h2><p>使用update()方法实现多个对象的更新：<br><code>Publisher.objects.all().update(country=&#39;USA&#39;)</code></p><h2 id="删除对象"><a href="#删除对象" class="headerlink" title="删除对象"></a>删除对象</h2><p>使用delete()方法删除表项：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Publisher.objects.filter(country=<span class="string">'USA'</span>).delete()</span><br><span class="line">Publisher.objects.all().delete()</span><br></pre></td></tr></table></figure></p><h1 id="站点管理admin"><a href="#站点管理admin" class="headerlink" title="站点管理admin"></a>站点管理admin</h1><h2 id="django-contrib-包"><a href="#django-contrib-包" class="headerlink" title="django.contrib 包"></a>django.contrib 包</h2><p>django.contrib 是一套庞大的功能集，他是django基本代码的组成部分，django框架就是由众多的包含附加组件的基本代码构成的。<br>管理工具是django.contrib.admin 。</p><h2 id="激活管理界面"><a href="#激活管理界面" class="headerlink" title="激活管理界面"></a>激活管理界面</h2><p>激活Django管理页面需要以下几个步骤：</p><ol><li><code>django.contrib.admin</code>被加入了setting的INSTALLED_APPS配置中。</li><li>保证INSTALLED_APPS中包含了<code>django.contrib.auth</code>,<code>django.contrib.contenttype</code>,<code>django.contrib.sessions</code>这三个需求包。</li><li>确保MIDDLEWARE_CLASSES中包含了<code>django.middleware.common.CommonMiddleware</code>,<code>django.contrib.sessions.middleware.SessionMiddleware</code>,<code>django.contrib.auth.middleware.AuthenticationMiddleware</code>。</li></ol><p>运行<code>python manage.py syncdb</code> 将生成管理界面使用的额外数据库表。<br>运行<code>python manage.py createsuperuser</code>来创建超级用户。</p><p>之后在URLconf中配置admin的url。</p><h2 id="将Models加入到Admin管理中"><a href="#将Models加入到Admin管理中" class="headerlink" title="将Models加入到Admin管理中"></a>将Models加入到Admin管理中</h2><p>如果把我们之前建立的models与admin界面连接，我们就可以使用admin的GUI管理我们的数据库了。<br>在目录下创建一个admin.py文件然后输入代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin   </span><br><span class="line"><span class="keyword">from</span> mysite.books.models <span class="keyword">import</span> Publisher, Author, Book</span><br><span class="line"></span><br><span class="line">admin.site.register(Publisher); </span><br><span class="line">admin.site.register(Author); </span><br><span class="line">admin.site.register(Book);</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Python Study</title>
      <link href="/2016/12/19/Python-Study/"/>
      <url>/2016/12/19/Python-Study/</url>
      <content type="html"><![CDATA[<p><code>19 Dec 2016</code></p><p>[TOC]</p><p>#BASIC SYNTAX<br><a id="more"></a></p><h2 id="Lines-and-Indentations"><a href="#Lines-and-Indentations" class="headerlink" title="Lines and Indentations"></a>Lines and Indentations</h2><p>Python provides no braces to indicate blocks of code for class and function definitions or flow control. Blocks of code are denoted by line indentation, which is rigidly enforced.<br>Thus, in Python all the continuous lines indented with same number of spaces would form a block.</p><h2 id="Quotation"><a href="#Quotation" class="headerlink" title="Quotation"></a>Quotation</h2><p>Python accepts single (‘), double (“) and triple (‘’’ or “””) quotes to denote string literals, as long as the same type of quote starts and ends the string.</p><h2 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h2><p>A hash sign (#) that is not inside a string literal begins a comment. </p><h2 id="Multiple-Statement-Groups-as-Suites"><a href="#Multiple-Statement-Groups-as-Suites" class="headerlink" title="Multiple Statement Groups as Suites"></a>Multiple Statement Groups as Suites</h2><p>A group of individual statements, which make a single code block are called suites in Python. Compound or complex statements, such as if, while, def, and class require a header line and a suite.<br>Header lines begin the statement (with the keyword) and terminate with a colon ( : ) and are followed by one or more lines which make up the suite. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> expression :    </span><br><span class="line">    suite </span><br><span class="line"><span class="keyword">elif</span> expression :    </span><br><span class="line">    suite </span><br><span class="line"><span class="keyword">else</span> : </span><br><span class="line">    suite</span><br></pre></td></tr></table></figure><h1 id="BASIC-OPERATORS"><a href="#BASIC-OPERATORS" class="headerlink" title="BASIC OPERATORS"></a>BASIC OPERATORS</h1><ul><li>** :Exponent Performs </li><li>and: Logical AND</li><li>or: Logical OR</li><li>not: Logical NOT</li><li>is/is not: Evaluates to true if the variables on either side of the operator point to the same object and false otherwise.</li><li>in/not in: Evaluates to true if it finds a variable in the specified sequence and false otherwise.</li></ul><h1 id="VARIABLE"><a href="#VARIABLE" class="headerlink" title="VARIABLE"></a>VARIABLE</h1><p>use ‘del’ key word to delete the reference to value of any variable.</p><h2 id="Standard-Type"><a href="#Standard-Type" class="headerlink" title="Standard Type"></a>Standard Type</h2><p>Python has five standard data types:  Numbers  String  List  Tuple  Dictionary.</p><h2 id="Numbers"><a href="#Numbers" class="headerlink" title="Numbers"></a>Numbers</h2><p>Python supports four different numerical types: <br> int (signed integers)<br> long (long integers, they can also be represented in octal and hexadecimal)<br> float (floating point real values)<br> complex (complex numbers)</p><h2 id="Python-Strings"><a href="#Python-Strings" class="headerlink" title="Python Strings"></a>Python Strings</h2><p>Strings in Python are identified as a contiguous set of characters represented in the quotation marks. Python allows for either pairs of single or double quotes. Subsets of strings can be taken using the slice operator ([ ] and [:] ) with indexes starting at 0 in the beginning of the string and working their way from -1 at the end.</p><h2 id="Python-Lists"><a href="#Python-Lists" class="headerlink" title="Python Lists"></a>Python Lists</h2><p>Lists are the most versatile of Python’s compound data types. A list contains items separated by commas and enclosed within square brackets ([]). To some extent, lists are similar to arrays in C. One difference between them is that all the items belonging to a list can be of different data type. </p><p>The values stored in a list can be accessed using the slice operator ([ ] and [:]) with indexes starting at 0 in the beginning of the list and working their way to end -1. The plus (+) sign is the list concatenation operator, and the asterisk (*) is the repetition operator. </p><h2 id="Python-Tuples"><a href="#Python-Tuples" class="headerlink" title="Python Tuples"></a>Python Tuples</h2><p>A tuple is another sequence data type that is similar to the list. A tuple consists of a number of values separated by commas. Unlike lists, however, tuples are enclosed within parentheses. </p><p>The main differences between lists and tuples are: Lists are enclosed in brackets ( [ ] ) and their elements and size can be changed, while tuples are enclosed in parentheses ( ( ) ) and cannot be updated. Tuples can be thought of as read- only lists.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tuple = ( <span class="string">'abcd'</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">'john'</span>, <span class="number">70.2</span> ) </span><br><span class="line">list = [ <span class="string">'abcd'</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">'john'</span>, <span class="number">70.2</span> ] </span><br><span class="line">tuple[<span class="number">2</span>] = <span class="number">1000</span> <span class="comment"># Invalid syntax with tuple </span></span><br><span class="line">list[<span class="number">2</span>] = <span class="number">1000</span> <span class="comment"># Valid syntax with list</span></span><br></pre></td></tr></table></figure></p><h2 id="Python-Dictionary"><a href="#Python-Dictionary" class="headerlink" title="Python Dictionary"></a>Python Dictionary</h2><p>Python’s dictionaries are kind of hash table type. They work like associative arrays or hashes found in Perl and consist of key-value pairs. A dictionary key can be almost any Python type, but are usually numbers or strings. Values, on the other hand, can be any arbitrary Python object. </p><p>Dictionaries are enclosed by curly braces ({ }) and values can be assigned and accessed using square braces ([ ])<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dict = &#123;&#125; </span><br><span class="line">dict[<span class="string">'one'</span>] = <span class="string">"This is one"</span> </span><br><span class="line">dict[<span class="number">2</span>] = <span class="string">"This is two"</span> </span><br><span class="line">tinydict = &#123;<span class="string">'name'</span>: <span class="string">'john'</span>,<span class="string">'code'</span>:<span class="number">6734</span>, <span class="string">'dept'</span>: <span class="string">'sales'</span>&#125; </span><br><span class="line"><span class="keyword">print</span> dict[<span class="string">'one'</span>] <span class="comment"># Prints value for 'one' key</span></span><br><span class="line"><span class="keyword">print</span> dict[<span class="number">2</span>]             <span class="comment"># Prints value for 2 key</span></span><br><span class="line"><span class="keyword">print</span> tinydict              <span class="comment"># Prints complete dictionary</span></span><br><span class="line"><span class="keyword">print</span> tinydict.keys()  <span class="comment"># Prints all the keys</span></span><br><span class="line"><span class="keyword">print</span> tinydict.values()    <span class="comment"># Prints all the values</span></span><br></pre></td></tr></table></figure></p><h2 id="Data-Type-Conversion"><a href="#Data-Type-Conversion" class="headerlink" title="Data Type Conversion"></a>Data Type Conversion</h2><p>int(x [,base]) Converts x to an integer. base specifies the base if x is a string.<br>long(x [,base] ) Converts x to a long integer. base specifies the base if x is a string.<br>float(x) Converts x to a floating-point number.<br>str(x) Converts object x to a string representation.<br>list(s) Converts s to a list.<br>set(s) Converts s to a set.<br>dict(d) Creates a dictionary. d must be a sequence of (key,value) tuples.<br>chr(x) Converts an integer to a character.<br>unichr(x) Converts an integer to a Unicode character.<br>ord(x) Converts a single character to its integer value.<br>hex(x) Converts an integer to a hexadecimal string.<br>oct(x) Converts an integer to an octal string.</p><h1 id="DECISION-MAKING"><a href="#DECISION-MAKING" class="headerlink" title="DECISION MAKING"></a>DECISION MAKING</h1><h2 id="If-Statement"><a href="#If-Statement" class="headerlink" title="If Statement"></a>If Statement</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> expression1:    </span><br><span class="line">    statement(s) </span><br><span class="line"><span class="keyword">elif</span> expression2:    </span><br><span class="line">    statement(s) </span><br><span class="line"><span class="keyword">elif</span> expression3:    </span><br><span class="line">    statement(s) </span><br><span class="line"><span class="keyword">else</span>:    </span><br><span class="line">    statement(s)</span><br></pre></td></tr></table></figure><h1 id="LOOPS"><a href="#LOOPS" class="headerlink" title="LOOPS"></a>LOOPS</h1><h2 id="While-Loop"><a href="#While-Loop" class="headerlink" title="While Loop"></a>While Loop</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> expression:</span><br><span class="line">    statement(s)</span><br><span class="line"><span class="comment">#—————————</span></span><br><span class="line">count = <span class="number">0</span> </span><br><span class="line"><span class="keyword">while</span> (count &lt; <span class="number">9</span>):</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'The count is:'</span>, count</span><br><span class="line">    count = count + <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="For-Loop"><a href="#For-Loop" class="headerlink" title="For Loop"></a>For Loop</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> iterating_var <span class="keyword">in</span> sequence:</span><br><span class="line">    statements(s)</span><br><span class="line"><span class="comment">#———————————</span></span><br><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">'Python'</span>: <span class="comment"># First Example</span></span><br><span class="line">     <span class="keyword">print</span> <span class="string">'Current Letter :'</span>, letter</span><br><span class="line"></span><br><span class="line">fruits = [<span class="string">'banana'</span>, <span class="string">'apple'</span>,  <span class="string">'mango'</span>] </span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> range(len(fruits)): </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Current fruit :'</span>, fruits[index]</span><br></pre></td></tr></table></figure><h2 id="Pass-Statement"><a href="#Pass-Statement" class="headerlink" title="Pass Statement"></a>Pass Statement</h2><p>It is used when a statement is required syntactically but you do not want any command or code to execute.<br>The pass statement is a null operation; nothing happens when it executes. The pass is also useful in places where your code will eventually go, but has not been written yet </p><h1 id="NUMBERS"><a href="#NUMBERS" class="headerlink" title="NUMBERS"></a>NUMBERS</h1><h2 id="Mathematical-Functions"><a href="#Mathematical-Functions" class="headerlink" title="Mathematical Functions"></a>Mathematical Functions</h2><p>abs(x) The absolute value of x: the (positive) distance between x and zero.<br>ceil(x) The ceiling of x: the smallest integer not less than x<br>cmp(x, y) -1 if x &lt; y, 0 if x == y, or 1 if x &gt; y<br>exp(x) The exponential of x: ex<br>fabs(x) The absolute value of x.<br>floor(x) The floor of x: the largest integer not greater than x<br>log(x) The natural logarithm of x, for x&gt; 0 log10(x) The base-10 logarithm of x for x&gt; 0.<br>max(x1, x2,…) The largest of its arguments: the value closest to positive infinity<br>min(x1, x2,…) The smallest of its arguments: the value closest to negative infinity<br>modf(x) The fractional and integer parts of x in a two-item tuple. Both parts have the same sign as x. The integer part is returned as a float.<br>pow(x, y) The value of x**y.<br>round(x [,n]) x rounded to n digits from the decimal point. Python rounds away from zero as a tie-breaker: round(0.5) is 1.0 and round(- 0.5) is -1.0.<br>sqrt(x) The square root of x for x &gt; 0</p><h2 id="Mathematical-Constants"><a href="#Mathematical-Constants" class="headerlink" title="Mathematical Constants"></a>Mathematical Constants</h2><p>pi The mathematical constant pi.<br>e The mathematical constant e.</p><h1 id="STRINGS"><a href="#STRINGS" class="headerlink" title="STRINGS"></a>STRINGS</h1><h2 id="String-Formatting-Operator"><a href="#String-Formatting-Operator" class="headerlink" title="String Formatting Operator"></a>String Formatting Operator</h2><p>One of Python’s coolest features is the string format operator %. This operator is unique to strings and makes up for the pack of having functions from C’s printf() family.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> <span class="string">"My name is %s and weight is %d kg!"</span> % (<span class="string">'Zara'</span>, <span class="number">21</span>)</span><br></pre></td></tr></table></figure></p><h2 id="Triple-Quotes"><a href="#Triple-Quotes" class="headerlink" title="Triple Quotes"></a>Triple Quotes</h2><p>Python’s triple quotes comes to the rescue by allowing strings to span multiple lines, including verbatim NEWLINEs, TABs, and any other special characters.</p><h2 id="Built-in-String-Methods"><a href="#Built-in-String-Methods" class="headerlink" title="Built-in String Methods"></a>Built-in String Methods</h2><ul><li>capitalize() Capitalizes first letter of string.</li><li>count(str, beg= 0,end=len(string)) Counts how many times str occurs in string or in a substring of string if starting index beg and ending index end are given.</li><li>find(str, beg=0 end=len(string)) Determine if str occurs in string or in a substring of string if starting index beg and ending index end are given returns index if found and -1 otherwise.</li><li>index(str, beg=0, end=len(string)) Same as find(), but raises an exception if str not found.</li><li>isdigit() Returns true if string contains only digits and false otherwise.</li><li>len(string) Returns the length of the string.</li><li>split(str=””, num=string.count(str)) Splits string according to delimiter str (space if not provided) and returns list of substrings; split into at most num substrings if given.</li></ul><h1 id="LISTS"><a href="#LISTS" class="headerlink" title="LISTS"></a>LISTS</h1><h2 id="Built-in-List-Functions-and-Methods"><a href="#Built-in-List-Functions-and-Methods" class="headerlink" title="Built-in List Functions and Methods"></a>Built-in List Functions and Methods</h2><ul><li>cmp(list1, list2) Compares elements of both lists.</li><li>len(list) Gives the total length of the list.</li><li>max(list) Returns item from the list with max value.</li><li>min(list) Returns item from the list with min value.</li><li><p>list(seq) Converts a tuple into list.</p></li><li><p>list.append(obj) Appends object obj to list</p></li><li>list.count(obj) Returns count of how many times obj occurs in list</li><li>list.extend(seq) Appends the contents of seq to list</li><li>list.index(obj) Returns the lowest index in list that obj appears</li><li>list.insert(index, obj) Inserts object obj into list at offset index </li><li>list.pop(obj=list[-1]) Removes and returns last object or obj from list </li><li>list.remove(obj) Removes object obj from list </li><li>list.reverse() Reverses objects of list in place </li><li>list.sort([func]) Sorts objects of list, use compare func if given</li></ul><h1 id="FUNCTIONS"><a href="#FUNCTIONS" class="headerlink" title="FUNCTIONS"></a>FUNCTIONS</h1><h2 id="Defining-a-Function"><a href="#Defining-a-Function" class="headerlink" title="Defining a Function"></a>Defining a Function</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionname</span><span class="params">( parameters )</span>:</span></span><br><span class="line">    <span class="string">"function_docstring"</span></span><br><span class="line">    function_suite</span><br><span class="line">    <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure><h2 id="Passing-by-Reference-Versus-Passing-by-Value"><a href="#Passing-by-Reference-Versus-Passing-by-Value" class="headerlink" title="Passing by Reference Versus Passing by Value"></a>Passing by Reference Versus Passing by Value</h2><p>All object parameters (arguments) in the Python language are passed by reference. It means if you change what a parameter refers to within a function, the change also reflects back in the calling function.</p><h2 id="Variable-Length-Arguments"><a href="#Variable-Length-Arguments" class="headerlink" title="Variable Length Arguments"></a>Variable Length Arguments</h2><p>You may need to process a function for more arguments than you specified while defining the function. These arguments are called variable-length arguments and are not named in the function definition, unlike required and default arguments.</p><p>An asterisk (*) is placed before the variable name that holds the values of all nonkeyword variable arguments. This tuple remains empty if no additional arguments are specified during the function call.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionname</span><span class="params">([formal_args,] *var_args_tuple )</span>:</span></span><br><span class="line">     <span class="string">"function_docstring"</span></span><br><span class="line">     function_suite</span><br><span class="line">     <span class="keyword">return</span> [expression]</span><br><span class="line"><span class="comment">#——————————————</span></span><br><span class="line"><span class="comment"># Function definition is here </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span><span class="params">( arg1, *vartuple )</span>:</span></span><br><span class="line">     <span class="string">"This prints a variable passed arguments"</span></span><br><span class="line">      <span class="keyword">print</span> <span class="string">"Output is: "</span> <span class="keyword">print</span> arg1</span><br><span class="line">      <span class="keyword">for</span> var <span class="keyword">in</span> vartuple:</span><br><span class="line">           <span class="keyword">print</span> var</span><br><span class="line">      <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><h2 id="The-Anonymous-Functions"><a href="#The-Anonymous-Functions" class="headerlink" title="The Anonymous Functions"></a>The Anonymous Functions</h2><p>These functions are called anonymous because they are not declared in the standard manner by using the def keyword. You can use the lambda keyword to create small anonymous functions.</p><p>Lambda forms can take any number of arguments but return just one value in the form of an expression. They cannot contain commands or multiple expressions.<br>The syntax of lambda functions contains only a single statement<br><code>lambda [arg1 [,arg2,.....argn]]:expression</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Function definition is here </span></span><br><span class="line">sum = <span class="keyword">lambda</span> arg1, arg2: arg1 + arg2; </span><br><span class="line"><span class="comment"># Now you can call sum as a function </span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Value of total : "</span>, sum( <span class="number">10</span>, <span class="number">20</span> )</span><br></pre></td></tr></table></figure><h1 id="MODULES"><a href="#MODULES" class="headerlink" title="MODULES"></a>MODULES</h1><p>A module allows you to logically organize your Python code. Grouping related code into a module makes the code easier to understand and use. A module is a Python object with arbitrarily named attributes that you can bind and reference.<br>Simply, a module is a file consisting of Python code. A module can define functions, classes and variables. A module can also include runnable code.</p><h2 id="The-import-Statement"><a href="#The-import-Statement" class="headerlink" title="The import Statement"></a>The import Statement</h2><p>You can use any Python source file as a module by executing an import statement in<br>some other Python source file.<br><code>import module1[, module2[,... moduleN]</code></p><h2 id="The-from…import-Statement"><a href="#The-from…import-Statement" class="headerlink" title="The from…import(*) Statement"></a>The from…import(*) Statement</h2><p>Python’s from statement lets you import specific attributes from a module into the<br>current namespace. </p><h2 id="The-PYTHONPATH-Variable"><a href="#The-PYTHONPATH-Variable" class="headerlink" title="The PYTHONPATH Variable"></a>The PYTHONPATH Variable</h2><p>The PYTHONPATH is an environment variable, consisting of a list of directories. The syntax of PYTHONPATH is the same as that of the shell variable PATH.</p><h2 id="Namespaces-and-Scoping"><a href="#Namespaces-and-Scoping" class="headerlink" title="Namespaces and Scoping"></a>Namespaces and Scoping</h2><p>Variables are names (identifiers) that map to objects. A namespace is a dictionary of variable names (keys) and their corresponding objects (values).</p><p>A Python statement can access variables in a local namespace and in the global namespace. If a local and a global variable have the same name, the local variable shadows the global variable.</p><p>Python makes educated guesses on whether variables are local or global. It assumes that any variable assigned a value in a function is local.<br>Therefore, in order to assign a value to a global variable within a function, you must first use the global statement.<br>The statement global VarName tells Python that VarName is a global variable. Python stops searching the local namespace for the variable.</p><h1 id="FILES-I-O"><a href="#FILES-I-O" class="headerlink" title="FILES I/O"></a>FILES I/O</h1><h2 id="Reading-Keyboard-Input"><a href="#Reading-Keyboard-Input" class="headerlink" title="Reading Keyboard Input"></a>Reading Keyboard Input</h2><ul><li><p>raw_input<br>The raw_input([prompt]) function reads one line from standard input and returns it as a string (removing the trailing newline).</p></li><li><p>input<br>The input([prompt]) function is equivalent to raw_input, except that it assumes the input is a valid Python expression and returns the evaluated result to you.</p></li></ul><h2 id="Opening-and-Closing-Files"><a href="#Opening-and-Closing-Files" class="headerlink" title="Opening and Closing Files"></a>Opening and Closing Files</h2><p>Python provides basic functions and methods necessary to manipulate files by default. You can do your most of the file manipulation using a file object.</p><ul><li><p>open:<br><code>file object = open(file_name [, access_mode][, buffering])</code></p></li><li><p>close:<br><code>fileObject.close();</code></p></li></ul><h2 id="Reading-and-Writing-Files"><a href="#Reading-and-Writing-Files" class="headerlink" title="Reading and Writing Files"></a>Reading and Writing Files</h2><ul><li><p>write:<br><code>fileObject.write(string);</code></p></li><li><p>read:<br><code>fileObject.read([count]);</code></p></li></ul><h1 id="EXCEPTIONS"><a href="#EXCEPTIONS" class="headerlink" title="EXCEPTIONS"></a>EXCEPTIONS</h1><h1 id="CLASSES-AND-OBJECTS"><a href="#CLASSES-AND-OBJECTS" class="headerlink" title="CLASSES AND OBJECTS"></a>CLASSES AND OBJECTS</h1><h2 id="Creating-Classes"><a href="#Creating-Classes" class="headerlink" title="Creating Classes"></a>Creating Classes</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>:</span></span><br><span class="line"><span class="string">'Optional class documentation string'</span> </span><br><span class="line">    class_suite</span><br><span class="line"></span><br><span class="line"><span class="comment">#-----------------</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line"><span class="string">'Common base class for all employees'</span></span><br><span class="line">    empCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, salary)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.salary = salary</span><br><span class="line">        Employee.empCount += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">displayCount</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Total Employee %d"</span> % Employee.empCount</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">displayEmployee</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Name : "</span>, self.name, <span class="string">", Salary: "</span>, self.salary</span><br></pre></td></tr></table></figure><ul><li>The variable empCount is a class variable whose value is shared among all instances of a this class. This can be accessed as Employee.empCount from inside the class or outside the class.</li><li>The first method <strong>init</strong>() is a special method, which is called class constructor or initialization method that Python calls when you create a new instance of this class.</li><li>You declare other class methods like normal functions with the exception that the first argument to each method is self. Python adds the self argument to the list for you; you do not need to include it when you call the methods.</li></ul><h2 id="Creating-Instance-Objects"><a href="#Creating-Instance-Objects" class="headerlink" title="Creating Instance Objects"></a>Creating Instance Objects</h2><p>To create instances of a class, you call the class using class name and pass in whatever arguments its <strong>init</strong> method accepts.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"This would create first object of Employee class"</span> </span><br><span class="line">emp1 = Employee(<span class="string">"Zara"</span>, <span class="number">2000</span>)</span><br><span class="line"><span class="string">"This would create second object of Employee class"</span> </span><br><span class="line">emp2 = Employee(<span class="string">"Manni"</span>, <span class="number">5000</span>)</span><br></pre></td></tr></table></figure></p><h2 id="Class-Inheritance"><a href="#Class-Inheritance" class="headerlink" title="Class Inheritance"></a>Class Inheritance</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClassName</span> <span class="params">(ParentClass1[, ParentClass2, ...])</span>:</span></span><br><span class="line">     <span class="string">'Optional class documentation string'</span></span><br><span class="line">     class_suite</span><br><span class="line"><span class="comment">#———————————————</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Parent)</span>:</span> <span class="comment"># define child class</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">         <span class="keyword">print</span> <span class="string">"Calling child constructor"</span></span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">childMethod</span><span class="params">(self)</span>:</span></span><br><span class="line">         <span class="keyword">print</span> <span class="string">'Calling child method'</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="comment">## Data Hiding</span></span><br><span class="line">An objects attributes may or may not be visible outside the class definition. You need to name attributes with a double underscore prefix, and those attributes then are not be directly visible to outsiders.</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JustCounter</span>:</span></span><br><span class="line">    __secretCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__secretCount += <span class="number">1</span></span><br><span class="line">        <span class="keyword">print</span> self.__secretCount</span><br></pre></td></tr></table></figure><h1 id="REGULAR-EXPRESSIONS"><a href="#REGULAR-EXPRESSIONS" class="headerlink" title="REGULAR EXPRESSIONS"></a>REGULAR EXPRESSIONS</h1><p>The module re provides full support for Perl-like regular expressions in Python. The re module raises the exception re.error if an error occurs while compiling or using a regular expression.</p><p>To avoid any confusion while dealing with regular expressions, we would use Raw Strings as r’expression’.</p><h2 id="The-match-Function"><a href="#The-match-Function" class="headerlink" title="The match Function"></a>The match Function</h2><p><code>re.match(pattern, string, flags=0)</code></p><ul><li>pattern This is the regular expression to be matched.</li><li>string This is the string, which would be searched to match the pattern at the beginning of string.</li><li>flags You can specify different flags using bitwise OR (|). These are modifiers, which are listed in the table below.</li></ul><p>There.matchfunction returns amatchobject on success,noneon failure. We usegroup(num) or groups() function of match object to get matched expression.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re </span><br><span class="line"></span><br><span class="line">line = <span class="string">"Cats are smarter than dogs"</span> </span><br><span class="line">matchObj = re.match( <span class="string">r'(.*) are (.*?) .*'</span>, line, re.M|re.I) </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> matchObj:</span><br><span class="line">     <span class="keyword">print</span> <span class="string">"matchObj.group() : "</span>, matchObj.group()</span><br><span class="line">     <span class="keyword">print</span> <span class="string">"matchObj.group(1) : "</span>, matchObj.group(<span class="number">1</span>)</span><br><span class="line">     <span class="keyword">print</span> <span class="string">"matchObj.group(2) : "</span>, matchObj.group(<span class="number">2</span>) </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">     <span class="keyword">print</span> <span class="string">"No match!!"</span></span><br></pre></td></tr></table></figure><h2 id="The-search-Function"><a href="#The-search-Function" class="headerlink" title="The search Function"></a>The search Function</h2><p>This function searches for first occurrence of RE pattern within string with optional flags.<br><code>re.search(pattern, string, flags=0)</code></p><p>The re.search function returns a match object on success, none on failure. We use group(num) or groups() function of match object to get matched expression.</p><h2 id="Search-and-Replace"><a href="#Search-and-Replace" class="headerlink" title="Search and Replace"></a>Search and Replace</h2><p>One of the most important re methods that use regular expressions is sub.<br><code>re.sub(pattern, repl, string, max=0)</code></p><p>This method replaces all occurrences of the RE pattern in string with repl, substituting all occurrences unless max provided. This method returns modified string.</p><h1 id="NETWORK-PROGRAMMING"><a href="#NETWORK-PROGRAMMING" class="headerlink" title="NETWORK PROGRAMMING"></a>NETWORK PROGRAMMING</h1><p>Python provides two levels of access to network services. At a low level, you can access the basic socket support in the underlying operating system, which allows you to implement clients and servers for both connection-oriented and connectionless protocols.</p><p>Python also has libraries that provide higher-level access to specific application-level network protocols, such as FTP, HTTP, and so on.</p><h2 id="The-socket-Module"><a href="#The-socket-Module" class="headerlink" title="The socket Module"></a>The socket Module</h2><p>To create a socket, you must use the socket.socket() function available<br>in socket module, which has the general syntax:<br><code>s = socket.socket (socket_family, socket_type, protocol=0)</code></p><ul><li>socket_family: This is either AF_UNIX or AF_INET, as explained earlier.</li><li>socket_type: This is either SOCK_STREAM or SOCK_DGRAM.</li><li>protocol: This is usually left out, defaulting to 0.</li></ul><h2 id="Server-Socket-Methods"><a href="#Server-Socket-Methods" class="headerlink" title="Server Socket Methods"></a>Server Socket Methods</h2><ul><li><p>s.bind()<br>This method binds address (hostname, port number pair) to socket.</p></li><li><p>s.listen()<br>This method sets up and start TCP listener.</p></li><li><p>s.accept()<br>This passively accept TCP client connection, waiting until connection arrives (blocking).</p></li><li>s.connect()<br>This method actively initiates TCP server connection.</li></ul><h2 id="General-Socket-Methods"><a href="#General-Socket-Methods" class="headerlink" title="General Socket Methods"></a>General Socket Methods</h2><ul><li><p>s.recv()<br>This method receives TCP message</p></li><li><p>s.send()<br>This method transmits TCP message</p></li><li><p>s.recvfrom()<br>This method receives UDP message</p></li><li><p>s.sendto()<br>This method transmits UDP message</p></li><li><p>s.close()<br>This method closes socket</p></li><li><p>socket.gethostname()<br>Returns the hostname.</p></li></ul><h1 id="Comprehensions"><a href="#Comprehensions" class="headerlink" title="Comprehensions"></a>Comprehensions</h1><h2 id="List-Comprehension"><a href="#List-Comprehension" class="headerlink" title="List Comprehension"></a>List Comprehension</h2><p>A list comprehension consists of the following parts:</p><ul><li>An Input Sequence.</li><li>A Variable representing members of the input sequence.</li><li>An Optional Predicate expression.</li><li>An Output Expression producing elements of the output list from members of the Input Sequence that satisfy the predicate.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a_list = [<span class="number">1</span>, ‘<span class="number">4</span>’, <span class="number">9</span>, ‘a’, <span class="number">0</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">squared_ints = [ e**<span class="number">2</span> <span class="keyword">for</span> e <span class="keyword">in</span> a_list <span class="keyword">if</span> type(e) == types.IntType ]</span><br></pre></td></tr></table></figure><h2 id="Set-Comprehension"><a href="#Set-Comprehension" class="headerlink" title="Set Comprehension"></a>Set Comprehension</h2><p>Set comprehensions allow sets to be constructed using the same principles as list comprehensions, the only difference is that resulting sequence is a set.</p><p>Given the list:<br>names = [ ‘Bob’, ‘JOHN’, ‘alice’, ‘bob’, ‘ALICE’, ‘J’, ‘Bob’ ]</p><p>We require the set:<br>{ ‘Bob’, ‘John’, ‘Alice’ }</p><p>The following set comprehension accomplishes this:<br><code>{ name[0].upper() + name[1:].lower() for name in names if len(name) &gt; 1 }</code></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Binary Tree</title>
      <link href="/2016/12/19/Binary-Tree/"/>
      <url>/2016/12/19/Binary-Tree/</url>
      <content type="html"><![CDATA[<p><code>19 Dec 2016</code></p><h1 id="An-implementation-of-Tree-in-C"><a href="#An-implementation-of-Tree-in-C" class="headerlink" title="An implementation of Tree in C++"></a>An implementation of Tree in C++</h1><p>This is an simple implementation of Binary Tree template.</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">BinaryTreeNode</span>  </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T  element;                                         <span class="comment">//二叉树结点数据域</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt;*  left;                           <span class="comment">//二叉树结点指向左子树的指针</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt;*  right;                          <span class="comment">//二叉树结点指向左子树的指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BinaryTreeNode();</span><br><span class="line">    BinaryTreeNode(<span class="keyword">const</span> T&amp; ele);                       <span class="comment">//给定数据的构造函数</span></span><br><span class="line">    <span class="function">T  <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span></span>;                                   <span class="comment">//返回当前结点的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">setLeftchild</span><span class="params">(BinaryTreeNode&lt;T&gt;*)</span></span>;             <span class="comment">//设置当前结点的左子树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">setRightchild</span><span class="params">(BinaryTreeNode&lt;T&gt;*)</span></span>;            <span class="comment">//设置当前结点的右子树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">setValue</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span></span>;                        <span class="comment">//设置数据域</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt;*  leftchild() <span class="keyword">const</span>;              <span class="comment">//返回当前结点指向左子树的指针</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt;*  rightchild() <span class="keyword">const</span>;             <span class="comment">//返回当前结点指向右子树的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">BinaryTree</span>  </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    BinaryTreeNode&lt;T&gt;*  root;                           <span class="comment">//二叉树根结点指针</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt; elements;  <span class="comment">//用于保存遍历的元素</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Visit</span><span class="params">(T elem)</span> </span>&#123;elements.push_back(elem);&#125;;     <span class="comment">//遍历访问元素的值，返回数组线性表示遍历结果</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* root)</span></span>;             <span class="comment">//从root前序遍历二叉树或其子树(递归部分)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BinaryTreeNode&lt;T&gt; *root)</span></span>;              <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BinaryTreeNode&lt;T&gt; *root)</span></span>;            <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BinaryTreeNode&lt;T&gt; *root)</span></span>;           <span class="comment">//序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeleteBinaryTree</span><span class="params">(BinaryTreeNode&lt;T&gt;* root)</span></span>;     <span class="comment">//递归删除二叉树或其子树 </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BinaryTree()&#123;root=<span class="literal">NULL</span>;&#125;;                           <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~BinaryTree()&#123;DeleteBinaryTree(root);&#125;;                 <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Initialize</span><span class="params">(BinaryTreeNode&lt;T&gt;* pointer)</span> </span>&#123;root=pointer;&#125;;    <span class="comment">//构造树</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt; traversePreOrder();  <span class="comment">//从根节点前序遍历，以下依次对应</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************BinaryTreeNode类模板的实现************************/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">BinaryTreeNode</span>&lt;T&gt;:</span>:BinaryTreeNode()</span><br><span class="line">&#123;</span><br><span class="line">    left=right=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">BinaryTreeNode</span>&lt;T&gt;:</span>:BinaryTreeNode(<span class="keyword">const</span> T&amp; ele) <span class="comment">//给定数据的构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    element=ele;</span><br><span class="line">    left=right=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>  <span class="title">BinaryTreeNode</span>&lt;T&gt;:</span>:value() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> element; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">BinaryTreeNode</span>&lt;T&gt;*  <span class="title">BinaryTreeNode</span>&lt;T&gt;:</span>:leftchild() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> left;                                <span class="comment">//返回当前结点指向左子树的指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">BinaryTreeNode</span>&lt;T&gt;*  <span class="title">BinaryTreeNode</span>&lt;T&gt;:</span>:rightchild() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> right;                               <span class="comment">//返回当前结点指向右子树的指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span>  <span class="title">BinaryTreeNode</span>&lt;T&gt;:</span>:setValue(<span class="keyword">const</span> T&amp; val)     <span class="comment">//赋值</span></span><br><span class="line">&#123;</span><br><span class="line">    element = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span>  <span class="title">BinaryTreeNode</span>&lt;T&gt;:</span>:setLeftchild(BinaryTreeNode&lt;T&gt;* subroot)<span class="comment">//设置当前结点的左子树</span></span><br><span class="line">&#123;</span><br><span class="line">    left=subroot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span>  <span class="title">BinaryTreeNode</span>&lt;T&gt;:</span>:setRightchild(BinaryTreeNode&lt;T&gt;* subroot)<span class="comment">//设置当前结点的右子树</span></span><br><span class="line">&#123;</span><br><span class="line">    right=subroot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************BinaryTree类模板的实现************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">BinaryTree</span>&lt;T&gt;:</span>:DeleteBinaryTree(BinaryTreeNode&lt;T&gt;* root)       <span class="comment">//递归删除二叉树或其子树</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">    &#123;</span><br><span class="line">        DeleteBinaryTree(root-&gt;leftchild());</span><br><span class="line">        DeleteBinaryTree(root-&gt;rightchild());</span><br><span class="line">        <span class="keyword">delete</span> root;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">BinaryTree</span>&lt;T&gt;:</span>:PreOrder(BinaryTreeNode&lt;T&gt;* root)               <span class="comment">//前序遍历二叉树或其子树</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Visit(root-&gt;value());   </span><br><span class="line">        PreOrder(root-&gt;leftchild());            <span class="comment">//访问左子树</span></span><br><span class="line">        PreOrder(root-&gt;rightchild());           <span class="comment">//访问右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">BinaryTree</span>&lt;T&gt;:</span>:InOrder(BinaryTreeNode&lt;T&gt;* root)               <span class="comment">//前序遍历二叉树或其子树</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PreOrder(root-&gt;leftchild());            <span class="comment">//访问左子树</span></span><br><span class="line">        Visit(root-&gt;value());   </span><br><span class="line">        PreOrder(root-&gt;rightchild());           <span class="comment">//访问右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">BinaryTree</span>&lt;T&gt;:</span>:PostOrder(BinaryTreeNode&lt;T&gt;* root)               <span class="comment">//前序遍历二叉树或其子树</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PreOrder(root-&gt;leftchild());            <span class="comment">//访问左子树</span></span><br><span class="line">        PreOrder(root-&gt;rightchild());           <span class="comment">//访问右子树</span></span><br><span class="line">        Visit(root-&gt;value());   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">vector</span>&lt;T&gt; <span class="title">BinaryTree</span>&lt;T&gt;:</span>:traversePreOrder() </span><br><span class="line">&#123;</span><br><span class="line">    elements.clear();</span><br><span class="line">    PreOrder(root);</span><br><span class="line">    <span class="keyword">return</span> elements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rebuild-binary-tree"><a href="#rebuild-binary-tree" class="headerlink" title="rebuild binary tree"></a>rebuild binary tree</h1><p>Given Inorder traverse array and PostOrder traverse array, rebuild the Binary Tree.</p><p>The idea is that:<br>    In order to build the Binary tree from pre/post Order and InOrder array,we can do the recursive approch.</p><ol><li>The last/first element of post/pre Order array is the root element of the tree.Build the root Node. Find the root element in the InOrder array.</li><li>Count the number of elements of the left subarray and the right subarray of InOrder array, which is the number of elements in the corresponding left child subtree and right child subtree.</li><li>Divide the post/pre Order array into 3 part, the root, the right subarray contains a continuous elements of the number of right subarray of InOrder array, and the left vice versa.</li><li>Do the recurisve operation on the two subarrays.</li></ol><ul><li>code:<br>  postOrder and InOrder to build tree<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据后序和中序创建二叉树</span></span><br><span class="line"><span class="comment">//中序的首尾元素坐标，后序的首尾元素坐标</span></span><br><span class="line">BinaryTreeNode&lt;<span class="keyword">int</span>&gt;* createTree(<span class="keyword">int</span> io1, <span class="keyword">int</span> io2, <span class="keyword">int</span> po1, <span class="keyword">int</span> po2) &#123;</span><br><span class="line">    BinaryTreeNode&lt;<span class="keyword">int</span>&gt; *p;  <span class="comment">//新建一个结点(此处使用局部变量有风险)</span></span><br><span class="line">    p=<span class="keyword">new</span> BinaryTreeNode&lt;<span class="keyword">int</span>&gt;(vPost[po2]);  <span class="comment">//后序的最后一个元素是根结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//在中序里寻找根结点</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=io1; i&lt;=io2; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;value() == vIn[i])&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左子树是中序从io1到io1+i-1， 后序从po1到po1+i-1</span></span><br><span class="line">    <span class="comment">//注意递归出口，只有当io1&lt;=io1+i-1即i&gt;=1时才有意义</span></span><br><span class="line">    <span class="keyword">if</span> (io1&lt;=i<span class="number">-1</span>)&#123;</span><br><span class="line">        p-&gt;setLeftchild(createTree(io1, i<span class="number">-1</span>, po1, po1+(i<span class="number">-1</span>-io1)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//右子树类似</span></span><br><span class="line">    <span class="keyword">if</span> (i+<span class="number">1</span>&lt;=io2)&#123;</span><br><span class="line">        p-&gt;setRightchild(createTree(i+<span class="number">1</span>, io2, po2<span class="number">-1</span>-(io2-i<span class="number">-1</span>), po2<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="MinHeap-Implementation"><a href="#MinHeap-Implementation" class="headerlink" title="MinHeap Implementation"></a>MinHeap Implementation</h1><p>property:</p><ul><li>AVL tree, can be stored in array</li><li>parent k = i, left child k = 2i+1 ,right child k = 2i+2</li><li>value of parent node is bigger than children nodes, no direct relation between cousin nodes</li></ul><p>To Change to MaxHeap:<br>change method</p><ul><li>Insert,ShiftDown,ShiftUp,RemoveMax</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">MinHeap</span>  </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* heapArray;       <span class="comment">//存放堆数据的数组</span></span><br><span class="line">    <span class="keyword">int</span> CurrentSize;    <span class="comment">//当前堆中的元素数目</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize;        <span class="comment">//最大元素数目</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MinHeap(<span class="keyword">const</span> <span class="keyword">int</span> n);   <span class="comment">//构造函数，参数n为堆的最大元素数目</span></span><br><span class="line">    <span class="keyword">virtual</span> ~MinHeap() &#123;<span class="keyword">delete</span> []heapArray;&#125;;  <span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span>;           <span class="comment">//返回父结点位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">RemoveMin</span><span class="params">(T&amp; node)</span></span>;          <span class="comment">//从堆顶删除最小值</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> T&amp; newNode)</span></span>;   <span class="comment">//向堆中插入新元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SiftDown</span><span class="params">(<span class="keyword">int</span> left)</span></span>;         <span class="comment">//从left开始向下筛选  </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SiftUp</span><span class="params">(<span class="keyword">int</span> position)</span></span>;       <span class="comment">//从position向上开始调整，使序列成为堆       </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************MinHeap类模板的实现************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">MinHeap</span>&lt;T&gt;:</span>:MinHeap(<span class="keyword">const</span> <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    CurrentSize=<span class="number">0</span>;</span><br><span class="line">    MaxSize=n;</span><br><span class="line">    heapArray=<span class="keyword">new</span> T[MaxSize];   <span class="comment">//创建堆空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">MinHeap</span>&lt;T&gt;:</span>:parent(<span class="keyword">int</span> pos) <span class="keyword">const</span>   <span class="comment">// 返回父节点位置 pos1/2 == (pos1 - 1)/2 ;pos2 - 1 == pos1</span></span><br><span class="line">&#123;   <span class="comment">// return parent of both pos1 and pos2</span></span><br><span class="line">    <span class="keyword">return</span> (pos<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">MinHeap</span>&lt;T&gt;:</span>:SiftDown(<span class="keyword">int</span> left)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i=left;                         <span class="comment">//标识父结点</span></span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">2</span>*i+<span class="number">1</span>;                        <span class="comment">//标识关键值较小的子结点       </span></span><br><span class="line">    T   temp=heapArray[i];              <span class="comment">//保存父结点</span></span><br><span class="line">    <span class="comment">//过筛</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;CurrentSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((j&lt;CurrentSize<span class="number">-1</span>)&amp;&amp;(heapArray[j]&gt;heapArray[j+<span class="number">1</span>]))</span><br><span class="line">            j++;                        <span class="comment">//j指向右子结点</span></span><br><span class="line">        <span class="keyword">if</span>(temp&gt;heapArray[j])</span><br><span class="line">        &#123;</span><br><span class="line">            heapArray[i]=heapArray[j];</span><br><span class="line">            i=j;</span><br><span class="line">            j=<span class="number">2</span>*j+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    heapArray[i]=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">MinHeap</span>&lt;T&gt;:</span>:SiftUp(<span class="keyword">int</span> position) </span><br><span class="line">&#123;<span class="comment">//从position向上开始调整，使序列成为堆</span></span><br><span class="line">    <span class="keyword">int</span> temppos=position;</span><br><span class="line">    T temp=heapArray[temppos];</span><br><span class="line">    <span class="keyword">while</span>((temppos&gt;<span class="number">0</span>)&amp;&amp;(heapArray[parent(temppos)]&gt;temp))</span><br><span class="line">    &#123;</span><br><span class="line">        heapArray[temppos]=heapArray[parent(temppos)];</span><br><span class="line">        temppos=parent(temppos);</span><br><span class="line">    &#125;</span><br><span class="line">    heapArray[temppos]=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">MinHeap</span>&lt;T&gt;:</span>:RemoveMin(T&amp; node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(CurrentSize==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        node = heapArray[<span class="number">0</span>];</span><br><span class="line">        heapArray[<span class="number">0</span>]=heapArray[--CurrentSize];  <span class="comment">//用最后的元素代替被删除的元素</span></span><br><span class="line">        <span class="keyword">if</span> (CurrentSize&gt;<span class="number">1</span>) &#123;</span><br><span class="line">            SiftDown(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">MinHeap</span>&lt;T&gt;:</span>:Insert(<span class="keyword">const</span> T&amp; newNode)</span><br><span class="line">&#123;<span class="comment">//向堆中插入一个结点</span></span><br><span class="line">    <span class="keyword">if</span>(CurrentSize&gt;=MaxSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    heapArray[CurrentSize]=newNode; </span><br><span class="line">    SiftUp(CurrentSize);    </span><br><span class="line">    CurrentSize++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="BinarySearchTree-Sort-Implementation"><a href="#BinarySearchTree-Sort-Implementation" class="headerlink" title="BinarySearchTree Sort Implementation"></a>BinarySearchTree Sort Implementation</h1><p>BST Sort, InOrder traverse the BST created and the result is a sorted array.<br>BST inherited from BinaryTree. Key method is InsertNode which create the tree.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">BinarySearchTree</span>:</span><span class="keyword">public</span> BinaryTree&lt;T&gt; </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BinarySearchTree()&#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~BinarySearchTree()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InsertNode</span><span class="params">(BinaryTreeNode&lt;T&gt;* newpointer)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(BinaryTreeNode&lt;T&gt;* pointer)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:InsertNode(BinaryTreeNode&lt;T&gt;* newpointer)</span><br><span class="line">&#123;</span><br><span class="line">    BinaryTreeNode&lt;T&gt;* pointer=<span class="literal">NULL</span>; <span class="comment">//初始化 </span></span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//用指针newpointer初始化二叉搜索树树根，赋值实现</span></span><br><span class="line">        Initialize(newpointer);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> pointer=root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(newpointer-&gt;value()==pointer-&gt;value())</span><br><span class="line">            <span class="keyword">return</span> ;                                    <span class="comment">//相等则不用插入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(newpointer-&gt;value()&lt;pointer-&gt;value())   <span class="comment">//作为左子树</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pointer-&gt;leftchild()==<span class="literal">NULL</span>)  &#123;</span><br><span class="line">                pointer-&gt;left=newpointer;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    pointer=pointer-&gt;leftchild();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;                                           <span class="comment">//作为右子树</span></span><br><span class="line">            <span class="keyword">if</span>(pointer-&gt;rightchild()==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                pointer-&gt;right=newpointer;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    pointer=pointer-&gt;rightchild();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:DeleteNode(BinaryTreeNode&lt;T&gt;* pointer)</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">if</span>( pointer == <span class="literal">NULL</span> )   <span class="comment">//如果带删除节点为空,返回</span></span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    BinaryTreeNode&lt;T&gt; * parent = GetParent(root ,pointer ); <span class="comment">//保存要删除节点的父节点 </span></span><br><span class="line">    <span class="keyword">if</span>( pointer-&gt;leftchild() == <span class="literal">NULL</span> )  <span class="comment">//如果待删除节点的左子树为空,就将它的右子树代替它即可</span></span><br><span class="line">    &#123;       </span><br><span class="line">        <span class="keyword">if</span>( parent == <span class="literal">NULL</span> )                      <span class="comment">//将右子树连到待删除节点的父的合适位置</span></span><br><span class="line">            root = pointer-&gt;rightchild();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( parent-&gt;leftchild() == pointer )</span><br><span class="line">            parent-&gt;left = pointer-&gt;rightchild();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            parent-&gt;right = pointer-&gt;rightchild();</span><br><span class="line">        <span class="keyword">delete</span> pointer;</span><br><span class="line">        pointer=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当待删除节点左子树不为空,就在左子树中寻找最大节点替换待删除节点</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt; * temppointer;  <span class="comment">//保存要替换上来的节点 </span></span><br><span class="line">    BinaryTreeNode&lt;T&gt; * tempparent = <span class="literal">NULL</span>;  <span class="comment">//保存要替换上来的节点的父节点 </span></span><br><span class="line">    temppointer = pointer-&gt;leftchild();     </span><br><span class="line">    <span class="keyword">while</span>(temppointer-&gt;rightchild() != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        tempparent = temppointer;</span><br><span class="line">        temppointer = temppointer-&gt;rightchild();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除替换结点</span></span><br><span class="line">    <span class="keyword">if</span>(tempparent==<span class="literal">NULL</span>)</span><br><span class="line">        pointer-&gt;left=temppointer-&gt;leftchild();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tempparent-&gt;right=temppointer-&gt;leftchild();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用替换结点去替代真正的删除结点</span></span><br><span class="line">    <span class="keyword">if</span>(parent==<span class="literal">NULL</span>)</span><br><span class="line">        root=temppointer;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( parent-&gt;leftchild() == pointer )</span><br><span class="line">        parent-&gt;left=temppointer;</span><br><span class="line">    <span class="keyword">else</span> parent-&gt;right=temppointer;</span><br><span class="line"></span><br><span class="line">    temppointer-&gt;left=pointer-&gt;leftchild();</span><br><span class="line">    temppointer-&gt;right=pointer-&gt;rightchild();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pointer;</span><br><span class="line">    pointer=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Dynamic Programming</title>
      <link href="/2016/12/17/Dynamic-Programming/"/>
      <url>/2016/12/17/Dynamic-Programming/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>UBiOnlineTest</title>
      <link href="/2016/11/16/UBiOnlineTest/"/>
      <url>/2016/11/16/UBiOnlineTest/</url>
      <content type="html"><![CDATA[<p><code>16 Nov 2016</code></p><p>在巴黎一年多了，去年由于学校安排不用实习，今年就不行了。所以，年底之前就在忙活实习的事情。之前偶尔发现育碧巴黎总部要招实习生，当然我自己也是非常想在育碧这样的公司工作的，因为她的名气？超酷的工作环境？高水平的同事？可能都有些，于是就精心准备了下简历、动机信，投了游戏编程(game play programmer)。这个职位听起来也蛮不错的，但是c++开发。由于我c++在本科一年级学的，现在基本就和没学一样，所以就开始重新复习准备了一阵。</p><p>一段时间之后，投的简历给我回复说要安排网测，今天早上测试。早上，美女HR在指定时间给我发来了题目，三道120分钟。一看题，整体感觉，给的题目不算是特别难，应该是基本。但由于我还是对c++不是很熟练，做的很差。</p><p>但首先她推荐但我没有用VS编译器，我用clang编译，所以搞清楚她给的文件的格式用了不少时间。其次，我承认对文件输入输出虽然知道，但基本没有自己写过，用起来很蹩脚。还有STL中好多函数还是不清楚，以及她给的题目中用了闭包，这个我完全没想到。所以，虽然对题目都有想法，现实是没有完全实现一道。</p><p>现在把题目拿来，给出做法及知识点总结。个人还是蛮喜欢育碧这个游戏公司，相信我准备好的话下次再投应该不会有问题。<br><a id="more"></a></p><h1 id="data-reader"><a href="#data-reader" class="headerlink" title="data-reader"></a>data-reader</h1><p><strong>题目：</strong><br>请你设计一个文件数据读取写入软件。输入数据有不同的版本，和不同的数据结构。输出的数据有统一的版本和结构。</p><p>从输入文件中导入数据。每一组数据由只包含#符开头的一行标记开始，之后的行包含这样的字段“键：值”<br>多行的键值对无序出现，如果一个旧的版本中有值不存在，则值为0，新版本则改为None。</p><p>版本0.2: 在Version: 0.2之后<br>X: entier<br>Y: entier<br>Label: chaîne de caractères<br>Rank: chaîne de caractères</p><p>版本0.1: 在Version: 0.1之后<br>X: entier<br>Y: entier<br>Label: chaîne de caractères<br>Color: chaîne de caractères</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p>这里先给出一个不完善的做法：这个作法无法把值为0的改为None<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inItem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> lin0;</span><br><span class="line">    <span class="built_in">string</span> linV;</span><br><span class="line">    <span class="built_in">string</span> linX;</span><br><span class="line">    <span class="built_in">string</span> linY;</span><br><span class="line">    <span class="built_in">string</span> linL;</span><br><span class="line">    <span class="built_in">string</span> linR;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">input</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.find(<span class="string">"#"</span>) != <span class="number">-1</span> ) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 或 includes(str.begin(),str.end(),"#") ！= str.end() 来判断是一样的</span></span><br><span class="line">        <span class="keyword">if</span>(str.find(<span class="string">"X:"</span>) != <span class="number">-1</span>) linX = str;</span><br><span class="line">        <span class="keyword">if</span>(str.find(<span class="string">"Y:"</span>) != <span class="number">-1</span>) linY = str;</span><br><span class="line">        <span class="keyword">if</span>(str.find(<span class="string">"Label:"</span>) != <span class="number">-1</span>) linL = str;</span><br><span class="line">        <span class="keyword">if</span>(str.find(<span class="string">"Rank:"</span>) != <span class="number">-1</span>) linR = str; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lin0 = <span class="string">"#"</span>;</span><br><span class="line">        linV = <span class="string">"Version: 0.2"</span>;</span><br><span class="line">        linX = <span class="string">"X: None"</span>;</span><br><span class="line">        linY = <span class="string">"Y: None"</span>;</span><br><span class="line">        linL = <span class="string">"Label: None"</span>;</span><br><span class="line">        linR = <span class="string">"Rank: None"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeItem</span><span class="params">(ofstream &amp; o,inItem i)</span></span>&#123;</span><br><span class="line">        o&lt;&lt;i.lin0&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        o&lt;&lt;i.linV&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        o&lt;&lt;i.linX&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        o&lt;&lt;i.linY&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        o&lt;&lt;i.linL&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        o&lt;&lt;i.linR&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; input_content)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; output_content;</span><br><span class="line">    <span class="function">ofstream <span class="title">outFile</span><span class="params">(<span class="string">"out.txt"</span>,ios::out)</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> canWrite = <span class="literal">false</span>;</span><br><span class="line">    inItem item;</span><br><span class="line">    item.reset();</span><br><span class="line">    ostream_iterator&lt;<span class="built_in">string</span>&gt; output(outFile,<span class="string">"\n"</span>);</span><br><span class="line">    for_each(input_content.begin(), input_content.end(),</span><br><span class="line">            [&amp;](<span class="built_in">string</span> line)&#123;</span><br><span class="line">                <span class="keyword">if</span>(item.input(line))&#123; <span class="comment">//find #</span></span><br><span class="line">                    <span class="keyword">if</span>(canWrite)&#123;</span><br><span class="line">                        writeItem(outFile,item);</span><br><span class="line">                        item.reset();</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            canWrite = <span class="literal">true</span>;</span><br><span class="line">                        &#125;;  </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    item.input(line);</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    writeItem(outFile,item);</span><br><span class="line">    outFile.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="c-11-闭包-Liambda-Function"><a href="#c-11-闭包-Liambda-Function" class="headerlink" title="c++11 闭包(Liambda Function)"></a>c++11 闭包(Liambda Function)</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ capture ] ( params ) <span class="keyword">mutable</span> exception attribute -&gt; ret &#123; body &#125;  (<span class="number">1</span>) </span><br><span class="line">[ capture ] ( params ) -&gt; ret &#123; body &#125;  (<span class="number">2</span>) </span><br><span class="line">[ capture ] ( params ) &#123; body &#125; (<span class="number">3</span>) </span><br><span class="line">[ capture ] &#123; body &#125;    (<span class="number">4</span>)</span><br></pre></td></tr></table></figure><ol><li>lambda-introducer： 定义引用自由变量的方式,指定哪些在函数声明处的作用域中可见的符号将在函数体内可见.</li></ol><p>[] // 没有定义任何变量。使用未定义变量会导致错误。</p><p>[x, &amp;y] // x 以传值方式传入(默认)，y 以引用方式传入。</p><p>[&amp;] // 任何被使用到的外部变量皆隐式地以引用方式加以使用。</p><p>[=] // 任何被使用到的外部变量皆隐式地以传值方式加以使用。</p><p>[&amp;, x] // x 显示地以传值方式加以使用。其余变量以引用方式加以使用。</p><p>[=, &amp;z] // z 显示地以引用方式加以使用。其余变量以传值方式加以使用。</p><ol start="2"><li>lambda-parameter-declaration-list：</li></ol><p>参数列表。但是参数不可以有默认值，不可以使用变长参数，不可以有unamed arguments</p><ol start="3"><li>mutable-specification </li></ol><p>使得传值引入的变量可以修改。这个修改因为是修改的外部变量的拷贝，因此并不会影响它本来的值</p><ol start="4"><li>exception-specification：</li></ol><p>throw()该函数不能抛出异常。如果抛出异常，编译器将报warning C4297。 throw(…) 可以抛出异常。throw(type)可以抛出type的异常</p><ol start="5"><li>lambda-return-type-clause：</li></ol><p>如果仅有0/1个return的话可以省略。返回值可以是lambda表达式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> g = [](<span class="keyword">int</span> x) -&gt; function&lt;<span class="keyword">int</span> (<span class="keyword">int</span>)&gt; &#123; <span class="keyword">return</span> [=](<span class="keyword">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;; &#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> h = [](<span class="keyword">const</span> function&lt;<span class="keyword">int</span> (<span class="keyword">int</span>)&gt;&amp; f, <span class="keyword">int</span> z) &#123; <span class="keyword">return</span> f(z) + <span class="number">1</span>; &#125;;</span><br></pre></td></tr></table></figure><h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><ul><li><p>一般用法最后用括号传递参数值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">100</span>,y=<span class="number">200</span>,z=<span class="number">300</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; [ ](<span class="keyword">double</span> a,<span class="keyword">double</span> b) &#123; <span class="keyword">return</span> a + b; &#125; (<span class="number">1.2</span>,<span class="number">2.5</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//(1.2,2.5) 为a，b的参数值</span></span><br><span class="line"><span class="keyword">auto</span> ff = [=,&amp;y,&amp;z](<span class="keyword">int</span> n) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;x &lt;&lt; <span class="built_in">endl</span>; y++; z++;</span><br><span class="line"><span class="keyword">return</span> n*n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ff(<span class="number">15</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; y &lt;&lt; <span class="string">","</span> &lt;&lt; z &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li><li><p>闭包类似于函数指针用法，这个列子参数为引用类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">for_each(a.begin(),a.end(),[&amp;](<span class="keyword">int</span> &amp; x) &#123;total += x; x*=<span class="number">2</span>;&#125;); <span class="built_in">cout</span> &lt;&lt; total &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 10 </span></span><br><span class="line">for_each(a.begin(),a.end(),[ ](<span class="keyword">int</span> x) &#123; <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;&#125;); <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p>闭包实现斐波纳切数列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; fib = [&amp;fib](<span class="keyword">int</span> n)&#123; <span class="keyword">return</span> n &lt;= <span class="number">2</span> ? <span class="number">1</span> : fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>);&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; fib(<span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出5</span></span><br><span class="line"><span class="comment">//function&lt;int(int)&gt; 表示返回值为 int, 有一个int参数的函数 std::function 是一个类模版可以对函数(普通函数、成员函数)、lambda表达式、std::bind的绑定表达式、函数对象等进行封装。std::function的实例可以对这些封装的目标进行存储、复制和调用等操作</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 育碧面试网测(C++) </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>STLAlgorithme</title>
      <link href="/2016/11/15/STLAlgorithme/"/>
      <url>/2016/11/15/STLAlgorithme/</url>
      <content type="html"><![CDATA[<p><code>15 Nov 2016</code></p><p>使用模版算法需要 #include <algorithme></algorithme></p><h1 id="STL中的算法大致可以分为以下七类"><a href="#STL中的算法大致可以分为以下七类" class="headerlink" title="STL中的算法大致可以分为以下七类:"></a>STL中的算法大致可以分为以下七类:</h1><ul><li>不变序列算法 </li><li>变值算法</li><li>删除算法</li><li>变序算法</li><li>排序算法</li><li>有序区间算法 </li><li>数值算法</li></ul><p>大多重载的算法都是有两个版本的,用“==”判断元素是否相等,或用“&lt;”来比较大小 多出一个类型参数“Pred”和函数形参“Predop”:<br>通过表达式 “op(x,y)” 的返回值: ture/false,判断x是否 “等于” y，或者x是否 “小于” y<br><a id="more"></a></p><h1 id="不变序列算法"><a href="#不变序列算法" class="headerlink" title="不变序列算法"></a>不变序列算法</h1><p>该类算法不会修改算法所作用的容器或对象,适用于顺序容器和关联容器,时间复杂度都是O(n)</p><ul><li>min:求两个对象中较小的(可自定义比较器)</li><li>max:求两个对象中较大的(可自定义比较器)</li><li>find:在区间中查找等于某值的元素<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InIt</span> <span class="title">find</span>(<span class="title">InIt</span> <span class="title">first</span>, <span class="title">InIt</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">val</span>);</span></span><br></pre></td></tr></table></figure></li></ul><p>返回区间 [first,last) 中的迭代器 i ,使得 * i == val.</p><ul><li>count:计算区间中等于某值的元素个数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">size_t</span> <span class="title">count</span>(<span class="title">InIt</span> <span class="title">first</span>, <span class="title">InIt</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">val</span>);</span></span><br></pre></td></tr></table></figure></li></ul><p>计算[first, last) 中等于val的元素个数(x==y为true算等于)</p><ul><li>for_each:对区间中的每个元素都做某种操作<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt</span>, <span class="title">class</span> <span class="title">Fun</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Fun</span> <span class="title">for_each</span>(<span class="title">InIt</span> <span class="title">first</span>, <span class="title">InIt</span> <span class="title">last</span>, <span class="title">Fun</span> <span class="title">f</span>);</span></span><br></pre></td></tr></table></figure></li></ul><p>对[first, last)中的每个元素e, 执行f(e), 要求 f(e)不能改变e.</p><ul><li>min_element:求区间中的最小值(可自定义比较器)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">FwdIt</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">FwdIt</span> <span class="title">min_element</span>(<span class="title">FwdIt</span> <span class="title">first</span>, <span class="title">FwdIt</span> <span class="title">last</span>);</span></span><br></pre></td></tr></table></figure></li></ul><p>返回[first,last) 中最小元素的迭代器, 以 “&lt;” 作比较器,最小指没有元素比它小, 而不是它比别的不同元素都小 因为即便a!= b, a&lt;b 和b&lt;a有可能都不成立.</p><ul><li>max_element:求区间中的最大值(可自定义比较器)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">FwdIt</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">FwdIt</span> <span class="title">max_element</span>(<span class="title">FwdIt</span> <span class="title">first</span>, <span class="title">FwdIt</span> <span class="title">last</span>);</span></span><br></pre></td></tr></table></figure></li></ul><p>返回[first,last) 中最大元素(不小于任何其他元素)的迭代器 以 “&lt;” 作比较器.</p><ul><li>count_if:计算区间中符合某种条件的元素个数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt</span>, <span class="title">class</span> <span class="title">Pred</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">size_t</span> <span class="title">count_if</span>(<span class="title">InIt</span> <span class="title">first</span>, <span class="title">InIt</span> <span class="title">last</span>, <span class="title">Pred</span> <span class="title">pr</span>);</span></span><br></pre></td></tr></table></figure></li></ul><p>计算[first, last) 中符合pr(e) == true 的元素e的个数</p><ul><li>find_if:在区间中查找符合某条件的元素<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt</span>, <span class="title">class</span> <span class="title">Pred</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InIt</span> <span class="title">find_if</span>(<span class="title">InIt</span> <span class="title">first</span>, <span class="title">InIt</span> <span class="title">last</span>, <span class="title">Pred</span> <span class="title">pr</span>);</span></span><br></pre></td></tr></table></figure></li></ul><p>返回区间 [first,last) 中的迭代器 i, 使得 pr(*i) == true.</p><ul><li>find_end:在区间中查找另一个区间最后一次出现的位 置(可自定义比较器)</li><li>find_first_of:在区间中查找第一个出现在另一个区间中的元素 (可自定义比较器)</li><li>adjacent_find:在区间中寻找第一次出现连续两个相等元素的位置(可自定义比较器)</li><li>search:在区间中查找另一个区间第一次出现的位置(可自定义比较器)</li><li>search_n:在区间中查找第一次出现等于某值的连续n个元 素(可自定义比较器)</li><li>equal:判断两区间是否相等(可自定义比较器)</li><li>mismatch:逐个比较两个区间的元素，返回第一次发生不相等的两个元素的位置(可自定义比较器)</li></ul><h1 id="变值算法"><a href="#变值算法" class="headerlink" title="变值算法"></a>变值算法</h1><p>此类算法会修改源区间或目标区间元素的值,值被修改的那个区间, 不可以是属于关联容器的。</p><ul><li>for_each:对区间中的每个元素都做某种操作</li><li>copy:复制一个区间到别处<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt</span>, <span class="title">class</span> <span class="title">OutIt</span>&gt; <span class="title">OutIt</span> <span class="title">copy</span>(<span class="title">InIt</span> <span class="title">first</span>, <span class="title">InIt</span> <span class="title">last</span>, <span class="title">OutIt</span> <span class="title">x</span>);</span></span><br></pre></td></tr></table></figure></li></ul><p>本函数对每个在区间[0, last - first)中的N执行一次 <em>(x+N) = </em>(first + N), 返回 x + </p><ul><li>copy_backward:复制一个区间到别处, 但目标区前是从后往前被修改的</li><li>transform:将一个区间的元素变形后拷贝到另一个区间<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt</span>, <span class="title">class</span> <span class="title">OutIt</span>, <span class="title">class</span> <span class="title">Unop</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutIt</span> <span class="title">transform</span>(<span class="title">InIt</span> <span class="title">first</span>, <span class="title">InIt</span> <span class="title">last</span>, <span class="title">OutIt</span> <span class="title">x</span>, <span class="title">Unop</span> <span class="title">uop</span>);</span></span><br></pre></td></tr></table></figure></li></ul><p>对[first,last)中的每个迭代器I,执行 uop( <em> I ); 并将结果依次放入从 x 开始的地方,要求 uop( </em> I ) 不得改变 * I 的值.<br>本模板返回值是个迭代器, 即 x + (last-first) • x可以和 first相等.</p><ul><li>swap_ranges:交换两个区间内容</li><li>fill:用某个值填充区间</li><li>fill_n:用某个值替换区间中的n个元素</li><li>generate:用某个操作的结果填充区间</li><li>generate_n:用某个操作的结果替换区间中的n个元素</li><li>replace:将区间中的某个值替换为另一个值</li><li>replace_if:将区间中符合某种条件的值替换成另一个值</li><li>replace_copy:将一个区间拷贝到另一个区间，拷贝时某个值 要换成新值拷过去</li><li>replace_copy_if:将一个区间拷贝到另一个区间，拷贝时符合某条件的值要换成新值拷过去</li></ul><h1 id="删除算法"><a href="#删除算法" class="headerlink" title="删除算法"></a>删除算法</h1><p>删除一个容器里的某些元素<br>删除不会使容器里的元素减少<br>删除算法不应作用于关联容器<br>算法复杂度都是O(n)的</p><ul><li>将所有应该被删除的元素看做空位子</li><li>用留下的元素从后往前移, 依次去填空位子</li><li>元素往前移后, 它原来的位置也就算是空位子</li><li>也应由后面的留下的元素来填上</li><li><p>最后, 没有被填上的空位子, 维持其原来的值不变</p></li><li><p>remove:删除区间中等于某个值的元素</p></li><li>remove_if:删除区间中满足某种条件的元素</li><li>remove_copy:拷贝区间到另一个区间. 等于某个值的元素不拷贝</li><li>remove_copy_if:拷贝区间到另一个区间. 符合某种条件的元素不拷贝</li><li>unique:删除区间中连续相等的元素, 只留下一个(可自定义比较器)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">FwdIt</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">FwdIt</span> <span class="title">unique</span>(<span class="title">FwdIt</span> <span class="title">first</span>, <span class="title">FwdIt</span> <span class="title">last</span>);</span></span><br><span class="line"><span class="comment">//用 == 比较是否等</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">FwdIt</span>, <span class="title">class</span> <span class="title">Pred</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">FwdIt</span> <span class="title">unique</span>(<span class="title">FwdIt</span> <span class="title">first</span>, <span class="title">FwdIt</span> <span class="title">last</span>, <span class="title">Pred</span> <span class="title">pr</span>);</span></span><br><span class="line"><span class="comment">//用 pr (x,y)为 true说明x和y相等</span></span><br></pre></td></tr></table></figure></li></ul><p>对[first,last) 这个序列中连续相等的元素, 只留下第一个,返回值是迭代器, 指向元素删除后的区间的最后一个元 素的后面</p><ul><li>unique_copy:拷贝区间到另一个区间. 连续相等的元素, 只拷贝第一个到目 标区间 (可自定义比较器)</li></ul><h1 id="变序算法"><a href="#变序算法" class="headerlink" title="变序算法"></a>变序算法</h1><p>变序算法改变容器中元素的顺序,是不改变元素的值,变序算法不适用于关联容器,算法复杂度都是O(n)的.</p><ul><li>reverse:颠倒区间的前后次序</li><li>reverse_copy:把一个区间颠倒后的结果拷贝到另一个区间,源区间不变</li><li>rotate:将区间进行循环左移</li><li>rotate_copy:将区间以首尾相接的形式进行旋转后的结果,拷贝到另一个区间，源区间不变</li><li>next_permutation:将区间改为下一个排列(可自定义比较器)</li><li>prev_permutation:将区间改为上一个排列(可自定义比较器)</li><li>random_shuffle:随机打乱区间内元素的顺序</li><li>partition:把区间内满足某个条件的元素移到前面，不满足该条件的移到后面</li></ul><h1 id="有序区间算法"><a href="#有序区间算法" class="headerlink" title="有序区间算法"></a>有序区间算法</h1><p>要求所操作的区间是已经从小到大排好序的 需要随机访问迭代器的支持 有序区间算法不能用于关联容器和list</p><ul><li><p>binary_search:判断区间中是否包含某个元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">FwdIt</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">binary_search</span>(<span class="title">FwdIt</span> <span class="title">first</span>, <span class="title">FwdIt</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">val</span>);</span></span><br><span class="line"><span class="comment">//上面这个版本, 比较两个元素x, y 大小时, 看 x &lt; y template&lt;class FwdIt, class T, class Pred&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">binary_search</span><span class="params">(FwdIt first, FwdIt last, <span class="keyword">const</span> T&amp; val, Pred pr)</span></span>;</span><br><span class="line"><span class="comment">//上面这个版本, 比较两个元素x, y 大小时, 若 pr(x,y) 为true, 则 认为x小于y</span></span><br></pre></td></tr></table></figure></li><li><p>includes:判断是否一个区间中的每个元素，都在另一个区间中</p></li><li><p>lower_bound:查找最后一个不小于某值的元素的位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">FwdIt</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">FwdIt</span> <span class="title">lower_bound</span>(<span class="title">FwdIt</span> <span class="title">first</span>, <span class="title">FwdIt</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">val</span>);</span></span><br><span class="line"><span class="comment">//要求[first,last)是有序的</span></span><br><span class="line"><span class="comment">//查找[first,last)中的, 最大的位置 FwdIt, 使得[first,FwdIt)中所有的元素都比 val 小</span></span><br></pre></td></tr></table></figure></li><li><p>upper_bound:查找第一个大于某值的元素的位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">FwdIt</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">FwdIt</span> <span class="title">upper_bound</span>(<span class="title">FwdIt</span> <span class="title">first</span>, <span class="title">FwdIt</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">val</span>);</span></span><br><span class="line"><span class="comment">//要求[first,last)是有序的</span></span><br><span class="line"><span class="comment">//查找[first,last)中的, 最小的位置 FwdIt, 使得[FwdIt,last)中所有的元素都比 val 大</span></span><br></pre></td></tr></table></figure></li><li><p>equal_range:同时获取lower_bound和upper_bound</p></li><li><p>merge:合并两个有序区间到第三个区间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt1</span>, <span class="title">class</span> <span class="title">InIt2</span>, <span class="title">class</span> <span class="title">OutIt</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutIt</span> <span class="title">merge</span>(<span class="title">InIt1</span> <span class="title">first1</span>, <span class="title">InIt1</span> <span class="title">last1</span>, <span class="title">InIt2</span> <span class="title">first2</span>, <span class="title">InIt2</span> <span class="title">last2</span>, <span class="title">OutIt</span> <span class="title">x</span>);</span></span><br><span class="line"><span class="comment">//用 &lt; 作比较器</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt1</span>, <span class="title">class</span> <span class="title">InIt2</span>, <span class="title">class</span> <span class="title">OutIt</span>, <span class="title">class</span> <span class="title">Pred</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutIt</span> <span class="title">merge</span>(<span class="title">InIt1</span> <span class="title">first1</span>, <span class="title">InIt1</span> <span class="title">last1</span>, <span class="title">InIt2</span> <span class="title">first2</span>, <span class="title">InIt2</span> <span class="title">last2</span>, <span class="title">OutIt</span> <span class="title">x</span>, <span class="title">Pred</span> <span class="title">pr</span>);</span></span><br><span class="line"><span class="comment">//用 pr 作比较器把[first1,last1), [ first2,last2) 两个升序序列合并, 形成第 3 个升序序列, 第3个升序序列以 x 开头</span></span><br></pre></td></tr></table></figure></li><li><p>set_union:将两个有序区间的并拷贝到第三个区间</p></li><li>set_intersection:将两个有序区间的交拷贝到第三个区间</li><li>set_difference:将两个有序区间的差拷贝到第三个区间</li><li>set_symmetric_difference:将两个有序区间的对称差拷贝到第三个区间</li><li>inplace_merge:将两个连续的有序区间原地合并为一个有序区间</li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>StandardTemplateLibrary(STL)</title>
      <link href="/2016/11/11/StandardTemplateLibrary-STL/"/>
      <url>/2016/11/11/StandardTemplateLibrary-STL/</url>
      <content type="html"><![CDATA[<p><code>11 Nov 2016</code></p><h1 id="范型程序设计"><a href="#范型程序设计" class="headerlink" title="范型程序设计"></a>范型程序设计</h1><p>C++ 语言的核心优势之一就是便于软件的重用，C++中有两个方面体现重用:</p><ol><li>面向对象的思想:继承和多态，标准类库</li><li>泛型程序设计(generic programming) 的思想: 模板机 制，以及标准模板库 STL。</li></ol><p>将一些常用的数据结构(比如链表，数组，二叉树) 和算法(比如排序，查找)写成模板，以后则不论数据 结构里放的是什么对象，算法针对什么样的对象，则都 不必重新实现数据结构，重新编写算法。</p><p>标准模板库 (Standard Template Library) 就是一些常用数据结构和算法的模板的集合。<br>有了STL，不必再写大多的标准数据结构和算法，并且可获得非常高的性能。</p><h1 id="标准模版库"><a href="#标准模版库" class="headerlink" title="标准模版库"></a>标准模版库</h1><ul><li>容器:可容纳各种数据类型的通用数据结构,是类模板 </li><li>迭代器:可用于依次存取容器中元素，类似于指针 </li><li>算法:用来操作容器中的元素的函数模板</li></ul><a id="more"></a><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>可以用于存放各种类型的数据(基本类型的变量， 对象等)的数据结构，都是类模版,分为三种:</p><ol><li>顺序容器(无序的)</li></ol><ul><li>vector, deque,list</li></ul><ol start="2"><li>关联容器(排序的)</li></ol><ul><li>set, multiset, map, multimap</li></ul><ol start="3"><li>容器适配器</li></ol><ul><li>stack, queue, priority_queue(排序的)</li></ul><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>头文件 #include <vector></vector></p><p>可变长的动态数组。元素在内存连续存放。支持随机访问迭代器，随机存取任何元素都能在常数时间完成。<br>在尾端增删元素具有较佳的性能(大部分情况下是常数时间)。在中间插入慢。<br>所有STL算法都能对vector操作。</p><h4 id="构造函数初始化"><a href="#构造函数初始化" class="headerlink" title="构造函数初始化"></a>构造函数初始化</h4><ul><li>vector(): 无参构造函数, 将容器初始化成空的</li><li>vector(int n) : 将容器初始化成有n个元素</li><li>vector(int n, const T &amp; val) : 假定元素类型是T, 将容器初始化成 有n个元素, 每个元素的值都是val</li><li>vector(iterator first, iterator last) : 将容器初始化为与别的容器上区间 [first, last)一致的内容</li></ul><h4 id="vector的成员函数"><a href="#vector的成员函数" class="headerlink" title="vector的成员函数"></a>vector的成员函数</h4><ul><li>void pop_back() : 删除容器末尾的元素</li><li>void push_back(const T &amp; val) : 将val添加到容器末尾</li><li>int size() : 返回容器中元素的个数</li><li>T &amp; font() : 返回容器中第一个元素的引用</li><li>T &amp; back() : 返回容器中最后一个元素的引用</li></ul><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>双向队列 #include <deque></deque></p><p>所有适用于vector的操作都适用于deque。<br>deque还有 <code>push_front()</code> (将元素插入到容器的头部) 和 <code>pop_front()</code>(删除头部的元素)操作。</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>双向链表 #include <list></list></p><p>不支持根据下标随机存取元素，在任何位置插入/删除都是常数时间。<br>具有所有顺序容器都有的成员函数。</p><h4 id="list特有成员函数"><a href="#list特有成员函数" class="headerlink" title="list特有成员函数"></a>list特有成员函数</h4><ul><li>push_front ：在链表最前面插入</li><li>pop_front：删除链表最前面的元素</li><li>sort ：排序 (list 不支持 STL 的算法 sort)</li><li>remove：删除和指定值相等的所有元素</li><li>unique：删除所有和前一个元素相同的元素</li><li>merge：合并两个链表, 并清空被合并的链表</li><li>reverse：颠倒链表</li><li>splice：在指定位置前面插入另一链表中的一个或多个元素, 并在另一链表中删除被插入的元素</li></ul><h4 id="list容器之sort函数"><a href="#list容器之sort函数" class="headerlink" title="list容器之sort函数"></a>list容器之sort函数</h4><p>list容器的迭代器不支持完全随机访问，不能用标准库中sort函数对它进行排序。</p><p>list自己的sort成员函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;T&gt; classname</span><br><span class="line">classname.sort(compare); <span class="comment">//compare函数可以自己定义 </span></span><br><span class="line">classname.sort(); <span class="comment">//无参数版本, 按&lt;排序</span></span><br></pre></td></tr></table></figure></p><h3 id="顺序容器的常用成员函数"><a href="#顺序容器的常用成员函数" class="headerlink" title="顺序容器的常用成员函数"></a>顺序容器的常用成员函数</h3><ul><li>front :返回容器中第一个元素的引用</li><li>back : 返回容器中最后一个元素的引用</li><li>push_back : 在容器末尾增加新元素</li><li>pop_back : 删除容器末尾的元素</li><li>erase :删除迭代器指向的元素(可能会使该迭代器失效)，或 删除一个区间，返回被删除元素后面的那个元素的迭代器</li></ul><h3 id="set-multiset"><a href="#set-multiset" class="headerlink" title="set/multiset"></a>set/multiset</h3><p>头文件 #include <set><br>元素是排序的,插入任何元素，都按相应的排序规则来确定其位置,set 即集合。set中不允许相同元素，multiset中允许存在相同的元素。</set></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Pred</span> = <span class="title">less</span>&lt;Key&gt;, <span class="title">class</span> <span class="title">A</span> = <span class="title">allocator</span>&lt;Key&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">multiset</span> &#123;</span> ...... &#125;;</span><br></pre></td></tr></table></figure><p>Pred类型的变量决定了multiset 中的元素，“一个比另一个小”是怎么定义的。 multiset运行过程中，比较两个元素x,y的大小的做法，就是生成一个 Pred类型的 变量，假定为 op,若表达式op(x,y) 返回值为true,则 x比y小。<br>Pred的缺省类型是 less<key>。</key></p><h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><ul><li>iterator find(const T &amp; val)： 在容器中查找值为val的元素，返回其迭代器。如果找不到，返回end()。</li><li>iterator insert(const T &amp; val)： 将val插入到容器中并返回其迭代器。</li><li>void insert( iterator first,iterator last)： 将区间[first,last)插入容器。</li><li>int count(const T &amp; val)：  统计有多少个元素的值和val相等。</li><li>iterator lower_bound(const T &amp; val)：查找一个最大的位置 it,使得[begin(),it) 中所有的元素都比 val 小。</li><li>iterator upper_bound(const T &amp; val)：<br>查找一个最小的位置 it,使得[it,end()) 中所有的元素都比 val 大。</li><li>pair&lt;iterator,iterator&gt; equal_range(const T &amp; val)：同时求得lower_bound和upper_bound。</li><li>iterator erase(iterator it)：<br>删除it指向的元素，返回其后面的元素的迭代器(Visual studio 2010上如此，但是在 C++标准和Dev C++中，返回值不是这样)。</li></ul><h3 id="map-multimap"><a href="#map-multimap" class="headerlink" title="map/multimap"></a>map/multimap</h3><p>头文件 #include <map><br>map与set的不同在于map中存放pari,其有且仅有两个成员变量，一个名 为first,另一个名为second, map根据first值对元素进行从小到大排序，并可快速地根据first来检索元素。<br>map同multimap的不同在于是否允许相同first值的元素。</map></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Pred</span> = <span class="title">less</span>&lt;Key&gt;, <span class="title">class</span> <span class="title">A</span> = <span class="title">allocator</span>&lt;T&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">multimap</span> &#123;</span> ....</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">const</span> Key, T&gt; value_type; .......</span><br><span class="line"><span class="comment">//Key 代表关键字的类型</span></span><br></pre></td></tr></table></figure><h4 id="pair-模板"><a href="#pair-模板" class="headerlink" title="pair 模板"></a>pair 模板</h4><p>map/multimap里放着的都是pair模版类的对象，且按first从小到大排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">T1</span>, <span class="title">class</span> _<span class="title">T2</span>&gt; <span class="title">struct</span> <span class="title">pair</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> _T1 first_type; <span class="keyword">typedef</span> _T2 second_type;</span><br><span class="line">_T1 first;</span><br><span class="line">_T2 second;</span><br><span class="line">pair(): first(), second() &#123; &#125;</span><br><span class="line">pair(<span class="keyword">const</span> _T1&amp; __a, <span class="keyword">const</span> _T2&amp; __b) : first(__a), second(__b) &#123; &#125; <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">U1</span>, <span class="title">class</span> _<span class="title">U2</span>&gt; <span class="title">pair</span>(<span class="title">const</span> <span class="title">pair</span>&lt;_U1, _U2&gt;&amp; __<span class="title">p</span>)</span></span><br><span class="line"><span class="class">:</span> first(__p.first), second(__p.second) &#123; &#125; &#125;;</span><br></pre></td></tr></table></figure><p>multimap中的元素由 &lt;关键字,值&gt;组成，每个元素是一个pair对象，关键字<br>就是first成员变量,其类型是Key。</p><p>multimap 中允许多个元素的关键字相同。元素按照first成员变量从小到大<br>排列，缺省情况下用 less<key> 定义关键字的“小于”关系。</key></p><h4 id="map的-成员函数"><a href="#map的-成员函数" class="headerlink" title="map的[]成员函数"></a>map的[]成员函数</h4><p>若pairs为map模版类的对象，<br>pairs[key]<br>返回对关键字等于key的元素的值(second成员变量)的引用。若没有关键 字为key的元素，则会往pairs里插入一个关键字为key的元素，其值用无参构造函数初始化，并返回其值的引用。</p><h4 id="成员函数-1"><a href="#成员函数-1" class="headerlink" title="成员函数"></a>成员函数</h4><ul><li>find: 查找等于某个值 的元素(x小于y和y小于x同时不成立即为相等) </li><li>lower_bound : 查找某个下界</li><li>upper_bound : 查找某个上界</li><li>equal_range : 同时查找上界和下界</li><li>count :计算等于某个值的元素个数(x小于y和y小于x同时不成立即为相等) </li><li>insert: 用以插入一个元素或一个区间</li></ul><h3 id="顺序容器和关联容器中都有的成员函数"><a href="#顺序容器和关联容器中都有的成员函数" class="headerlink" title="顺序容器和关联容器中都有的成员函数"></a>顺序容器和关联容器中都有的成员函数</h3><ul><li>begin： 返回指向容器中第一个元素的迭代器</li><li>end： 返回指向容器中最后一个元素后面的位置的迭代器  </li><li>rbegin 返回指向容器中最后一个元素的迭代器</li><li>rend： 返回指向容器中第一个元素前面的位置的迭代器 </li><li>erase 从容器中删除一个或几个元素</li><li>clear： 从容器中删除所有元素</li></ul><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>用于指向顺序容器和关联容器中的元素，迭代器用法和指针类似。<br>有const 和非 const两种。通过迭代器可以读取它指向的元素，通过非const迭代器还能修改其指向的元素。</p><p>定义一个容器类的迭代器的方法可以是:<br><code>容器类名::iterator 变量名;</code><br>或:<br><code>容器类名::const_iterator 变量名;</code><br>访问一个迭代器指向的元素:<br><code>* 迭代器变量名</code></p><p>迭代器上可以执行 ++ 操作, 以使其指向容器中的下一个元素。 如果迭代器到达了容器中的最后一个元素的后面，此时再使用 它，就会出错，类似于使用NULL或未初始化的指针一样.</p><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>头文件 #include <stack><br>后进先出,容器适配器上没有迭代器。</stack></p><p>容器适配器都有3个成员函数:</p><ul><li>push: 添加一个元素;</li><li>top: 返回栈顶部或队头元素的引用 </li><li>pop: 删除一个元素</li></ul><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p>头文件 #include <queue><br>先进先出，只能插入, 删除, 访问栈顶的元素。同样也有push, pop, top函数</queue></p><ul><li>push发生在队尾</li><li>pop, top发生在队头, 先进先出</li></ul><h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><p>头文件 #include <queue><br>最高优先级元素总是第一个出列，priority_queue 通常用堆排序技术实现, 保证最大的元素总是在最前面，默认的元素比较器是 less<t>。</t></queue></p><ul><li>执行pop操作时, 删除的是最大的元素</li><li>执行top操作时, 返回的是最大元素的引用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">priority_queue&lt;<span class="keyword">double</span>&gt; priorities; </span><br><span class="line">priorities.push(<span class="number">3.2</span>);</span><br><span class="line">priorities.push(<span class="number">9.8</span>); </span><br><span class="line">priorities.push(<span class="number">5.4</span>);</span><br><span class="line"><span class="keyword">while</span>( !priorities.empty() ) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; priorities.top() &lt;&lt; <span class="string">" "</span>; priorities.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">//输出结果: 9.8 5.4 3.2</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>FileStreamAndTemplate.md</title>
      <link href="/2016/11/08/FileStreamAndTemplate/"/>
      <url>/2016/11/08/FileStreamAndTemplate/</url>
      <content type="html"><![CDATA[<p><code>8 Nov 2016</code></p><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>用于文件操作 — 统称为文件流类。C++标准库中: ifstream, ofstream和fstream共3个类。<br>先打开文件，再读写文件，再关闭文件。<br>包含头文件 <code>#include &lt;fstream&gt;</code> </p><h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><ol><li><p>创建文件流对象并且打开<br><code>ofstream outFile(“clients.dat”, ios::out|ios::binary);</code></p></li><li><p>创建文件流之后打开</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ofstream fout;</span><br><span class="line">fout.open( “test.out”, ios::out|ios::binary );</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><h2 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h2><p>对于输入文件,有一个读指针。对于输出文件, 有一个写指针。对于输入输出文件, 有一个读写指针。标识文件操作的当前位置, 该指针在哪里读写操作就在哪里进行。</p><ol><li>读指针</li></ol><p>tellg() : 取得读指针的位置。<br>seekg() : 将读指针移动到指定位置。</p><p>例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(“a1.in”,ios::in)</span></span>; </span><br><span class="line"><span class="keyword">long</span> location = fin.tellg(); <span class="comment">//取得读指针的位置</span></span><br><span class="line">location = <span class="number">10L</span>;  </span><br><span class="line">fin.seekg(location);    <span class="comment">//将读指针移动到第10个字节处</span></span><br><span class="line">fin.seekg(location, ios::beg); <span class="comment">//从头数location </span></span><br><span class="line">fin.seekg(location, ios::cur); <span class="comment">//从当前位置数location </span></span><br><span class="line">fin.seekg(location, ios::end);<span class="comment">//从尾部数location</span></span><br></pre></td></tr></table></figure></p><ol start="2"><li>写指针</li></ol><p>tellp() : 取得写指针的位置。<br>seekp() : 将写指针移动到指定位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(“a1.in”,ios::in)</span></span>; </span><br><span class="line"><span class="keyword">long</span> location = fin.tellg(); <span class="comment">//取得读指针的位置</span></span><br><span class="line">location = <span class="number">10L</span>; </span><br><span class="line">fin.seekg(location); <span class="comment">//将读指针移动到第10个字节处 </span></span><br><span class="line">fin.seekg(location, ios::beg); <span class="comment">//从头数location</span></span><br><span class="line">fin.seekg(location, ios::cur); <span class="comment">//从当前位置数location </span></span><br><span class="line">fin.seekg(location, ios::end); <span class="comment">//从尾部数location</span></span><br></pre></td></tr></table></figure><h2 id="文件的读写"><a href="#文件的读写" class="headerlink" title="文件的读写"></a>文件的读写</h2><ol><li><p>写如文件内容：<br><code>fout.write( (const char *)(&amp;x), sizeof(int) );</code></p></li><li><p>读取文件内容<br><code>fin.read( (char *)(&amp;x), sizeof(int) );</code></p></li></ol><h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(“test.dat”, ios::in)</span></span>;</span><br><span class="line">fin.close();</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(“test.dat”, ios::out)</span></span>;</span><br><span class="line">fout.close();</span><br></pre></td></tr></table></figure><h1 id="函数模版"><a href="#函数模版" class="headerlink" title="函数模版"></a>函数模版</h1><p>例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Swap</span>(<span class="title">T</span> &amp; <span class="title">x</span>, <span class="title">T</span> &amp; <span class="title">y</span>) &#123;</span></span><br><span class="line">T tmp = x; x = y;</span><br><span class="line">y = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T1</span> <span class="title">myFunction</span>( <span class="title">T1</span> <span class="title">arg1</span>, <span class="title">T2</span> <span class="title">arg2</span>) &#123;</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;arg1&lt;&lt;“ ”&lt;&lt;arg2&lt;&lt;“\n”;</span><br><span class="line"><span class="keyword">return</span> arg1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="类模版"><a href="#类模版" class="headerlink" title="类模版"></a>类模版</h1><p>在定义类的时候给它一个/多个参数，这个/些参数表示不同的数据类型。<br>在调用类模板时, 指定参数, 由编译系统根据参数提供 的数据类型自动产生相应的模板类。</p><h2 id="类模版的定义"><a href="#类模版的定义" class="headerlink" title="类模版的定义"></a>类模版的定义</h2><ol><li><p>写类模版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt; <span class="title">class</span> <span class="title">Pair</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T1 key; <span class="comment">//关键字</span></span><br><span class="line">T2 value; <span class="comment">//值</span></span><br><span class="line">Pair(T1 k,T2 v):key(k),value(v) &#123;&#125;;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Pair&lt;T1,T2&gt; &amp; p) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>声明一个模版类对象</p></li></ol><p>编译器由类模板生成类的过程叫类模板的实例化<br>由类模板实例化得到的类叫模板类</p><p>类模板名 &lt;真实类型参数表&gt; 对象名(构造函数实际参数表);<br><code>Pair&lt;string, int&gt; student(&quot;Tom&quot;,19);</code></p><h2 id="类模板与非类型参数"><a href="#类模板与非类型参数" class="headerlink" title="类模板与非类型参数"></a>类模板与非类型参数</h2><p>类模板的参数声明中可以包括非类型参数</p><p><code>template &lt;class T, int elementsNumber&gt;</code></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>RegularExpression.md</title>
      <link href="/2016/11/02/RegularExpression/"/>
      <url>/2016/11/02/RegularExpression/</url>
      <content type="html"><![CDATA[<p><code>Nov 2 2016</code></p><h1 id="正则表达式RegexOne译文-Toutorial-From-RegexOne"><a href="#正则表达式RegexOne译文-Toutorial-From-RegexOne" class="headerlink" title="正则表达式RegexOne译文(Toutorial From RegexOne)"></a>正则表达式RegexOne译文(Toutorial From RegexOne)</h1><p>[TOC]</p><h1 id="第一课-介绍、ABC、123"><a href="#第一课-介绍、ABC、123" class="headerlink" title="第一课 介绍、ABC、123"></a>第一课 介绍、ABC、123</h1><p>正则表达式在从文本如代码、日志文件、电子表格、或文件中抽取信息是非常有用的。虽然这个语言背后有很深入的理论背景，在接下来的课程和练习中我们将探讨正则表达式的实践用途，让读者可以快速上手使用。</p><p>在用正则表达式之前先要明确的是，在正则表达式中所有东西都用字符表达，我们写的是一些模式能够匹配一些特定的字符串。大部分模式用ASCII，其中使用了字母，数字，表达和你在键盘上能找到的字符，但是可以用Unicode字符来匹配任何语言的文本。<br><a id="more"></a><br>以下是一个小例子：<br>Match   abcdefg<br>Match   abcde<br>Match   abc</p><p>pattern:</p><blockquote><p><code>abd</code></p></blockquote><p>字符如果去查ASCII码的话，包括字母、数字和其他符号。<br>在接下来的课中我们会学习一下元字符用来匹配特定的字符。</p><ul><li>\d :匹配0-9的任意数字字符</li><li>\D :匹配任意飞数字的字符</li></ul><p><code>\</code>符使其与普通d／D 字母区分开，表示其是一个元字符。 </p><p>例子：<br>Match   abc123xyz<br>Match   define “123”<br>Match   var g = 123;</p><blockquote><p><code>123</code>; <code>\d</code>; <code>\D</code> ; <code>\d\d\d</code> 等等</p></blockquote><h1 id="第二课-点"><a href="#第二课-点" class="headerlink" title="第二课 点 ."></a>第二课 点 .</h1><p>在正则表达式中，经常会遇见的情况是，你想匹配格式一样内容未知的文本，比如电话号码、邮政编码。</p><p>句点<code>.</code>元字符可实现，其匹配任意一个单个字符。</p><p>句点元字符复写了句号字符的功能，如果想匹配句号而不是枇杷任意一个字符使用<code>\.</code></p><p>例子：</p><p>Match   cat.<br>Match   896.<br>Match   ?=+.<br>Skip    abc1</p><blockquote><p><code>...\.</code>; <code>\.</code></p></blockquote><h1 id="第三课-匹配指定字符集"><a href="#第三课-匹配指定字符集" class="headerlink" title="第三课 匹配指定字符集 []"></a>第三课 匹配指定字符集 []</h1><p>句点操作符功能很强大，但匹配太广泛，如果我们匹配电话号码，我们并不期望匹配到字母。</p><p>在方括号<code>[ ]</code>中指明具体的字符，可以实现对具体一个字符的条件匹配。比如，<code>[abc]</code>只会匹配a，b或c。</p><p>例子：<br>Match   can<br>Match   man<br>Match   fan<br>Skip    dan<br>Skip    ran<br>Skip    pan</p><blockquote><p><code>[cmf]an</code>; 或 <code>[^drp]an</code>；</p></blockquote><h1 id="第四课-不匹配指定字符集"><a href="#第四课-不匹配指定字符集" class="headerlink" title="第四课 不匹配指定字符集 [^]"></a>第四课 不匹配指定字符集 [^]</h1><p>有些情况下，我们不需要匹配某一些字符。比如，电话号码匹配中，也许我们不想匹配650地区的号码</p><p>实现不匹配指定字符集功能，我们用<code>[^abc]</code>这样这个字符就不匹配a、b、c。</p><p>例子：<br>Match   hog<br>Match   dog<br>Skip    bog </p><blockquote><p><code>[^b]og</code>; 或 <code>[hd]og</code></p></blockquote><h1 id="第五课-字符范围"><a href="#第五课-字符范围" class="headerlink" title="第五课 字符范围 [ - ]"></a>第五课 字符范围 [ - ]</h1><p>有些情况下，我们要匹配的字符在一些字符中或在某些字符范围中，我们用<code>-</code>连接两个字符表示范围。</p><p>比如<code>[0-6]</code>表示0到6，<code>[^n-p]</code>表示匹配一个不是从n到p之内的字符</p><p>在一个方括号里也可以用多个范围。比如<code>[A-Za-z0-9]</code>是用了匹配一个字母或数字的表达式。<br><code>\w</code> 原字符表示一个字母或数字的字符(AlphaNumeric)<br><code>\W</code> 表示一个非字母数字的字符(Non-AlphaNumeric)</p><p>例子：<br>Match   Ana<br>Match   Bob<br>Match   Cpc<br>Skip    aax<br>Skip    bby<br>Skip    ccz</p><blockquote><p><code>[A-C][n-p][a-c]</code></p></blockquote><h1 id="第六课-重复内容"><a href="#第六课-重复内容" class="headerlink" title="第六课 重复内容 {}"></a>第六课 重复内容 {}</h1><p>如果我们想匹配重复的字符，怎么办呢？一个方法是重复的写出匹配表达式，如<code>\d\d\d</code>这样可以匹配3个数字。<br>一种更方便的方法是使用大括号注释。</p><p><code>a{3}</code> 表示匹配a这个字符3次。有些引擎还能实现如<code>a{1,3}</code>表示把a匹配不少于1次不多余3次。<br>这个限定符可以用在任何字符上。比如<code>[wxy]{5}</code> 匹配5次w、x、y任意一个的字符。<code>.{2,6}</code>匹配2到6次任意字符。</p><p>例子：</p><p>Match   wazzzzzup<br>Match   wazzzup<br>Skip    wazup</p><blockquote><p><code>waz{3,5}up</code></p></blockquote><h1 id="第七课-与"><a href="#第七课-与" class="headerlink" title="第七课   * 与 +"></a>第七课   * 与 +</h1><p>正则表达式中的一个强大的功能是匹配任意数量的字符。例如， 假设让你写一个捐款表格，其中一个捐款数量字段需要填入一个单位是美元的数字。有钱的捐款者可能卷25,000$而一般人则卷25$。</p><p>一种解决这样匹配的方式用到称为克莱尼(斯蒂芬·科尔·克莱尼,美国数学家、逻辑学家、他也是正则表示法的发明者)+和克莱尼<em>的概念。其表示0个或更多和一个或更多。具体的说，一个上面捐款的匹配可以是：<br>`\d</em><code>表示一个数字字符或更多。一个更好的写法则为：</code>\d+`表示一个数字或更多，其保证了至少一个数字的输入。</p><p>这两个限定符可以与任何字符或元字符连用。比如，<code>a+</code> 一个或更多a。<code>[abc]+</code> 一个或更多a、b、c其中一个字符。 <code>.*</code>0个或更多任意字符。</p><p>例子：</p><p>Match   aaaabcc<br>Match   aabbbbc<br>Match   aacc<br>Skip    a</p><blockquote><p><code>a+b*c+</code>;或 <code>a{2,4}b{0,4}c{1,2}</code>;</p></blockquote><h1 id="第八课-可选元字符-？"><a href="#第八课-可选元字符-？" class="headerlink" title="第八课   可选元字符 ？"></a>第八课   可选元字符 ？</h1><p>一个可以提供可选择性的限度符是<code>?</code>。<br>这个元字符是你可以这个符号之前的一个字符匹配或不匹配，它使它之前的一个字符可选匹配。例如，<code>ab?c</code>可以匹配<code>ac</code>或<code>abc</code>因为b是可选匹配。<br>如果你想匹配问号，则要使用<code>\?</code>来匹配。</p><p>例子:<br>Match   1 file found?<br>Match   2 files found?<br>Match   24 files found?</p><blockquote><p><code>\d+ files? found\?</code></p></blockquote><h1 id="第九课-空格-s-S"><a href="#第九课-空格-s-S" class="headerlink" title="第九课 空格 \s \S"></a>第九课 空格 \s \S</h1><p>在现实文本输入的场景中，很难遇不见空格。在正则表达式中最常见的包含空格的形式是空格(space)、制表符(\t)、换行符(\n)、返回符(\r)，以上所有字符都对应自己的空格形式。<br>另外，<code>\s</code>符匹配以上所有白空格内容。<br><code>\S</code>匹配所用非白空格内容。</p><p>例子：<br>Match   1.   abc<br>Match   2.  abc<br>Match   3.           abc<br>Skip    4.abc</p><blockquote><p><code>\d\.\s+\w+</code></p></blockquote><h1 id="第十课-开始于结束-…"><a href="#第十课-开始于结束-…" class="headerlink" title="第十课 开始于结束 ^….$"></a>第十课 开始于结束 ^….$</h1><p>假设我们想在日志文件中匹配单词”success”，我们当不想匹配到这么一行”Error: unsuccessful operation”。所以大多数情况下，我们的正则表达式要写的越准确越具体越好。</p><p>一个把匹配表达式写的更紧凑的方法是使用元字符<code>^</code>和<code>$</code>来限定句子的开始和终止。在上面的例子中，我们可以用<code>^success</code>来匹配仅仅以”success”开头的行，加上<code>$</code>你可以限定一句的开始和结尾。</p><p>注意<code>^..</code>与<code>[^..]</code>是完全不同的用法。</p><p>例子:<br>Match   Mission: successful<br>Skip    Last Mission: unsuccessful<br>Skip    Next Mission: successful</p><blockquote><p><code>^Mission: successful$</code></p></blockquote><h1 id="第十一课-组匹配"><a href="#第十一课-组匹配" class="headerlink" title="第十一课 组匹配 ()"></a>第十一课 组匹配 ()</h1><p>使用正则表达式我们不仅可以匹配文本，也可以抽取信息以便进一步处理。它可以通过定义字符组并使用元字符<code>(</code>与<code>)</code>。任何的在括号中的子模式将被当作组而被捕获。在实践中，组匹配常用于在各类信息中筛选像电话号码、电子邮件类的信息。</p><p>考虑这种情况，使用命令行列出储存在云盘上的所有图片文件，你可以用这样的匹配模式<code>^(IMG\d+\.png)$</code>捕获所用的图片文件名。如果你仅仅想捕获文件名可以用<code>^(IMG\d+)\.png$</code>这样可以捕获扩展名之前的内容。</p><p>例子：</p><p>Capture file_record_transcript.pdf<br>Capture file_07241999.pdf<br>Skip    testfile_fake.pdf.tmp</p><blockquote><p><code>^(file.+)\.pdf$</code></p></blockquote><h1 id="第十二课-组匹配嵌套"><a href="#第十二课-组匹配嵌套" class="headerlink" title="第十二课 组匹配嵌套 ( .. (..) .. )"></a>第十二课 组匹配嵌套 ( .. (..) .. )</h1><p>当在对复杂的数据操作的时候，要抽取多层次的数据是很常见的，这就会产生组匹配嵌套。一般的，组匹配嵌套捕捉的结果顺序就是它们定义时的顺序。</p><p>以上一课捕捉图片文件名的例子来说，如果每一个图片文件名中都存在一段数字标号，我们可以用这样的匹配模式<code>^(IMG(\d+))\.png$</code>。</p><p>嵌套的组被从左到右读取，顺序即是按左括号出现的顺序。</p><p>例子：</p><p>Capture Jan 1987    Jan 1987 1987<br>Capture May 1969    May 1969 1969<br>Capture Aug 2011    Aug 2011 2011</p><blockquote><p><code>(\w+\s(\d+))</code> </p></blockquote><h1 id="第十三课-更多的组匹配内容-匹配全部"><a href="#第十三课-更多的组匹配内容-匹配全部" class="headerlink" title="第十三课 更多的组匹配内容 (.*)匹配全部"></a>第十三课 更多的组匹配内容 (.*)匹配全部</h1><p>我们之前学过的限定符包括*、+、{}、？等可以作用于组匹配模式上，这是对字符串作用限定符的唯一方法，除此之外，限定符只能作用于单个字符上。</p><p>比如，如果我不确定一个电话号码是否包含区号，正确的匹配区号的模式为<code>(\d{3})?</code>。</p><p>例子：<br>Capture 1280x720    1280 720<br>Capture 1920x1600   1920 1600<br>Capture 1024x768    1024 768</p><blockquote><p><code>(\d+)x(\d+)</code></p></blockquote><h1 id="第十四课-或"><a href="#第十四课-或" class="headerlink" title="第十四课 或 |"></a>第十四课 或 |</h1><p>之前我们说个，写正则表达式时最好要写的准确。<br>当我们有多个确定的可能选项时，使用<code>|</code>或符来连接多个可能性的模式。比如，匹配<code>(milk|break|juice)</code>表示匹配这三个可能性结果中的一个。</p><p>你也可以结合或符与其他元字符、限定符一起使用。比如，<code>([cb]ats*|[dh]ogs?)</code>表示匹配cats或bats或dogs或hogs。如果条件写的太多，会降低模式的可读性，可以考虑写成多个独立的模式。</p><p>例子：</p><p>Match   I love cats<br>Match   I love dogs<br>Skip    I love logs<br>Skip    I love cogs</p><blockquote><p><code>I\slove\s(cats|dogs)</code> 或 <code>I love (cats|dogs)</code></p></blockquote><h1 id="第十五课-其他特殊字符-b"><a href="#第十五课-其他特殊字符-b" class="headerlink" title="第十五课 其他特殊字符 \b"></a>第十五课 其他特殊字符 \b</h1><p>这节课介绍其他的元字符，和组匹配的结果。</p><p>我们之前学过使用<code>\d</code>捕获数字，使用<code>\s</code>捕获空格，使用<code>\w</code>捕获数字字母字符。正则表达式也提供了匹配这些字符集补集的方法，通过使用这些元字符的大写字母，可以表示原本小写字母表示集的补集。</p><p>另外，<code>\b</code>元字符匹配单词的界限，<code>\b</code>的长度为0，所以其不匹配任何字符，只是匹配单词边界。例如，<code>\bcat\b</code>可以匹配cat这个单词，但不会匹配包含cat的单词如catatonic，tomcat。<code>\bcat</code>会匹配以cat开头的单词catfish，<code>cat\b</code>会匹配cat结尾的单词tomcat。</p><p>很多系统允许你通过索引操作组匹配的结果，<code>\0</code>一般表示所有被匹配到的文本，<code>\1</code>第一组匹配结果，<code>\2</code>第二组匹配结果，等等。</p><h1 id="练习一-匹配十进制数字"><a href="#练习一-匹配十进制数字" class="headerlink" title="练习一 匹配十进制数字"></a>练习一 匹配十进制数字</h1><p>看题目为匹配十进制数字，你会认为很简单吧。</p><p>我们用<code>\d</code>匹配任意数字，通过它来匹配十进制数字应该很容易吧？对于简单的数字当然很容易，但如果是匹配用科学计数法写出来的数字，或金融表示的大数字，你需要应对正负号，有效位，指数表示，甚至不同的表示格式(如用，号分割千位，百万位)。</p><p>例子：<br>Match   3.14529<br>Match   -255.34<br>Match   128<br>Match   1.9e10<br>Match   123,340.00<br>Skip    720p</p><blockquote><p><code>^-?\d+(,\d+)*(\.\d+(e\d+)?)?$</code></p></blockquote><h1 id="练习二-匹配电话号码"><a href="#练习二-匹配电话号码" class="headerlink" title="练习二  匹配电话号码"></a>练习二  匹配电话号码</h1><p>手机号码匹配也是一个需要技巧的任务。在不同的州需要加区号，国际长途会有国家前缀号，这些都会增加表达式复杂度。另外，不同人也有不同的书写号码的习惯(有些人会在号码中加入横线或空格分隔号码)。</p><p>例子：<br>Capture 415-555-1234    415<br>Capture 650-555-2345    650<br>Capture (416)555-3456   416<br>Capture 202 555 4567    202<br>Capture 4035555678      403<br>Capture 1 416 555 9292  416</p><blockquote><p><code>1?[\s-]?\(?(\d{3})\)?[\s-]?\d{3}[\s-]?\d{4}</code></p></blockquote><h1 id="练习三-匹配电邮"><a href="#练习三-匹配电邮" class="headerlink" title="练习三 匹配电邮"></a>练习三 匹配电邮</h1><p>在HTML格式中，使用正则表达式获取数据很有用。特别的，电子邮件由于形式构成的复杂性，正则匹配起来会有难度，作者推荐使用内建语言或函数处理，而不是自己写表达式。 当然是用我们所学的内容，你也可以写出一个鲁棒性强的匹配表达式。</p><p>一个要注意的事情是，很多人用加地址来当作用一次的电邮地址。比如，<a href="mailto:`name+filter@gmail.com" target="_blank" rel="noopener">`name+filter@gmail.com</a><code>的邮件会直接发给</code><a href="mailto:name@gmail.com" target="_blank" rel="noopener">name@gmail.com</a>`但可以用附加的信息过滤此邮件。另外，有些域名有多个部分组成，也需要注意。</p><p>Capture <a href="mailto:tom@hogwarts.com" target="_blank" rel="noopener">tom@hogwarts.com</a>    tom<br>Capture <a href="mailto:tom.riddle@hogwarts.com" target="_blank" rel="noopener">tom.riddle@hogwarts.com</a> tom.riddle<br>Capture <a href="mailto:tom.riddle+regexone@hogwarts.com" target="_blank" rel="noopener">tom.riddle+regexone@hogwarts.com</a>    tom.riddle<br>Capture <a href="mailto:tom@hogwarts.eu.com" target="_blank" rel="noopener">tom@hogwarts.eu.com</a> tom<br>Capture <a href="mailto:potter@hogwarts.com" target="_blank" rel="noopener">potter@hogwarts.com</a> potter<br>Capture <a href="mailto:harry@hogwarts.com" target="_blank" rel="noopener">harry@hogwarts.com</a>  harry<br>Capture <a href="mailto:hermione+regexone@hogwarts.com" target="_blank" rel="noopener">hermione+regexone@hogwarts.com</a>  hermione</p><blockquote><p><code>^([\w\.]*)</code></p></blockquote><h1 id="元字符表"><a href="#元字符表" class="headerlink" title="元字符表"></a>元字符表</h1><table><thead><tr><th>Metacharacter</th><th>Description</th></tr></thead><tbody><tr><td>\</td><td></td></tr><tr><td>^</td><td>Matches the position at the beginning of the input string.</td></tr><tr><td>$</td><td>Matches the position at the end of the input string.</td></tr><tr><td>*</td><td>Matches the preceding subexpression zero or more times.</td></tr><tr><td>+</td><td>Matches the preceding subexpression one or more times.</td></tr><tr><td>?</td><td>Matches the preceding subexpression zero or one time.</td></tr><tr><td>{n}</td><td>Matches exactly n times, where n is a non-negative integer.</td></tr><tr><td>{n,}</td><td>Matches at least n times, n is a non-negative integer.</td></tr><tr><td>{n,m}</td><td>Matches at least n and at most m times, where m and n are non-negative integers and n &lt;= m.</td></tr><tr><td>.</td><td>Matches any single character except “n”.</td></tr><tr><td>[xyz]</td><td>A character set. Matches any one of the enclosed characters.</td></tr><tr><td>x</td><td>y</td><td>Matches either x or y.</td></tr><tr><td>[^xyz]</td><td>A negative character set. Matches any character not enclosed.</td></tr><tr><td>[a-z]</td><td>A range of characters. Matches any character in the specified range.</td></tr><tr><td>[^a-z]</td><td>A negative range characters. Matches any character not in the specified range.</td></tr><tr><td>b</td><td>Matches a word boundary, that is, the position between a word and a space.</td></tr><tr><td>B</td><td>Matches a nonword boundary. ‘erB’ matches the ‘er’ in “verb” but not the ‘er’ in “never”.</td></tr><tr><td>d</td><td>Matches a digit character.</td></tr><tr><td>D</td><td>Matches a non-digit character.</td></tr><tr><td>f</td><td>Matches a form-feed character.</td></tr><tr><td>n</td><td>Matches a newline character.</td></tr><tr><td>r</td><td>Matches a carriage return character.</td></tr><tr><td>s</td><td>Matches any whitespace character including space, tab, form-feed, etc.</td></tr><tr><td>S</td><td>Matches any non-whitespace character.</td></tr><tr><td>t</td><td>Matches a tab character.</td></tr><tr><td>v</td><td>Matches a vertical tab character.</td></tr><tr><td>w</td><td>Matches any word character including underscore.</td></tr><tr><td>W</td><td>Matches any non-word character.</td></tr><tr><td>un</td><td>Matches n, where n is a Unicode character expressed as four hexadecimal digits. For example, u00A9 matches the copyright symbol</td></tr></tbody></table>]]></content>
      
      
    </entry>
    
    <entry>
      <title>polymorphism</title>
      <link href="/2016/10/29/polymorphism/"/>
      <url>/2016/10/29/polymorphism/</url>
      <content type="html"><![CDATA[<p><code>29 Oct 2016</code></p><p>面向对象程序设计中的类有三大特性：继承(Inheritance)，封装(Encapsulation)，多态(Polymorphism)</p><h1 id="C-多态"><a href="#C-多态" class="headerlink" title="C++ 多态"></a>C++ 多态</h1><p>多态分为动态多态(dynamic polymorphism)和静态多态(static polymorphism)。<br>静态多态包括： 重载(overload)、模版。动态多态包括：虚函数，抽象类，覆盖(override)。一般所谓的多态是动态多态。<br>C++使用虚函数（虚函数表）来实现动态绑定，当基类对象的指针（或引用）指向派生类的对象时候，实际调用的是派生类相应的函数。</p><a id="more"></a><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><ul><li>表现形式</li></ul><ol><li>派生类的指针可以赋给基类指针 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CBase * p = &amp; ODerived;</span><br><span class="line">p -&gt; SomeVirtualFunction();</span><br></pre></td></tr></table></figure></li></ol><p>2.派生类的对象可以赋给基类引用<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CBase &amp; r = ODerived;</span><br><span class="line">r.SomeVirtualFunction();</span><br></pre></td></tr></table></figure></p><ul><li>虚析构函数</li></ul><p>由于通过new产生的基类的指针删除派生类对象时只调用基类的析构函数。为了保证不出现内存泄漏，需要把基类的析构函数定义成虚析构函数。<br><code>virtual ~Base(){};</code></p><ul><li>纯虚函数和抽象类</li></ul><p>纯虚函数: 没有函数体的虚函数。<br><code>virtual void Print( ) = 0 ; //纯虚函数</code><br>抽象类: 包含纯虚函数的类。其只能作为基类来派生新类使用，不能创建抽象类的对象<br>在抽象类中：</p><ol><li>在成员函数内可以调用纯虚函数</li><li>在 构造函数/析构函数 内部不能调用纯虚函数</li></ol><ul><li>C++中多态的实现原理</li></ul><p>当类中声明虚函数时，编译器会在类中生成一个虚函数表<br>虚函数表是一个存储类成员函数指针的数据结构<br>虚函数表是由编译器自动生成与维护的<br>virtual成员函数会被编译器放入虚函数表中<br>存在虚函数时，每个对象中都有一个指向虚函数表的指针(vptr指针)<br>多态的函数调用语句被编译成一系列根据基类指针所指向的（或基类引用所引用的）对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址，并调用虚函数的指令。。</p><h1 id="OC-多态"><a href="#OC-多态" class="headerlink" title="OC 多态"></a>OC 多态</h1><p>Objective-c 是动态语言，所以它具有动态类型和动态绑定的特性。Objective-c系统总是跟踪对象所属的类。对于类型的判断和方法的确定都是在运行时进行。<br>Objecive-c使用类对象的形式来实现运行多态，每个对象都保存其类对象的地址，类对象中保存了类的基本信息。类对象是进行动态创建（反射），动态识别，消息传递等机制的基础。<br>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Printer.h</span><br><span class="line">@interface Printer : NSObject</span><br><span class="line">- (void)print;  // 简单的方法print</span><br><span class="line">@end;</span><br><span class="line"></span><br><span class="line">Printer.m</span><br><span class="line">#import &quot;Printer.h&quot;</span><br><span class="line">@implementation Printer</span><br><span class="line">- (void)print &#123;</span><br><span class="line">NSLog(@&quot;打印机打印纸张&quot;)；</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>创建一个子类，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ColorPrinter.h</span><br><span class="line">#import &quot;printer.h&quot;</span><br><span class="line">@interface ColorPrinter : Printer</span><br><span class="line">- (void)print;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">ColorPrinter.m</span><br><span class="line">#import &quot;ColorPrinter.h&quot;</span><br><span class="line">@implementation ColorPrinter</span><br><span class="line">- (void)print&#123;</span><br><span class="line">NSLog(@&quot;彩色打印机&quot;)；</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>另一个子类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BlackPrinter.h</span><br><span class="line"> #import &quot;Printer.h&quot;</span><br><span class="line"> @interface BlackPrinter : Printer</span><br><span class="line"> - (void)print;</span><br><span class="line"> @end</span><br><span class="line"> BlackPringer.m</span><br><span class="line"> @implementation  BlackPrinter</span><br><span class="line"> - (void)print&#123;</span><br><span class="line"> NSLog(@&quot;黑白打印机&quot;)；</span><br><span class="line"> &#125;</span><br><span class="line"> @end</span><br></pre></td></tr></table></figure></p><p>定义一个Person类来操作具体的打印机<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Person.h</span><br><span class="line">#import &quot;ColorPrinter.h&quot;</span><br><span class="line">#import &quot;BlackPrinter.h&quot;</span><br><span class="line">// 扩展性不高， 当我们需要添加一个新的打印机的时候， 还要定义对应的方法 </span><br><span class="line">// 所以这时候就可以使用*多态*</span><br><span class="line">@interface Person ： Nsbject &#123;</span><br><span class="line">NSString *_name;</span><br><span class="line">&#125;;</span><br><span class="line"> //  - (void) printWithColor:(ColorPrinter *)colorPrint;</span><br><span class="line"> //  - (void) printWithBlack:(BlackPriter *)blackPrint;</span><br><span class="line"> - (void) doPrint:(Printer *)printer;</span><br><span class="line">@end    </span><br><span class="line"></span><br><span class="line">Person.m</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">@implementation Person</span><br><span class="line">// - (void) printWithColor:(ColorPringter *)colorPrinter&#123;[colorPrint print];&#125;</span><br><span class="line">//  - (void) printWithBlack:(BlackPrinter *)blackPrint&#123;[blackPrint print];&#125;</span><br><span class="line">- (void) doPrint: (Printer *)printer&#123;</span><br><span class="line">[printer print];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>main<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   #import &quot;Person.h&quot;</span><br><span class="line">   #import &quot;BlackPrinter.h&quot;</span><br><span class="line">   #import &quot;ColorPrinter.h&quot;</span><br><span class="line"></span><br><span class="line">   int main(int argc, const char* argv[])&#123;</span><br><span class="line">   @autoreleasepool &#123;</span><br><span class="line">    Person *person = [[Person alloc] init];</span><br><span class="line"></span><br><span class="line">    // 多态定义  注意差别</span><br><span class="line">     ColorPrinter *colorPrint = [[ColorPrinter alloc] init];</span><br><span class="line">     BlackPrinter *blackPrint = [[BlackPrinter alloc] init];</span><br><span class="line">    [person doPrint:colorPrinter];</span><br><span class="line">    [person doPrint:blackPrinter];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对不同对象发送相同消息得到不同行为。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>InputAndOutputFunctionsAndStreamsInDetail</title>
      <link href="/2016/10/19/InputAndOutputFunctionsAndStreamsInDetail/"/>
      <url>/2016/10/19/InputAndOutputFunctionsAndStreamsInDetail/</url>
      <content type="html"><![CDATA[<p><code>19 Oct 2016</code></p><h1 id="包含文件"><a href="#包含文件" class="headerlink" title="包含文件"></a>包含文件</h1><ul><li>对于c++ #include <iostream>： 解决所有标准输入输出头文件</iostream></li><li>对于c++ #include <fstream>: 解决所有文件输入输出头文件</fstream></li><li>对于c #include &lt;stdio.h&gt;: 为c所有输入输出头文件</li></ul><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><ul><li>cin </li></ul><p>输入原理：<br>程序的输入都建有一个缓冲区，即输入缓冲区。一次输入过程是这样的，当一次键盘输入结束时会(键入回车)将输入的数据存入输入缓冲区，而cin函数直接从输入缓冲区中取数据。正因为cin函数是直接从缓冲区取数据的，所以有时候当缓冲区中有残留数据时，cin函数会直接取得这些残留数据而不会请求键盘输入</p><p><code>cin&gt;&gt;</code><br>输入指定类型的数据，对于输入的单个数据对象遇到space、TAB、enter都结束输入</p><p><code>cin.get() / cin.get(char) ／ cin.get(char,int) / cin.get(char*,int,char terminator)</code> 接收一个字符类似getchar()<br>cin.get()返回一个接收的字符，cin.get(char)把接收的字符存入char。cin.get(char,int) 输入一行字符int指示输入字符的数目，大于数目的输入会报错。三个参数的cin.get()类型cin.getline()。<br>函数如果读取成功返回1，如果失败(遇到文件结束符)返回0。</p><p>函数本身可以输入任何字符，连续输入情况下一般可以用输入终止字符EOF或者^Z字符判断结束输入。<br>其与getchar()的区别是getchar()不跳过任何字符，EOF字符也会输入。不能通过返回值来结束连续输入，必选自己判断结束输入。</p><p><code>cin.getline()/ cin.getline(char*,int,char terminator = &#39;\0&#39;)</code><br>和cin.get()行为基本一样，除了get()如果遇到自定义结束符terminator时指针停在其上，下一个输入从结束符开始，而getline()把结束符当作一行结尾，从而跳过结束符从下一个字符开始输入。</p><ul><li>int scanf(const char * restrict format, …)</li></ul><p>scanf（）返回成功接收的参数个数</p><a id="more"></a><p><em>格式字符串</em><br>在Turbo C中格式字符串的一般形式为： [标志][输出最小宽度][.精度][长度]类型。其中方括号[]中的项为可选项。<br>各项的意义介绍如下： </p><p>类型：类型字符用以表示输出数据的类型，其格式符和意义如下表所示：</p><table><thead><tr><th>格式字符</th><th>意            义</th></tr></thead><tbody><tr><td>d</td><td>以十进制形式输出带符号整数(正数不输出符号)</td></tr><tr><td>o</td><td>以八进制形式输出无符号整数(不输出前缀0)</td></tr><tr><td>x,X</td><td>以十六进制形式输出无符号整数(不输出前缀Ox)</td></tr><tr><td>u</td><td>以十进制形式输出无符号整数</td></tr><tr><td>f</td><td>以小数形式输出单、双精度实数</td></tr><tr><td>e,E</td><td>以指数形式输出单、双精度实数</td></tr><tr><td>g,G</td><td>以%f或%e中较短的输出宽度输出单、双精度实数</td></tr><tr><td>c</td><td>输出单个字符</td></tr><tr><td>s</td><td>输出字符串</td></tr></tbody></table><p>标志：标志字符为-、+、#、空格四种，其意义下表所示：</p><table><thead><tr><th>标 志</th><th>意        义</th></tr></thead><tbody><tr><td>-</td><td>结果左对齐，右边填空格</td></tr><tr><td>+</td><td>输出符号(正号或负号)</td></tr><tr><td>空格</td><td>输出值为正时冠以空格，为负时冠以负号</td></tr><tr><td>#</td><td>对c,s,d,u类无影响；对o类,在输出时加前缀o；对x类,在输出时加前缀0x；对e,g,f 类当结果有小数时才给出小数点</td></tr></tbody></table><p>输入格式字符串的一般形式为：%[*][输入数据宽度][类型长度]类型 </p><p>“*”符:用以表示该输入项,读入后不赋予相应的变量，即跳过该输入值。<br>如：</p><blockquote><p><code>scanf(&quot;%d %*d %d&quot;,&amp;a,&amp;b);</code>。</p></blockquote><p>当输入为：1   2   3时，把1赋予a，2被跳过，3赋予b。</p><p>宽度:用十进制整数指定输入的宽度(即字符数)。<br>例如： </p><blockquote><p> <code>scanf(&quot;%5d&quot;,&amp;a);</code> </p></blockquote><p>输入12345678只把12345赋予变量a，其余部分被截去。 </p><p>又如： </p><blockquote><p><code>scanf(&quot;%4d%4d&quot;,&amp;a,&amp;b);</code></p></blockquote><p>输入12345678将把1234赋予a，而把5678赋予b。</p><p>长度:长度格式符为l和h，l表示输入长整型数据(如%ld) 和双精度浮点数(如%lf)。h表示输入短整型数据。<br>使用scanf函数还必须注意以下几点： </p><p>scanf函数中没有精度控制，如：<code>scanf(&quot;%5.2f&quot;,&amp;a)</code>;是非法的。不能企图用此语句输入小数为2位的实数。</p><p>scanf中要求给出变量地址，如给出变量名则会出错。如<code>scanf(&quot;%d&quot;,a);</code>是非法的，应改为<code>scnaf(&quot;%d&quot;,&amp;a);</code>才是合法的。</p><p>在输入多个数值数据时，若格式控制串中没有非格式字符作输入数据之间的间隔则可用空格，TAB或回车作间隔。C编译在碰到空格，TAB，回车或非法数据(如对“%d”输入“12A”时，A即为非法数据)时即认为该数据结束。<br>在输入字符数据时，若格式控制串中无非格式字符，则认为所有输入的字符均为有效字符。<br>例如： </p><blockquote><p>  <code>scanf(&quot;%c%c%c&quot;,&amp;a,&amp;b,&amp;c);</code> </p></blockquote><p>输入 d   e   f 则把’d’赋予a, ‘ ‘ 赋予b,’e’赋予c。只有当输入为 def 时，才能把’d’赋于a,’e’赋予b,’f’赋予c。 </p><p>如果在格式控制中加入空格作为间隔，如: </p><blockquote><p><code>scanf (&quot;%c %c %c&quot;,&amp;a,&amp;b,&amp;c);</code> </p></blockquote><p>则输入时各数据之间可加空格。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><ul><li>cout</li></ul><p><code>cout&lt;&lt;</code> 控制</p><blockquote><p>需要加入头文件  <code>#include &lt;iomanip\&gt;</code></p></blockquote><p>除了可以用控制符来控制输出格式外，还可以通过调用流对象cout中用于控制输出格式的成员函数来控制输出格式。<br>用于控输出格式的流成员函数:</p><table><thead><tr><th>流成员函数</th><th>与之作用相同的控制符</th><th>作用</th></tr></thead><tbody><tr><td>precision(n)</td><td>setprecision(n)</td><td>设置实数的精度为n位</td></tr><tr><td>width(n)</td><td>setw(n)</td><td>设置字段宽度为n位</td></tr><tr><td>fill(c)</td><td>setfill(c)</td><td>设置填充宇符c</td></tr><tr><td>setf()</td><td>setiosflags()</td><td>设置输出格式状态，括号中应给出格式状态，内容与控制符setiosflags括号中的内容相同，如表13.5所示</td></tr><tr><td>unsetf()</td><td>resetioflags()</td><td>终止已设置的输出格式状态，在括号中应指定内容</td></tr></tbody></table><p>流成员函数setf和控制符setiosflags括号中的参数表示格式状态，它是通过格式标志来指定的。格式标志在类ios中被定义为枚举值。因此在引用这些格式标志时要在前面加上类名ios和域运算符“::”。格式标志见表:</p><table><thead><tr><th>格式标志</th><th>作用</th></tr></thead><tbody><tr><td>ios::left</td><td>输出数据在本域宽范围内向左对齐</td></tr><tr><td>ios::right</td><td>输出数据在本域宽范围内向右对齐</td></tr><tr><td>ios::internal</td><td>数值的符号位在域宽内左对齐，数值右对齐，中间由填充字符填充</td></tr><tr><td>ios::dec</td><td>设置整数的基数为10</td></tr><tr><td>ios::oct</td><td>设置整数的基数为8</td></tr><tr><td>ios::hex</td><td>设置整数的基数为16</td></tr><tr><td>ios::showbase</td><td>强制输出整数的基数(八进制数以0打头，十六进制数以0x打头)</td></tr><tr><td>ios::showpoint</td><td>强制输出浮点数的小点和尾数0</td></tr><tr><td>ios::uppercase</td><td>在以科学记数法格式E和以十六进制输出字母时以大写表示</td></tr><tr><td>ios::showpos</td><td>对正数显示“+”号</td></tr><tr><td>ios::scientific</td><td>浮点数以科学记数法格式输出</td></tr><tr><td>ios::fixed</td><td>浮点数以定点格式(小数形式)输出</td></tr><tr><td>ios::unitbuf</td><td>每次输出之后刷新所有的流</td></tr><tr><td>ios::stdio</td><td>每次输出之后清除stdout, stderr</td></tr></tbody></table><p>ps: 函数width(n)和控制符setw(n)只对其后的第一个输出项有效</p><ul><li>int printf(const char * restrict format, …)</li></ul><p>printf（）返回成功打印的字符数。</p><p>printf 使用 format 字符串控制输出.字符串里的纯字符都会如实打印.echo 的转义序列会被解释.包括%与一个字母的格式指示符.用来指示相对应的参数字符串的格式化.</p><table><thead><tr><th>转义字符</th><th>意义</th><th>ASCII码值（十进制）</th></tr></thead><tbody><tr><td>\a</td><td>响铃(BEL)</td><td>007</td></tr><tr><td>\b</td><td>退格(BS) 将当前位置移到前一列</td><td>008</td></tr><tr><td>\f</td><td>换页(FF)，将当前位置移到下页开头</td><td>012</td></tr><tr><td>\n</td><td>换行(LF) ，将当前位置移到下一行开头</td><td>010</td></tr><tr><td>\r</td><td>回车(CR) ，将当前位置移到本行开头</td><td>013</td></tr><tr><td>\t</td><td>水平制表(HT) （跳到下一个TAB位置）</td><td>009</td></tr><tr><td>\v</td><td>垂直制表(VT)</td><td>011</td></tr><tr><td>\</td><td>代表一个反斜线字符’’\’</td><td>092  ​   ​</td></tr><tr><td>\’</td><td>代表一个单引号（撇号）字符</td><td>039</td></tr><tr><td>\”</td><td>代表一个双引号字符</td><td>034</td></tr><tr><td>\0</td><td>空字符(NULL)</td><td>000</td></tr><tr><td>\ddd</td><td>1到3位八进制数所代表的任意字符</td><td>三位八进制</td></tr><tr><td>\xhh</td><td>1到2位十六进制所代表的任意字符</td><td>二位十六进制</td></tr></tbody></table><p>printf格式化输出格式与scanf格式化输入的格式相同，可以用精度表示输出小数点后位数。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>SomeTricksAndFunctions</title>
      <link href="/2016/10/17/BigNumberCalculatorInCpp/"/>
      <url>/2016/10/17/BigNumberCalculatorInCpp/</url>
      <content type="html"><![CDATA[<p><code>17 Oct 2016</code></p><p>Here are some Tricks and Functions that i find useful.<br>Content:</p><h1 id="new"><a href="#new" class="headerlink" title="new"></a>new</h1><p>new 返回分配的地址，所以用指针赋值。<br><code>int *p = new int；</code></p><h2 id="动态分配二维数组"><a href="#动态分配二维数组" class="headerlink" title="动态分配二维数组"></a>动态分配二维数组</h2><p>手动两次分配空间，生成二维数组<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态开辟空间  </span></span><br><span class="line"> <span class="keyword">int</span> **p = <span class="keyword">new</span> <span class="keyword">int</span>*[m]; <span class="comment">//开辟行  </span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)  </span><br><span class="line">      p[i] = <span class="keyword">new</span> <span class="keyword">int</span>[n]; <span class="comment">//开辟列</span></span><br></pre></td></tr></table></figure></p><h2 id="动态分配三维数组，在类里定义下标访问"><a href="#动态分配三维数组，在类里定义下标访问" class="headerlink" title="动态分配三维数组，在类里定义下标访问"></a>动态分配三维数组，在类里定义下标访问</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">CArray3D</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T *** arr ;</span><br><span class="line">        CArray3D(<span class="keyword">int</span> d1,<span class="keyword">int</span> d2,<span class="keyword">int</span> d3)&#123;</span><br><span class="line">             arr = <span class="keyword">new</span> T**[d1];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; d1;i++)&#123;</span><br><span class="line">                 arr[i] = <span class="keyword">new</span> T*[d2];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;d2;j++)&#123;</span><br><span class="line">                    arr[i][j] = <span class="keyword">new</span> T[d3];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    T ** <span class="keyword">operator</span>[](<span class="keyword">int</span> i)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="is-number-返回是否string内全是数字"><a href="#is-number-返回是否string内全是数字" class="headerlink" title="is_number: 返回是否string内全是数字"></a>is_number: 返回是否string内全是数字</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_number</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s)</span></span>&#123;<span class="keyword">return</span> !s.empty() &amp;&amp; <span class="built_in">std</span>::find_if(s.begin(), s.end(), [](<span class="keyword">char</span> c) &#123; <span class="keyword">return</span> !<span class="built_in">std</span>::<span class="built_in">isdigit</span>(c); &#125;) == s.end();&#125;</span><br></pre></td></tr></table></figure><h1 id="getPrimeNum-求一个整数质因数的数量"><a href="#getPrimeNum-求一个整数质因数的数量" class="headerlink" title="getPrimeNum: 求一个整数质因数的数量"></a>getPrimeNum: 求一个整数质因数的数量</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getPrimeNum</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span> n = t;</span><br><span class="line">  <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; counter;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d="</span>,n);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">while</span>(n!=i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d*"</span>,i);</span><br><span class="line">        counter.insert(i);</span><br><span class="line">        n=n/i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span>(n != t)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n);</span><br><span class="line">  counter.insert(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> res = counter.size();</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Combination-一个简单的组合书实现"><a href="#Combination-一个简单的组合书实现" class="headerlink" title="Combination: 一个简单的组合书实现"></a>Combination: 一个简单的组合书实现</h1><p>返回数值必须不大于长整型大小<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span>  <span class="title">Combination</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n; i&gt;=(n-m+<span class="number">1</span>); --i)</span><br><span class="line">        ans *= i;</span><br><span class="line">    <span class="keyword">while</span>(m)</span><br><span class="line">        ans /= m--;</span><br><span class="line">    <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="出栈序列统计：Catalan-number-应用"><a href="#出栈序列统计：Catalan-number-应用" class="headerlink" title="出栈序列统计：Catalan number 应用"></a>出栈序列统计：Catalan number 应用</h1><p>栈是常用的一种数据结构，有n个元素在栈顶端一侧等待进栈，栈顶端另一侧是出栈序列。你已经知道栈的操作有两种：push和pop，前者是将一个元素进栈，后者是将栈顶元素弹出。现在要使用这两种操作，由一个操作序列可以得到一系列的输出序列。请你编程求出对于给定的n，计算并输出由操作数序列1，2，…，n，经过一系列操作可能得到的输出序列总数。</p><p>解：答案为Catalan number<br><code>h(n) = C(2n,n)/(n+1)</code></p><h2 id="Catalan-number"><a href="#Catalan-number" class="headerlink" title="Catalan number"></a>Catalan number</h2><p>令h(1)=1, h(0)=1，catalan数满足递归式：h(n)=h(n-1)*2(2n-1)/(n+1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">h(n)=h(0)*h(n-1)+h(1)*h(n-2)+...+h(n-1)h(0) (n&gt;=2)</span><br><span class="line"></span><br><span class="line">　　=C(2n, n)/(n+1)</span><br><span class="line"></span><br><span class="line">　　=h(n-1)*2(2n-1)/(n+1)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>c++Constructor</title>
      <link href="/2016/10/15/c-Constructor/"/>
      <url>/2016/10/15/c-Constructor/</url>
      <content type="html"><![CDATA[<p><code>le 15 Oct</code></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>下面的写法定义了一个引用，并将其初始化为引用某个变量。<br>类型名 &amp; 引用名 = 某变量名;<br><code>int &amp; r = n;</code></p><ul><li>定义引用时一定要将其初始化成引用某个变量。引用只能引用变量，不能引用常量和表达式。<br>例子：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">( <span class="keyword">int</span> &amp; a, <span class="keyword">int</span> &amp; b)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> tmp;</span><br><span class="line">     tmp = a; a = b; b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n1, n2;</span><br><span class="line">swap(n1,n2) ; <span class="comment">// n1,n2的值被交换</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="一般构造函数"><a href="#一般构造函数" class="headerlink" title="一般构造函数"></a>一般构造函数</h3><ul><li>如果创建一个类你没有写任何构造函数,则系统会自动生成默认的无参构造函数，函数为空，什么都不做</li><li>只要你写了一个下面的某一种构造函数，系统就不会再自动生成这样一个默认的构造函数，如果希望有一个这样的无参构造函数，则需要自己显示地写出来</li><li>一般构造函数可以有各种参数形式,一个类可以有多个一般构造函数，前提是参数的个数或者类型不同（基于c++的重载函数原理）<br>例如：你还可以写一个 Complex( int num)的构造函数出来<br>创建对象时根据传入的参数不同调用不同的构造函数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Complex(<span class="keyword">double</span> real, <span class="keyword">double</span> imag)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">     m_real = real;</span><br><span class="line"></span><br><span class="line">     m_imag = imag;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="拷贝构造函数-复制构造函数"><a href="#拷贝构造函数-复制构造函数" class="headerlink" title="拷贝构造函数(复制构造函数()"></a>拷贝构造函数(复制构造函数()</h3><ul><li>复制构造函数参数为类对象本身的引用，用于根据一个已存在的对象复制出一个新的该类的对象，一般在函数中会将已存在对象的数据成员的值复制一份到新创建的对象中</li><li>若没有显示的写复制构造函数，则系统会默认创建一个复制构造函数，但当类中有指针成员时，由系统默认创建该复制构造函数会存在风险，具体原因请查询有关 “浅拷贝” 、“深拷贝”的文章论述<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Complex(<span class="keyword">const</span> Complex &amp; c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将对象c中的数据成员值复制过来</span></span><br><span class="line">    m_real = c.m_real;</span><br><span class="line">    m_img  = c.m_img;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="类型转换构造函数"><a href="#类型转换构造函数" class="headerlink" title="类型转换构造函数"></a>类型转换构造函数</h3><ul><li>根据一个指定的类型的对象创建一个本类的对象<br>例如：下面将根据一个double类型的对象创建了一个Complex对象<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Complex::Complex(<span class="keyword">double</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    m_real = r;</span><br><span class="line">    m_imag = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="派生类的构造函数"><a href="#派生类的构造函数" class="headerlink" title="派生类的构造函数"></a>派生类的构造函数</h3><ul><li>派生类拥有基类的全部成员函数和成员变<br>量，不论是private、protected、public。在派生类的各个成员函数中，不能访问<br>基类中的private成员。</li><li><p>派生类对象的体积，等于基类对象的体积，再加上派<br>生类对象自己的成员变量的体积。在派生类对象中，包<br>含着基类对象，而且基类对象的存储位置位于派生类对<br>象新增的成员变量之前。</p></li><li><p>执行基类构造函数前先执行派生类构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Skill</span> &#123;</span> <span class="keyword">public</span>:</span><br><span class="line">Skill(<span class="keyword">int</span> n) &#123; &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyBug</span>:</span> <span class="keyword">public</span> Bug &#123; <span class="keyword">int</span> nWings;</span><br><span class="line">Skill sk1, sk2; <span class="keyword">public</span>:</span><br><span class="line">FlyBug(<span class="keyword">int</span> legs, <span class="keyword">int</span> color, <span class="keyword">int</span> wings); &#125;;</span><br><span class="line"></span><br><span class="line">FlyBug::FlyBug( <span class="keyword">int</span> legs, <span class="keyword">int</span> color, <span class="keyword">int</span> wings): Bug(legs, color), sk1(<span class="number">5</span>), sk2(color) &#123;</span><br><span class="line">nWings = wings; </span><br><span class="line">Bug::function();<span class="comment">//派生类内部调用其基类函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>派生类调用基类成员</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FlyBug a; </span><br><span class="line">a.function();<span class="comment">// 本类函数</span></span><br><span class="line">a.Bug::function();<span class="comment">//基类函数</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><p>匿名对象可以理解为是一个临时对象，一般系统自动生成的，如你的函数返回一个对象，这个对象在返回时会生成一个临时对象。</p><p>总结：如果生成的匿名对象在外部有对象等待被其实例化，此匿名对象的生命周期就变成了外部对象的生命周期；<br>如果生成的匿名对象在外面没有对象等待被其实例化，此匿名对象将会生成之后，立马被析构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cat()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Cat类 无参构造函数"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Cat(Const Cat&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Cat类 拷贝构造函数"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Cat()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Cat类 析构函数 "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">playStage</span><span class="params">()</span> <span class="comment">//一个舞台，展示对象的生命周期</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cat();             <span class="comment">/*在执行此代码时，利用无参构造函数生成了一个匿名Cat类对象；执行完此行代码，</span></span><br><span class="line"><span class="comment">                            因为外部没有接此匿名对象的变量，此匿名又被析构了*/</span></span><br><span class="line">    Cat cc = Cat();    <span class="comment">/*在执行此代码时，利用无参构造函数生成了一个匿名Cat类对象；然后将此匿名变</span></span><br><span class="line"><span class="comment">                            成了cc这个实例对象，此匿名对象没有被析构。*/</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"cc 对象好没有被析构"</span>&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    playStage();</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Cat类 无参构造函数</span><br><span class="line">Cat类 析构函数</span><br><span class="line">Cat类 无参构造函数</span><br><span class="line">cc 对象好没有被析构</span><br><span class="line">Cat类 析构函数</span><br></pre></td></tr></table></figure></p><p>说明：<br>1、在执行playStage( )函数中的Cat( )时，生成了一个匿名对象，执行完Cat( )代码后，此匿名对象就此<br>消失。这就是匿名对象的生命周期。<br>2、在执行playStage( )函数中Cat cc = Cat();时，首先生成了一个匿名对象，因为外部有cc对象在等待被<br>实例化，然后将此匿名对象变为了cc对象，其生命周期就变成了cc对象的生命周期。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>c++ Operator Overload</title>
      <link href="/2016/10/14/c-Operator-Override/"/>
      <url>/2016/10/14/c-Operator-Override/</url>
      <content type="html"><![CDATA[<p><code>le 14 Oct</code></p><h3 id="双目运算符-，-等的重载"><a href="#双目运算符-，-等的重载" class="headerlink" title="双目运算符+ ，- 等的重载"></a>双目运算符+ ，- 等的重载</h3><ul><li>可定义为成员函数或普通函数或友元函数<br>但成员函数可以c+5 不能5+c这样操作<br>普通函数不能操作私有成员<br>所以推荐定义成友元函数</li></ul><p>实现复数加法 例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Complex <span class="keyword">operator</span>+( <span class="keyword">const</span> Complex &amp;a , <span class="keyword">const</span> Complex &amp;b )&#123; <span class="comment">//a 和 b 是对+号两边操作数的常引用</span></span><br><span class="line">     <span class="keyword">return</span> Complex(a.real +b.real , a.imaginary + b.imaginary );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>重载为类的成员函数时参赛个数为一</li></ul><h3 id="赋值运算符-重载"><a href="#赋值运算符-重载" class="headerlink" title="赋值运算符 = 重载"></a>赋值运算符 = 重载</h3><ul><li>只能定义为类成员函数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Sting&amp; String::<span class="keyword">operator</span>=(<span class="keyword">const</span> String &amp;s)&#123; ／/注意返回值要与参赛类型一样，以便在连等于时也可以使用</span><br><span class="line">     <span class="keyword">if</span>(str == s.str) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">     <span class="keyword">if</span>(str) <span class="keyword">delete</span>[] str;</span><br><span class="line">     <span class="keyword">if</span>(s.str)&#123;</span><br><span class="line">          str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(s.str) + <span class="number">1</span>];</span><br><span class="line">          <span class="built_in">strcpy</span>(str , s.str);</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          str = <span class="literal">NULL</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>ps: void operator=(const Complex &amp;)<br>如果返回值是void的话，如果出现连续赋值操作比如<code>c=b=a</code>,则得到<code>c=void</code>.<br>只有返回赋值</p><a id="more"></a><h3 id="重载-运算符"><a href="#重载-运算符" class="headerlink" title="重载[] 运算符"></a>重载[] 运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; CArray::<span class="keyword">operator</span>[ ]( <span class="keyword">int</span> i)&#123;<span class="comment">// CArray是自定义数组， ptr是指向数组内存的int* 指针， 返回int&amp; 所以可以更改数组内容。</span></span><br><span class="line">     <span class="keyword">return</span> ptr[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="流插入运算符-lt-lt-gt-gt-的重载"><a href="#流插入运算符-lt-lt-gt-gt-的重载" class="headerlink" title="流插入运算符&lt;&lt; , &gt;&gt; 的重载"></a>流插入运算符&lt;&lt; , &gt;&gt; 的重载</h3><p>cin和cout是在<iostream>中定义的，istream和ostream类的对象。<br>重载例子:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;( ostream &amp; o,<span class="keyword">const</span> CStudent &amp; s)&#123;</span><br><span class="line">     o &lt;&lt; s.nAge ;</span><br><span class="line">     <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></iostream></p><h3 id="自增-自减运算符重载"><a href="#自增-自减运算符重载" class="headerlink" title="自增/自减运算符重载"></a>自增/自减运算符重载</h3><ul><li><p>前置运算符作为一元运算符可重载为：<br><code>T &amp; operator++();</code>成员函数<br>或<br><code>T &amp; operator++(T &amp;);</code>普通函数<br>++obj, obj.operator++(), operator++(obj) 都调用上述函数</p></li><li><p>后置运算符作为二元运算符重载<br><code>T operator++(int);</code>或<br><code>T operator++(T &amp;, int);</code><br>obj++, obj.operator++(0), operator++(obj,0) 都调用上函数</p></li></ul><p>例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CDemo &amp; CDemo::<span class="keyword">operator</span>++() &#123; <span class="comment">//前置 ++</span></span><br><span class="line">     n++;</span><br><span class="line">     <span class="keyword">return</span> * <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CDemo CDemo::<span class="keyword">operator</span>++(<span class="keyword">int</span> k) &#123; <span class="comment">//后置 ++</span></span><br><span class="line">     <span class="function">CDemo <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>; <span class="comment">//记录修改前的对象</span></span><br><span class="line">     n++;</span><br><span class="line">     <span class="keyword">return</span> tmp; <span class="comment">//返回修改前的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="类型强制转换运算符"><a href="#类型强制转换运算符" class="headerlink" title="类型强制转换运算符"></a>类型强制转换运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">int</span> <span class="params">( )</span> </span>&#123; <span class="keyword">return</span> n; &#125;<span class="comment">//重载(int)id</span></span><br></pre></td></tr></table></figure><p>重载了<code>(int) s ;</code> 相当于调用<code>s.int();</code></p><ul><li>不写返回值类型，因为返回值类型就是转换类型</li></ul><h3 id="运算符重载的注意事项"><a href="#运算符重载的注意事项" class="headerlink" title="运算符重载的注意事项"></a>运算符重载的注意事项</h3><ul><li>C++不允许定义新的运算符</li><li>重载后运算符的含义应该符合日常习惯</li><li>运算符重载不改变运算符的优先级</li><li>以下运算符不能被重载: “.”, “.*”, “::”, “?:”, sizeof</li><li>重载运算符(), [ ], -&gt;或者赋值运算符=时, 重载函数必须声明 为类的成员函数</li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>SublimeText+Latex-ConfigurationOnMac</title>
      <link href="/2016/10/10/SublimeText-Latex-ConfigurationOnMac/"/>
      <url>/2016/10/10/SublimeText-Latex-ConfigurationOnMac/</url>
      <content type="html"><![CDATA[<h3 id="前言-Preface"><a href="#前言-Preface" class="headerlink" title="前言(Preface)"></a>前言(Preface)</h3><p>某日，突发奇想欲用Latex模版制作简历，由于开始研究配置，经过一番折腾终于弄好，然其过程不畅快使人折磨。故写此博文，以便诸君。<br>本文适用场景：基于 <strong>BasicTex(2016)</strong> 在 <strong>SublimeText3</strong> 中用 <strong>LatexTool</strong> 编译，于 <strong>skim</strong> 中显示的latexPDF。<br>写于2016年10月</p><h5 id="1-安装BasicTex"><a href="#1-安装BasicTex" class="headerlink" title="1.安装BasicTex"></a>1.安装BasicTex</h5><p>不需要安装完整版程序只要Basic功能就行。<a href="http://mirror.ctan.org/systems/mac/mactex/mactex-basic.pkg" target="_blank" rel="noopener">BasicTex</a><br>如果安装没问题请看下一单元，如果网页打不开，或者下载包pkg打不开请用homebrew安装</p><ul><li><p>homebrew安装<br>1.在终端输入<br><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; &lt; /dev/null 2&gt; /dev/null ; brew install caskroom/cask/brew-cask 2&gt; /dev/null</code><br>2.输入<br><code>brew cask install basictex</code><br>如果homebrew安装出现写入权限的问题(permisson denied),参考<a href="http://stackoverflow.com/questions/16432071/how-to-fix-homebrew-permissions" target="_blank" rel="noopener">此处</a>第一个答案。</p></li><li><p>安装latexmk<br>终端输入：<br><code>sudo tlmgr update --self</code><br><code>sudo tlmgr install latexmk</code></p></li></ul><p>PS：如果终端不识别tlmgr命令说明要给系统增加环境变量。方法如下：<br>默认情况下tlmgr在目录<code>/usr/local/texlive/2016basic/bin/universal-darwin</code>中，如果不是默认情况请在<code>/</code>目录下找具体安装目录<br>在终端下输入：<br><code>cd</code><br><code>vim .bash_profile</code><br>进入文件，在文件底部添加：<br><code># Add TeXlive</code><br><code>export PATH=/usr/local/texlive/2016basic/bin/universal-darwin:$PATH</code><br>输入<code>:wq</code>回到终端之后输入：<br><code>source .bash_profile</code><br>回车<br>然后再运行安装latexmk的两条命令就可以了。</p><h5 id="2-配置SublimeText"><a href="#2-配置SublimeText" class="headerlink" title="2.配置SublimeText"></a>2.配置SublimeText</h5><p>在ST里打开LaTeXTools.sublime-usersettings。在<code>builder-settings</code>中添加两项：<br><code>&quot;program&quot; : &quot;xelatex&quot;,</code><br><code>&quot;command&quot; : [&quot;latexmk&quot;, &quot;-cd&quot;, &quot;-e&quot;, &quot;$pdflatex = &#39;xelatex -interaction=nonstopmode -synctex=1 %S %O&#39;&quot;, &quot;-f&quot;, &quot;-pdf&quot;],</code><br>LaTeXTools默认调用Skim来打开生成的PDF文件，如果你更喜欢使用OS X自带的“预览”，现在可以直接在用户设置中添加：<br><code>&quot;viewer&quot;: &quot;preview&quot;,</code><br>编译之后就是用preview显示了。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>A vim Tutorial and Primer(中译)</title>
      <link href="/2016/09/27/A-vim-Tutorial-and-Primer-%E4%B8%AD%E8%AF%91/"/>
      <url>/2016/09/27/A-vim-Tutorial-and-Primer-%E4%B8%AD%E8%AF%91/</url>
      <content type="html"><![CDATA[<h1 id="VIM启蒙教程"><a href="#VIM启蒙教程" class="headerlink" title="VIM启蒙教程"></a>VIM启蒙教程</h1><p><a href="https://danielmiessler.com/study/vim/" target="_blank" rel="noopener">A vim Tutorial and Primer (原文链接)</a><br><a href="https://github.com/yangyangwithgnu/use_vim_as_ide" target="_blank" rel="noopener">Vim as IDE / Vim作为IDE (Vim配置教程)</a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文是”A vim Tutorial and Primer”中文翻译。鄙人在偶尔浏览到这篇博客，正值vim学习中，顾欲翻译之，以提高姿势水平。 在下才疏学浅，文笔欠佳，请多多见谅，如对内容有疑问请看原文。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>[TOC]</p><ul><li>介绍<ul><li>为什么用Vim？</li><li>方法</li><li>配置<ul><li>重映射大写锁键</li><li>用Pathogen来插件管理</li><li>用GitHub的备份和移动能力</li></ul></li><li>把Vim当做一种语言</li></ul></li><li>成为实践派<ul><li>操作文件</li><li>搜索文本</li><li>文本内移动</li><li>修改文本</li><li>删除文本</li><li>撤销操作和恢复操作</li><li>重复之前的动作</li><li>拷贝和粘贴</li><li>检查拼写错误</li><li>替换文本</li></ul></li><li>进阶<ul><li>可重复过程</li><li>文本对象</li><li>虚拟模式</li><li>使用宏</li></ul></li><li>小技巧<ul><li>移除行尾的空格</li><li>改变文件类型</li><li>包裹内容</li><li>分屏操作</li><li>多标签页面</li></ul></li><li>结论</li><li>参考文献</li></ul><hr><p>本教程的目标是教会你Vim每一个层次的内容– 从明白Vim的逻辑，到把你的能力提升到那些少数人的阶段。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="为什么用Vim？"><a href="#为什么用Vim？" class="headerlink" title="为什么用Vim？"></a>为什么用Vim？</h2><p>我认为有以下3点原因使人们想用<code>vim</code>:</p><ol><li>它无所不在。在任何地方任何机器上你都能找到它。</li><li>它强大的扩展性。既可以当做文本编辑器，又可以作为编程写作的完整平台。</li><li>它功能强大。由于用起来像一门语音，vim可以很快使你从一个入门的使用者到受人膜拜的大神。<br>简而言之，你可以把vim当成你上课学的一门外语，或者基本数学。但一切的一切都要从认识你的编辑器开始。<a id="more"></a></li></ol><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><a href="http://whileimautomaton.net/2008/11/vimm3/operator" target="_blank" rel="noopener">Kana the Wizard</a>说掌握Vim要经历5个阶段：</p><ul><li>Level0 ：不识Vim</li><li>Level1 ：知道基本Vim用法</li><li>Level2 ：知道虚拟模式用法</li><li>Level3 ：了解了各种姿势水平</li><li>Level4 ：不需要用虚拟模式</li></ul><p>我不知道是否正确，但我认为值得提一下这些概念。毕竟Kana是个大神。我主要介绍<code>vim</code>的四个主要内容：</p><ol><li>基本入门：让你思维走向正轨的基本热身。</li><li>变成实践派：这是熟肉。准备好吧，这些内容够你受得了。</li><li>进阶：在这里你将会成为会用<code>vim</code>的少数人。</li><li>常见问题：这里有一些很好用的小技巧。</li></ol><p>如果你已经入门了那直接看变成实践派的内容吧，如果你很熟悉Vim了那去进阶里学真功夫吧，如果你只是像找某个特定问题的解决办法去看看常见问题吧。<br>简而言之，安装、基本用法、’忍术‘、和常见的问题。从这些内容中找你需要的学吧。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>由于这是启蒙类教程所以不涉及太深入的配置内容。<br>笔者推荐读者自己安装和维护vim。vim安装在<code>~/.vim</code>目录下配置保存在<code>~/.vimc</code>文件下。</p><ul><li>一些重要配置更改<br>首先，<code>&lt;Eec&gt;</code>退出键用于退出插入模式，进入命令模式，以笔者观点来看是有点过时了。Vim即是效率，如果手能不离开键盘就尽量不离开键盘。笔者这里推荐用jk键组合代替退出：</li></ul><blockquote><p><code>inoremap jk &lt;Esc&gt;</code></p></blockquote><ul><li>冲设置领导键<br>领导键是用来激活缩写的键，其功能十分强大。例如如果你要用c键映射一个缩写那么你先键入你要缩写的键，之后键入领导键和c键。<br>默认的领导键为（<code>\</code>）这里笔者认为改为空格键<code>Space</code>更为合适。</li></ul><blockquote><p><code>let mapleader = &quot;\&lt;Space&gt;&quot;</code></p></blockquote><p>用空格更好理解也方便操作，因为你的拇指总是在空格键上。</p><h3 id="重映射大写锁键"><a href="#重映射大写锁键" class="headerlink" title="重映射大写锁键"></a>重映射大写锁键<capslock></capslock></h3><p>笔者认为键盘上的大写锁键capslock毫无意义所以重映射到<code>Ctrl</code>键</p><blockquote><p>filetype plugin indent on<br>syntax  on<br>set encoding = utf-8</p></blockquote><h3 id="用Pathogen来插件管理"><a href="#用Pathogen来插件管理" class="headerlink" title="用Pathogen来插件管理"></a>用Pathogen来插件管理</h3><p>你所需要做的是：</p><ol><li>安装Pathogen。</li><li><code>git clone</code> 需要的插件到<code>~/.vim/bundle</code></li><li>添加<code>execute pathogen#infect()</code>到<code>~/.vimc</code></li></ol><h3 id="用GitHub的备份和移动能力"><a href="#用GitHub的备份和移动能力" class="headerlink" title="用GitHub的备份和移动能力"></a>用GitHub的备份和移动能力</h3><p>笔者会把我配置好的Vim的整个文件夹<code>~/.vim</code>放在一个git仓库内，这样每当我换了终端时只要<code>git clone https://github.com/danielmiessler/vim</code> 就可以立刻得到我想要的整个Vim环境。</p><h2 id="把Vim当做一种语言"><a href="#把Vim当做一种语言" class="headerlink" title="把Vim当做一种语言"></a>把Vim当做一种语言</h2><p>可以说Vim最机智的一点是你用多了以后就开始以Vim的方式思考了。Vim是被像语言一样设计的，有名词、动词和副词。</p><ul><li><p>动词<br>动词是我们做的动作，动词可以作用于名词。例如：<br><code>d</code>: delete 删除<br><code>c</code>: change 修改<br><code>y</code>: yank 拷贝<br><code>v</code>: visually select 可见选择</p></li><li><p>修饰符<br>修饰符置于名词之前来描述你的动作的方式。例如：<br><code>i</code>: inside 内部的<br><code>a</code>: around 周围的<br><code>NUM</code>: number 数字的<br><code>t</code>: 找一些内容，停在它之前<br><code>f</code>: 找一些内容，停在它上<br><code>/</code>: 找到一个字符串(字符的或正则的)</p></li><li><p>名词<br>英语中名词是动作的对象。名词是对象，在vim中也一样。一些例子：<br><code>w</code>: word 词<br><code>s</code>: sentence 句子<br><code>)</code>: sentence 另一种句子写法<br><code>p</code>: paragraph 段落<br><code>}</code>: 段落另一种写法<br><code>t</code>: tag 标签<br><code>b</code>: block 闭包，区域</p></li><li><p>名词作为动作<br>名词也可以作为动作,作为移动内容距离的大小。</p></li><li><p>用Vim语言来造句<br>现在我们有了各种句子元素了，怎么造句？正如英语我们把名词、动词、修饰符直观的链接起来。</p></li></ul><p><strong>删除两个单词(Delete 2 words)</strong></p><blockquote><p><code>d2w</code></p></blockquote><p><strong>删除当前句子然后进入编辑模式(change inside sentence/delete current one and enter insider mode)</strong></p><blockquote><p><code>cis</code></p></blockquote><p><strong>拷贝你在的段落(yank inside paragraph)</strong></p><blockquote><p><code>yip</code></p></blockquote><p><strong>从你在的地方到下一个&lt;之内修改文本(change to &lt;)</strong></p><blockquote><p><code>ct&lt;</code> </p></blockquote><p>这里到下一个开尖括号可替换到下一个任何内容。到语法仅仅为<code>t</code>,我可以说<code>dt.</code>或<code>yt;</code>,意为删除到下一个句号和拷贝到下一个分号。</p><h1 id="成为实践派"><a href="#成为实践派" class="headerlink" title="成为实践派"></a>成为实践派</h1><p>在实践了一些基础内容之后，我们来上手更多深入的内容</p><h2 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h2><p><code>vi filename</code>:用vim打开文件<br><code>:w</code>:把改动写入(write)文件，即保存文件<br><code>:q!</code>:强行退出不保存(quit!)<br><code>:wq</code>:保存退出<br><code>:saveas ~/some/path/...</code>:另存为到指定地址</p><blockquote><p><code>ZZ</code>:是一种更快方式实现<code>:wq</code>的方法</p></blockquote><h2 id="搜索文本"><a href="#搜索文本" class="headerlink" title="搜索文本"></a>搜索文本</h2><p>学会使用文本编辑器的第一步就是快速找到你需要的文本。Vim有强大的文本搜索能力，接下来我们就具体谈一谈。</p><ul><li>搜索字符串(正则表达式搜索)<br>一个最基本的vim的文本搜索方法是输入<code>/</code>键之后页面下方出现正则搜索栏，在这里输入要搜索的表达式之后按回车即得到结果。</li></ul><p><strong>搜索include</strong> </p><blockquote><p><code>/include&lt;CR&gt;</code></p></blockquote><p>搜索结果如下：</p><p><img src="https://danielmiessler.com/images/vim_jump.jpg" alt="搜索结果"></p><p>搜索完成后，输入<code>n</code>到下一个结果的实列，或<code>N</code>到上一个结果。你也可以用<code>?</code>从你的位置向前搜索文本而不是默认的从光标位置向后搜索。</p><ul><li>跳转到某个字符<br>vim很酷的一个特性就是，从文本的任何地方，你都能找到并跳转到文本另一个特定字符的位置。<br>比如说，我在编辑HTML文件，我总是可以跳转到<code>&lt;</code>的位置也就是句子末尾的位置。</li></ul><p><strong>跳转到<code>&lt;</code>上</strong></p><blockquote><p><code>f&lt;</code></p></blockquote><p><strong>跳转到<code>&lt;</code>前</strong></p><blockquote><p><code>t&lt;</code></p></blockquote><p>可以这么理解，第一个是找到(find)所以是跳转到上，第二个是到(to)所以跳转到之前。</p><p><strong>更新到下一个<code>&lt;</code>之前到内容</strong></p><blockquote><p><code>ct&lt;</code></p></blockquote><p>这个适用于任何字符，比如标点符号、括号、正则表达式等。<br>注意：当用<code>t</code>或者<code>f</code>命令找到一个字符后，<code>;</code>转到下一个搜索结果，<code>,</code>转到上一个搜索结果。</p><p><strong>搜索文本总结</strong><br><code>/{string}</code>:找字符串<br><code>t</code>:跳转到字符前<br><code>f</code>:跳转到字符上<br><code>*</code>:找光标所在的单词的下一个实列<br><code>n</code>:执行找字符串之后，跳转到下一个结果实列<br><code>N</code>:执行找字符串之后，跳转到上一个结果实列<br><code>;</code>:执行跳转字符之后，跳转到下一个结果<br><code>,</code>:执行跳转字符之后，跳转到上一个结果</p><h2 id="文本内移动"><a href="#文本内移动" class="headerlink" title="文本内移动"></a>文本内移动</h2><p>在文本内快速移动对编辑效率至关重要。而Vim能简单且优雅的完成这项任务，凸显出其核心理念即vim是一门语言。</p><ul><li>基本动作<br>会打字的人右手基本都是放在<code>j,k,l,;</code>这几个键上的，这几个键对Vim也很重要。<br><code>j</code>:向下移动，下移一行<br><code>k</code>:向上移动，上移一行<br><code>h</code>:左移一个字符<br><code>l</code>:右移一个字符</li></ul><p>这上手可能有点别扭，但熟悉之后你会想在word里这么用。<br>你的食指和中指控制下和上，食指和四指控制左和右。</p><ul><li><p>行内移动<br>行内移动很方便<br><code>0</code>:移动到本行(光标所在的行)行首，即行的头。<br><code>$</code>:移动到行尾<br><code>^</code>:移动到本行第一个非空格字符上。</p></li><li><p>以一个单词为单位移动<br><code>w</code>:向前移动一个单词<br><code>b</code>:向后移动一个单词<br><code>e</code>:移动到当前单词的词尾位置</p></li></ul><p>当使用大写的上面的命令时，运行将无视定界字符，例如分号(;)等。<br><code>W</code>:向前移动一个整单词<br><code>B</code>:向后移动一个整单词</p><ul><li><p>以句子或段落为单位移动<br><code>(</code>:从光标位置向上移动一个句子。<br><code>)</code>:向下移动一个句子。<br><code>{</code>:向上移动一个段落。<br><code>}</code>:向下移动一个段落。</p></li><li><p>在屏幕显示的范围内移动<br><code>H</code>:移动到屏幕顶部<br><code>M</code>:移动到屏幕中间<br><code>L</code>:移动到屏幕底部<br><code>gg</code>:移动到文件头部<br><code>G</code>:移动到文件底部<br><code>^U</code>:上移半个频幕<br><code>^D</code>:下移半个频幕<br><code>^F</code>:上移动频幕页面<br><code>^B</code>:下移动频幕页面</p></li><li><p>向前向后跳转<br>在普通模式下在两个位置间跳转很容易<br><code>Ctrl-i</code>:跳到之前导航位置。<br><code>Ctrl-o</code>:跳到你原来的位置。</p></li><li><p>其它动作<br><code>:$行号</code>:移动到指定行。</p></li></ul><h2 id="修改文本"><a href="#修改文本" class="headerlink" title="修改文本"></a>修改文本</h2><p>我们已经学了不少文本移动光标操作；现在来学改变文本吧。首先我们要记住，我们总是要使用移动动作的，他们是这个语言的重要部分(修饰符)。</p><ul><li>认识模式<br><img src="https://danielmiessler.com/images/vim_modes.png" alt="模式"></li></ul><p>首先我们要掌握模式这个概念。当然开始你可能会觉得有些晦涩难懂，当你领会之后你就会习惯它的。大多数教程都是先开始讲解模式，但我觉得这样很不自然。从普通模式开始讲到插入模式的转折时我们再来讲就比较合适。</p><p><em>程序以普通模式开始</em>。最让初学者头疼的一件事就是你一打开vim时不能编辑，不能写任何东西的。普通模式也叫做命令模式，你在这个模式下输入命令。命令即是移动光标，删除等。之后便进入插入模式。</p><p><em>插入模式</em>是你修改文本的阶段。从普通模式有成吨的进入插入模式的方法。不用担心，在经常练习后你会熟悉它们的。</p><p><em>虚拟模式</em>是一种选择大段文本的方法。它很想普通模式，只不过光标移动改变选中的高亮显示。可以选多个字符或者多行。虚拟模式的意义是对选中内容同时进行操作。</p><p><em>执行模式</em>是在普通模式下输入<code>:</code>时在屏幕下方出现一行命令行。你可以在这里进行命令行操作。</p><ul><li>别忘了你的语言<br>让我们再回忆一下我们的语言：<em>动词</em>、<em>修饰符</em>、<em>名词</em>。假设我们从普通模式开始，现在将要进入插入模式。</li></ul><p>我们以动词开始，且有几个选择。我们可以改变(c)、插入(i)、或附加(a)并且可以在这些动作上添加变化。</p><ul><li>基本编辑／插入操作<br><code>i</code>:在光标前插入<br><code>a</code>:在光标后附加<br><code>I</code>:在行首插入<br><code>A</code>:在行尾附加<br><code>o</code>:在光标行下打开新一行，光标在新行首<br><code>O</code>:在光标行上打开新一行<br><code>r</code>:用r之后的一个字符替代光标所在的字符，之后还在普通模式<br><code>R</code>:用R之后的一串字符串替代光标所在位置之后的字符串，进入插入模式<br><code>c+movement</code>:改变你定义动作之内的内容<br><code>C</code>:改变一整行<br><code>ct?</code>:改变到问号之前<br><code>s</code>:替换光标位置开到下一个命令的内容<br><code>S</code>:替换光标所在的一整行</li></ul><p><strong>在句子中更改</strong></p><blockquote><p><code>cis</code></p></blockquote><p><strong>在光标所在的行首插入</strong></p><blockquote><p><code>I</code> </p></blockquote><p><strong>在光标位置后进入插入模式附加内容</strong></p><blockquote><p><code>a</code></p></blockquote><p>有很多的命令可以做多种动作，比如删除整行并进入插入模式</p><p><strong>删除光标所在位置之后的行内容且进入插入模式</strong></p><blockquote><p><code>C</code></p></blockquote><p><strong>删除光标所在的整行且进入插入模式</strong></p><blockquote><p><code>S</code></p></blockquote><ul><li><p>改变大小写<br><code>~</code>:对单个或者一组字符改变大小写</p></li><li><p>格式化文本<br>有时快速格式化一段文本很有用，比如格式化段落。</p></li></ul><p><strong>格式化当前段落</strong></p><blockquote><p><code>gq ap</code></p></blockquote><p><code>gq</code>根据你的文本宽度设定，把文本限制在这些界限内。<code>ap</code> 意思为在段落内(around paragraph )</p><h2 id="删除文本"><a href="#删除文本" class="headerlink" title="删除文本"></a>删除文本</h2><p>现在你已经知道怎么修改文本了，之后我们来看怎么删除文本。其实也是十分相同的，只要在语句中换不同的动词就好了。</p><ul><li>基本删除操作<br><code>x</code>:消灭光标所在的字符<br><code>X</code>:消灭光标位置之前的字符<br><code>d+movement</code>:删除一个动作，一个词，句子或者段落<br><code>dd</code>:删除光标所在的行<br><code>dt.</code>:删除到下个<code>.</code>号为止<br><code>D</code>:删除到行尾<br><code>J</code>:链接当前位置于下一行，删除之中的内容</li></ul><h2 id="撤销操作和恢复操作"><a href="#撤销操作和恢复操作" class="headerlink" title="撤销操作和恢复操作"></a>撤销操作和恢复操作</h2><p>撤销和恢复操作是文本编辑器必备功能。你应该注意到了，vim尽最大努力让键的操作很简单，撤销和恢复操作也一样。</p><p><code>u</code>:撤销上一次的操作<br><code>Ctrl-r</code>:恢复上一次撤销的操作</p><p>两个操作都可以重复多次，知道你撤销到最后保存到状态，或者恢复到你没有撤销之前的状态。</p><h2 id="重复之前的动作"><a href="#重复之前的动作" class="headerlink" title="重复之前的动作"></a>重复之前的动作</h2><p>vim有一个非常强大的命令符<code>.</code>,有点奇怪是不是。点操作符能让你实现聪明的操作，它重复你之前所做的动作。</p><p><strong>用<code>.</code>重复上一次的动作</strong><br>我们有很多任务会涉及到重复性的动作。例如，进入插入模式然后增加些文本。你能用<code>.</code>重复之前的动作到文本另一处再插入文本。</p><p><strong>删除一个单词，重复5次</strong></p><blockquote><p><code>dw</code><br><code>5.</code></p></blockquote><p>等他和虚拟模式一起使用的时候，你能发现他的强大功能。</p><h2 id="拷贝和粘贴"><a href="#拷贝和粘贴" class="headerlink" title="拷贝和粘贴"></a>拷贝和粘贴</h2><p>另一个编辑器必备功能是快速的拷贝粘贴，在这方面vim是大师。</p><p><strong>拷贝文本</strong><br>vim的拷贝指令有些不一般。并不是一遍期待的<code>c</code>而是<code>y</code>。<br><code>y</code>:拷贝光标之上或选中文本<br><code>yy</code>:拷贝整行</p><p><strong>剪切</strong><br>剪切和删除等同。实际上不管你用在什么语句中，你删除后的文本会被放在缓冲区，等待被粘贴。</p><p><strong>粘贴</strong><br>粘贴命令即是很直接的<code>p</code>命令，如果你使用<code>dd</code>删除了一行文本，你可以用<code>p</code>再粘贴回来。</p><p>关于粘贴还有一件事需要注意，内容将粘贴到你光标位置之后不论你将粘贴的是词、句子还是段落。如果出了错误，你当然可以用<code>u</code>命令撤销之前粘贴的内容。</p><ul><li>拷贝粘贴命令总结<br><code>y+movement</code>:拷贝内容，动作由movement决定<br><code>yy</code>:拷贝光标所在行<br><code>p</code>:光标位置之后粘贴内容<br><code>P</code>:光标位置之前粘贴内容</li></ul><p><strong>交换两行位置</strong></p><blockquote><p><code>ddp</code></p></blockquote><p>这是一个你用来交换两行文本的小技巧。首先你删除一行文本，使下一行为本上移，之后粘贴到上移文本之后，实现两行位置交换。</p><h2 id="检查拼写错误"><a href="#检查拼写错误" class="headerlink" title="检查拼写错误"></a>检查拼写错误</h2><p>如果编辑器不能进行拼写检查，会给我们带来很多麻烦。vim在这方面也很在行，所以不用担心。<br>首先在配置文件中加入以下设置：</p><p><strong>在配置文件中<code>~/.vimrc</code>加入</strong></p><blockquote><p><code>set spell spellang=en_us</code></p></blockquote><ul><li>定位拼写错误的文本<br>当你在配置文件中加入<code>set spell</code>项并开启，拼写错的单词就会被自动下划线，我们可以启用和关闭这一选项用<code>:set spell</code>和<code>set nospell</code>命令。</li></ul><p>一旦产生拼写错误，我们可以逐个访问这些单词，并且用下面动作修改。</p><p><strong>访问下一个错词，访问上一个错词</strong></p><blockquote><p><code>]s</code><br><code>[s</code></p></blockquote><p><strong>在错词上时vim给出修改意见</strong></p><blockquote><p><code>z=</code></p></blockquote><p><strong>把提示错误的单词添加为正确</strong></p><blockquote><p><code>zg</code></p></blockquote><p><strong>把没有提示错误的单词添加成错误</strong></p><blockquote><p><code>zw</code></p></blockquote><h2 id="替换文本"><a href="#替换文本" class="headerlink" title="替换文本"></a>替换文本</h2><p>vim的另一项强大特性是文本替换。首先指示你需要替换的文本，再指示替换内容，之后设定替换范围。<br>基本指令是<code>:%s</code></p><p><strong>在所有行里用bar替换foo</strong></p><blockquote><p><code>:%s /foo/bar/g</code></p></blockquote><p><strong>仅在光标所在行用bar替换foo</strong></p><blockquote><p><code>:s /foo/bar/g</code></p></blockquote><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>太棒了。我们已经学习了很多文本编辑器的基本操作，和怎么用vim实现这些操作。现在就让我们探索一些更高深的内容吧-不过请谨记这些高深的内容也仅仅是初步的高深内容，要成为高手还要更加努力。</p><h2 id="可重复过程"><a href="#可重复过程" class="headerlink" title="可重复过程"></a>可重复过程</h2><p>之前我们讨论过用句点操作符快速实现可重复操作。但句点操作符只特别适用某一些操作，并且我们应该知道其中的区别和原因。</p><p>总的来说，使用句点操作符的实质是你的动作和可重复命令语句被句点操作符捕捉到。</p><p>举个例子，假如你要在多行行尾增加一点文本，但你只希望文本增加到包含有你指定字符串的行。你可以用如下操作：</p><p><strong>搜索指定字符串</strong></p><blockquote><p><code>/delinquent</code></p></blockquote><p>得到结果后，按<code>n</code>键可以移动到下一个结果的位置。从第一个开始我们附加文本。</p><p><strong>附加文本</strong></p><blockquote><p><code>A[DO NOT PAY] [Esc]</code></p></blockquote><p>已经完成一处到操作了。但还有其它位置的操作。句点操作符可以让我们重复之前的操作，因为之前搜索结果被储存了所以我可以结合两个操作。</p><p><strong>到下一个搜索结果，重复之前添加文本的操作</strong></p><blockquote><p><code>n.</code> (n是到下一个结果）</p></blockquote><p>记住重点是把移动和存储的命令结合起来，你就可以遍历结果重复命令了。</p><h2 id="文本对象"><a href="#文本对象" class="headerlink" title="文本对象"></a>文本对象</h2><p>文本对象很厉害。他让你用行为(动词)于更复杂的目标(名词)。因此你可以不用仅仅选择一个单词删除，或从句首删除一句，你可以从任何地方对这些’对象’操作。</p><p>这里看几个例子:</p><p><strong>单词文本对象</strong><br>我们先看几个以单词为基础的对象。<br><code>iw</code>:在单词内部<br><code>aw</code>:在单词周围</p><p>这些是目标(名词)，所以我们可以更改它们，删除它们等等。</p><p><strong>在单词周围删除</strong></p><blockquote><p><code>daw</code></p></blockquote><p>注意：在单词内和在单词周围的区别是包不包括跟着单词的下一个空格。比如上面的命令，执行之后删除单词和跟着单词的一个空格，而<code>diw</code>命令只删除单词不删除空格。</p><p><strong>句子文本对象</strong></p><p><code>is</code>:在句子之内<br><code>as</code>:在句子周围</p><p>这些内容和单词的很接近。比如你在一个句子内部时决定要删除这个句子从新写一句，你不需要返回句子开头删除，只需要用:</p><p><strong>在句子内部更改</strong></p><blockquote><p><code>cis</code></p></blockquote><p>这个命令删除一句并让你在新句子的句首进入插入模式编辑。</p><p><strong>其它的对象类型</strong></p><p>还有一些其他对象类型，这里简要提一下。<br><code>ip</code>和<code>ap</code>:段落对象<br><code>i&#39;</code>和<code>a&#39;</code>:单引号对象<br><code>i&quot;</code>和<code>a&quot;</code>:双引号对象</p><p>笔者经常使用这些命令编辑代码和HTML文本。重点是你不需要在命令执行的位置，告诉vim<code>ci&quot;</code>他就会删除双引号内所以东西并把你置于其中。所以这个功能用好之后很酷的。</p><p>同样以上内容可以用于包括小括号、中括号、大括号或HTML中的tags。</p><p>像一下这个场景，你在编辑HTML链接，URL在双引号中，link文本在tags中。你可以很优雅的编辑，仅仅用<code>ci&quot;</code>和<code>cit</code>命令。</p><p><strong>文本对象总结</strong></p><p><code>iw/aw</code>:单词<br><code>is/as</code>:句子<br><code>ip/ap</code>:段落<br><code>i&#39;/a&#39;</code>:单引号<br><code>i&quot;/a&quot;</code>:双引号<br>i<code>:撇号</code>i(/a(<code>:括号</code>i[/a[<code>:方括号</code>i{/a{<code>:大括号</code>it/at`:标签tags</p><h2 id="虚拟模式"><a href="#虚拟模式" class="headerlink" title="虚拟模式"></a>虚拟模式</h2><p><img src="https://danielmiessler.com/images/vim_visualselect.jpg" alt="虚拟模式"></p><p>虽然有很多vim技巧用好了会很让人崇拜，但没几个能像用好虚拟模式给人带来快乐的。<br>关于虚拟模式最重要的一点可能就是，它增强你现在所学内容的威力。它让你对选中的文本执行命令。</p><p>让我们从进入虚拟模式开始说起。用<code>v</code>进入虚拟模式，你还有其他一些选择。</p><p><code>v</code>:以字符为基础选择文本<br><code>V</code>:以行为基础<br><code>Ctrl-v</code>:以段落为基础</p><ul><li>在内部选择<br>你时常需要在某些区域内部选择一些文本比如逗号、句号、括号等内部。你能通过以下命令实现：</li></ul><p><strong>在括号内选择</strong></p><blockquote><p><code>vi(</code> 或者 <code>vi[</code></p></blockquote><p>如果有嵌套集合，你也可以通过增加数字实现选择特定内容。<br><strong>选择第二级括号内</strong></p><blockquote><p><code>v2i{</code></p></blockquote><ul><li><p>字符虚拟模式选择<br>我们从字符选择模式开始，你用这个虚拟模式选择一个或多个字符。笔者此种模式的使用机会远小于行选择模式，不过它仍然是一种有用的模式。<br>要注意的一点是，在选择模式下，你的动作会选择文本，所以你可以通过单词句子之类移动加快选择速度。被选中部分是接下来命令的目标。</p></li><li><p>行基虚拟模式<br>用<code>V</code>进入此模式选择文本，然后执行我们接下来要讨论的动作。</p></li><li><p>能对选择的文本做的动作<br>其实什么动作任你选，不过最主要的包括删除、拷贝和粘贴。你可以把它理解成你用鼠标多选区域的操作。</p></li></ul><p><strong>进入虚拟模式，选择两个单词，拷贝</strong></p><blockquote><p><code>vwwy</code></p></blockquote><p>之后到你想要粘贴它们的地方用<code>p</code>。</p><p>你还可以做一些行基操作<br><strong>进入虚拟模式，删除两行文本</strong></p><blockquote><p><code>Vjjd</code></p></blockquote><p>你也可以使用文本对象，虽然可能有些麻烦<br><strong>虚拟模式下选中一整段</strong></p><blockquote><p><code>vip</code></p></blockquote><p><strong>选中一整段复杂粘贴到其下</strong></p><blockquote><p><code>vipyjjp</code></p></blockquote><p>别觉得它太长，记住它是门语言。</p><ul><li>把虚拟模式于重复结合<br>另一个很酷的事情是结合虚拟模式于<code>.</code>，吧储存的命令用于一片选中的区域，例如。</li></ul><blockquote><p>foo<br>bar<br>thing<br>other<br>yetanother<br>also</p></blockquote><p>如果我们像在每一个单词前面增加一个<code>:</code>符号，我们可以先给第一个加上，虚拟模式选中剩下行然后按<code>.</code>键。</p><blockquote><p>:foo<br>:bar<br>:thing<br>:other<br>:yetanother<br>:also</p></blockquote><p>想象如果你的文件有6000行，用这个办法是不是很酷？<br><strong>给整个文件加<code>:</code>号</strong></p><blockquote><p><code>0i:j0vG.</code></p></blockquote><p>以下是解释：</p><ol><li>到行首插入一个:号</li><li>到下一行首</li><li>虚拟选中整个文件</li><li>增加:号</li></ol><h2 id="使用宏"><a href="#使用宏" class="headerlink" title="使用宏"></a>使用宏</h2><p>很多人听到宏就害怕。其实一点也不然，宏说到底就做一件事：纪录你做的动作，当你需要重做时，重放这些动作。<br><code>qa</code>:开始记录一个名为a的宏<br><code>q</code>:停止记录<br><code>@a</code>:重放宏</p><p>很简单吧。你可以把多个宏储存在多个存储器中”b”,”c”等等。使用时只要重放就好。</p><ul><li>为什么用宏<br>有些人会问:如果虚拟模式选择加上重复动作符点既然已经很强大了，为什么要用宏呢？<br>原因很复杂，但请知道宏可以做任何你能做的事情。请看如下的工作流：</li></ul><ol><li>在行内搜索”widget”</li><li>在此单词尾附加”-maker”</li><li>回到行首插入”:”</li><li>再到行尾附加上”.”</li><li>删除行尾多余的空格</li></ol><p>以上有很多的操作，如果你的文件有6万行的话，你可以要崩溃了。<br>在vim里你所要做的仅仅是在一行中完成以上动作，在剩下行里重放就好了。</p><p>注意：你可以在虚拟模式选中文本中执行宏，<code>:normal @a</code>命令使你进入普通模式，然后在选中的文本重放a里的命令。</p><h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><p>我们来给出一些经常被问到一些任务的处理方法。</p><h2 id="移除行尾的空格"><a href="#移除行尾的空格" class="headerlink" title="移除行尾的空格"></a>移除行尾的空格</h2><blockquote><p><code>:%s/\s\+$//</code></p></blockquote><h2 id="改变文件类型"><a href="#改变文件类型" class="headerlink" title="改变文件类型"></a>改变文件类型</h2><blockquote><p><code>set ft=unix</code><br><code>set ft=html</code><br><code>set ft=dos</code></p></blockquote><h2 id="包裹内容"><a href="#包裹内容" class="headerlink" title="包裹内容"></a>包裹内容</h2><p>使用”surround”插件操作包裹文本很方便。</p><p><code>cs&quot;&#39;</code>:把”换成’<br><code>cs&#39;&lt;q&gt;</code>:把’换成<code>&lt;q&gt;</code><br><code>ds&quot;</code>:把包裹号”删除<br><code>ysiw[</code>:用方括号包裹当前单词<br><code>ysiw&lt;em&gt;</code>:强调当前单词</p><h2 id="分屏操作"><a href="#分屏操作" class="headerlink" title="分屏操作"></a>分屏操作</h2><p><code>:vs [filename]</code>:左右分屏<br><code>:sp [fileename]</code>:上下分屏<br><code>:e path/filename</code>:启动一个新文件替换当前文件内容<br><code>:f filename</code>:将当前文件命名为filename</p><p><code>Ctrl+w+h,j,k,l</code>:上下作用移动切换屏幕焦点<br><code>Ctrl+w+w,p</code>:焦点移到下一个，上一个屏幕</p><p><code>Ctrl+w+c</code>:关闭焦点所在的屏<br><code>Ctrl+w+o</code>:关闭其他屏幕</p><h2 id="多标签页面"><a href="#多标签页面" class="headerlink" title="多标签页面"></a>多标签页面</h2><p><code>:tabnew [filename]</code>:打开新标签页，如果有文件名参数，则打开页面后载入文件<br><code>:tabc</code>:关闭当前标签页<br><code>:tabfir</code>:到第一个标签页<br><code>:tabl</code>:到最后一个标签页<br><code>:tabn</code>:到下一个标签页<br><code>:tabp</code>:到上一个标签页<br><code>:tabo</code>:除了当前的标签页，其他标签页全关闭</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>还有两件事我想提一下。</p><ol><li>vim很好学习 </li><li>vim功能强大</li></ol><p>如果到目前为止能跟上并且能喜欢我们所学的基础那么说明你对文本更敏感，这可不是无关紧要的事。你越是对文本敏感，说明你对创意，观点很敏感，这是很棒的。</p><p>而这也是你为什么要熟练于文本编辑器的原因。让你更自然，更游刃有余的发现点子，记录想法，而不是被编辑器妨碍。</p><p>或者你也许并不在乎点子，只想成为那些编辑起文件来让其他人惊叹的人。不管哪种，我希望你会觉得本文有用处。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li>推荐一本 Drew Neil 的书 《Practical Vim: Edit Text at the Speed of Thought》。对于一个真正喜欢vim的人是本必备。</li><li>强烈推荐看 “Your Problem with vim is  that you don’t grok vi”,其中给出了很多技巧。</li><li>如果你没看过Steve Losh的《Coming Home to Vim》我推荐看一看。</li><li>当然要看看Kana the Wizard’s的《True Power of Vim》。</li><li>Vim Quick Reference这里有简洁的命令行总结。</li><li>当然别忘了the Vim Wiki。</li><li>Openvim的This is a really well done interactive tutorial。</li><li>当然还Vim自己的帮助文档。</li></ol>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Design Patterns</title>
      <link href="/2016/09/11/Design-Patterns/"/>
      <url>/2016/09/11/Design-Patterns/</url>
      <content type="html"><![CDATA[<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">View|ViewController &lt;===&gt; View Model &lt;===&gt; Model</span><br></pre></td></tr></table></figure><ul><li>Every View retains a View Model and a View Controller target while every View Model retains it`s View.</li><li>In View Model we handle the logy of the View and the data.</li><li>Since View retains ViewModel and ViewModel retains View, there is strong circle reference which cause memory leak.so all references must be weak both in View and ViewModel.<a id="more"></a><h2 id="Creational-Patterns"><a href="#Creational-Patterns" class="headerlink" title="Creational Patterns"></a>Creational Patterns</h2></li></ul><h2 id="Structural-Patterns"><a href="#Structural-Patterns" class="headerlink" title="Structural Patterns"></a>Structural Patterns</h2><h2 id="Behavioural-Patterns"><a href="#Behavioural-Patterns" class="headerlink" title="Behavioural Patterns"></a>Behavioural Patterns</h2><h3 id="Strategy-pattern"><a href="#Strategy-pattern" class="headerlink" title="Strategy pattern"></a>Strategy pattern</h3><p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/Strategy.jpg" alt="strategy"></p><p>Define a family of algorithms, encapsulate each one, and make theminterchangeable. Strategy lets the algorithm vary independently fromclients that use it.</p><h5 id="Main-Idea"><a href="#Main-Idea" class="headerlink" title="Main Idea"></a>Main Idea</h5><ul><li>Defines a protocol(interface) that contains the algorithm you want to encapsulate.It defines a method of a family of algorithm.</li><li>Implement this protocol in various way that rewrite the algorithm in different ways.</li><li>The context object representing the situation to apply certain algorithm. The context object contains a instance variable of type of the algorithm protocol.</li><li>By invoke the method defined in the protocol of different context, can we get different algorithm under different context. Its a good way to reuse code as all algorithms are written in the implementations of protocol.</li></ul><h3 id="Observer-Pattern"><a href="#Observer-Pattern" class="headerlink" title="Observer Pattern"></a>Observer Pattern</h3><p><img src="https://sourcemaking.com/files/v2/content/patterns/Observer.svg" alt="Observer Pattern"></p><p>The observer pattern is a software design pattern in which an object, called the subject, maintains a list of its dependents, called observers, and notifies them automatically of any state changes, usually by calling one of their methods. It is mainly used to implement distributed event handling systems. The Observer pattern is also a key part in the familiar model–view–controller (MVC) architectural pattern. The observer pattern is implemented in numerous programming libraries and systems, including almost all GUI toolkits.</p><h5 id="Main-Idea-1"><a href="#Main-Idea-1" class="headerlink" title="Main Idea"></a>Main Idea</h5><ul><li>Protocol Subject defines methods: register, unregister, notify. The implementation object of Subject maintains a list of observers that are to notify.</li><li>Register and Unregister method control the content of the list of observer.  Notify method iterate through the list and invoke observer<code>s update method with Subject</code>s data wanted to notify.</li><li>Protocol Observer defines the update method that when invoked by subject and received the data to update , update the data in object to the data just received.</li><li>Implementation of Observer maintains an instance variable of Subject.When Observer instance is created, Subject instance are take as default parameter. The subject instance must be a singleton among all observers.</li><li>When observer`s update method is invoked by subject,observers get the data send by Subject. Observer can update the data stored as do other custom action. </li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LintCode Medium Java Solution</title>
      <link href="/2016/08/27/LintCode-Medium-Java-Solution/"/>
      <url>/2016/08/27/LintCode-Medium-Java-Solution/</url>
      <content type="html"><![CDATA[<h5 id="Ugly-Number-II"><a href="#Ugly-Number-II" class="headerlink" title="Ugly Number II"></a>Ugly Number II</h5><ul><li>Ugly number is a number that only have factors 2,3 and 5.Design an algorithm to find the nth ugly number. The first 10 ugly numbers are1, 2, 3, 4, 5, 6, 8, 9, 10, 12…</li></ul><h6 id="solution"><a href="#solution" class="headerlink" title="solution:"></a>solution:</h6><ul><li>triple pointer: because the Ugly number array is an array that starts from 1 and by multiply 2,3,5 repeatedly to the numbers in the array.So the idea is to point at numbers in the array and check if the number multiplied by 2,3,5 is greater then the last number.</li><li>三个指针指向一个数列，如果指向目标乘2、3、5大于数列最后一个数，则从三者中选最小的加入数列</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">               List&lt;Integer&gt; uglys = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        uglys.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">0</span>, p3 = <span class="number">0</span>, p5 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// p2, p3 &amp; p5 share the same queue: uglys</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> lastNumber = uglys.get(i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (uglys.get(p2) * <span class="number">2</span> &lt;= lastNumber) p2++;</span><br><span class="line">            <span class="keyword">while</span> (uglys.get(p3) * <span class="number">3</span> &lt;= lastNumber) p3++;</span><br><span class="line">            <span class="keyword">while</span> (uglys.get(p5) * <span class="number">5</span> &lt;= lastNumber) p5++;</span><br><span class="line"></span><br><span class="line">            uglys.add(Math.min(</span><br><span class="line">                Math.min(uglys.get(p2) * <span class="number">2</span>, uglys.get(p3) * <span class="number">3</span>),</span><br><span class="line">                uglys.get(p5) * <span class="number">5</span></span><br><span class="line">            ));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> uglys.get(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="Binary-Tree-Serialization"><a href="#Binary-Tree-Serialization" class="headerlink" title="Binary Tree Serialization"></a>Binary Tree Serialization</h5><ul><li>Design an algorithm and write code to serialize and deserialize a binary tree. Writing the tree to a file is called ‘serialization’ and reading back from the file to reconstruct the exact same binary tree is ‘deserialization’.</li><li>There is no limit of how you deserialize or serialize a binary tree, you only need to make sure you can serialize a binary tree to a string and deserialize this string to the original structure.</li></ul><h5 id="solution-1"><a href="#solution-1" class="headerlink" title="solution:"></a>solution:</h5><p>maintain a list of TreeNode to keep track of nodes postions<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> public String serialize(TreeNode root) &#123;</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return &quot;&#123;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;TreeNode&gt; queue = new ArrayList&lt;TreeNode&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; queue.size(); i++) &#123;</span><br><span class="line">        TreeNode node = queue.get(i);</span><br><span class="line">        if (node == null) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(node.left);</span><br><span class="line">        queue.add(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (queue.get(queue.size() - 1) == null) &#123;</span><br><span class="line">        queue.remove(queue.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StringBuilder sb = new StringBuilder();</span><br><span class="line">    sb.append(&quot;&#123;&quot;);</span><br><span class="line">    sb.append(queue.get(0).val);</span><br><span class="line">    for (int i = 1; i &lt; queue.size(); i++) &#123;</span><br><span class="line">        if (queue.get(i) == null) &#123;</span><br><span class="line">            sb.append(&quot;,#&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sb.append(&quot;,&quot;);</span><br><span class="line">            sb.append(queue.get(i).val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sb.append(&quot;&#125;&quot;);</span><br><span class="line">    return sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode deserialize(String data) &#123;</span><br><span class="line">    if (data.equals(&quot;&#123;&#125;&quot;)) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] vals = data.substring(1, data.length() - 1).split(&quot;,&quot;);</span><br><span class="line">    ArrayList&lt;TreeNode&gt; queue = new ArrayList&lt;TreeNode&gt;();</span><br><span class="line">    TreeNode root = new TreeNode(Integer.parseInt(vals[0]));</span><br><span class="line">    queue.add(root);</span><br><span class="line">    int index = 0;</span><br><span class="line">    boolean isLeftChild = true;</span><br><span class="line">    for (int i = 1; i &lt; vals.length; i++) &#123;</span><br><span class="line">        if (!vals[i].equals(&quot;#&quot;)) &#123;</span><br><span class="line">            TreeNode node = new TreeNode(Integer.parseInt(vals[i]));</span><br><span class="line">            if (isLeftChild) &#123;</span><br><span class="line">                queue.get(index).left = node;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                queue.get(index).right = node;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!isLeftChild) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        isLeftChild = !isLeftChild;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Key Algorithms</title>
      <link href="/2016/07/13/Key-Algorithms/"/>
      <url>/2016/07/13/Key-Algorithms/</url>
      <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h1><ul><li>explain:<br>Set a pivot point in the array,all bigger than pivot to the right and all smaller than pivot to the left.divide the array through the pivot point into two subarray and do the sorting recursively.</li></ul><p>The steps are:<br>1 Pick an element, called a pivot, from the array.<br>2 Partitioning: reorder the array so that all elements with values less than the pivot come before the pivot, while all elements with values greater than the pivot come after it (equal values can go either way). After this partitioning, the pivot is in its final position. This is called the partition operation.<br>3 Recursively apply the above steps to the sub-array of elements with smaller values and separately to the sub-array of elements with greater values.</p><ul><li>分治法，快速排序</li></ul><p>数组中找一个中心点，把大于中心点的放在右，小于中心点的放在左。在中心点左右两个子数组中迭代的使用快速排序再排列。伪代码给出的实现方法用双指针法，把数组最右边元素当做中心点，前一个指针遍历数组，后一个指针纪录比中心点小的元素子列头位置，一旦前面指针遍历到有比中心点小的元素，则后面指针自增一并与前指针交换元素，形成前大于中心点子数组和后小于中心点子数组。最后把最右边的中心点与后指针加一位置元素交换再对两个子数组迭代。</p><p>步骤：<br>1 选中心点，一般为数组结尾元素。<br>2 分隔：重新调整数组，使比中心点小的元素在数组左边，比中心点大的元素在数组右边。分隔之后中心点在两个子数组中间。<br>3 在比中心点小的元素子数组和比中心大的子数组上迭代以上步骤，直到排序完成。</p><ul><li><p>pseudo code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">QuickSort(Array A,fistIndex p,lastIndex r) //p <span class="keyword">and</span> r represent the range to sort</span><br><span class="line"><span class="keyword">if</span>  p &lt; r:</span><br><span class="line">     q = Partition(A,p,r);</span><br><span class="line">     QuickSort(A,p,q<span class="number">-1</span>);</span><br><span class="line">     QuickSort(A,q+<span class="number">1</span>,r);</span><br><span class="line"></span><br><span class="line">Partition(Array A,startIndex p,endIndex r)</span><br><span class="line">x = A[r];</span><br><span class="line">i = p - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> j = p to r <span class="number">-1</span>:</span><br><span class="line">     <span class="keyword">if</span> A[j] &lt;= x :</span><br><span class="line">          i = i + <span class="number">1</span>;</span><br><span class="line">          exchange A[i] <span class="keyword">with</span> A[j]; //<span class="keyword">if</span> A[j] <span class="keyword">is</span> smaller than pivot point,put into left subarray</span><br><span class="line">exchange A[i + <span class="number">1</span>] <span class="keyword">with</span> A[r]; // after iteration put pivot into where it divide the two subarrays.</span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span>; // <span class="keyword">return</span> the index of the pivot point</span><br></pre></td></tr></table></figure></li><li><p>runtime O( )<br>worst case: O(n^2);<br>best case: O(n <em> log n) or O(n);<br>average case performance : O(n </em> log n);</p><a id="more"></a></li></ul><h1 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h1><ul><li><p>explanation:<br>Iterate from left of the array to the right of the array. For each iteration item, bubble sort left subarray to its  position.In place sort.<br>插入排序为原位排序，不需要多余空间复杂度。从数组左边遍历到右边，对于每一个遍历元素向左冒泡到其位置。</p></li><li><p>pseudo code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">INSERTION-SORT(A)</span><br><span class="line"><span class="keyword">for</span> j = <span class="number">1</span> to A.length - <span class="number">1</span>:</span><br><span class="line">     key = A[ j ];// insert key to subarray A[<span class="number">0</span> … j - <span class="number">1</span>]</span><br><span class="line">     i = j - <span class="number">1</span> ;</span><br><span class="line">     <span class="keyword">while</span> i &gt;= <span class="number">0</span>  <span class="keyword">and</span> A[ i ] &gt; key: //bubble sort</span><br><span class="line">          A[i + <span class="number">1</span>] = A[ i ];     // <span class="keyword">if</span> <span class="keyword">not</span> shift right</span><br><span class="line">          i = i - <span class="number">1</span>;</span><br><span class="line">     A[i + <span class="number">1</span>] = key; // <span class="keyword">if</span> yes insert</span><br></pre></td></tr></table></figure></li><li><p>runtime:<br>worst case : O ( n <em> (n</em>(n+1))/2) = O(n^2);<br>best case : O(n) , with n*(n+1)/2 = 1;<br>average case : O (n^2);</p></li></ul><h1 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort:"></a>Merge Sort:</h1><p>Merge Sort algorithm follows the divide-and-conquer paradigm closely.<br>For each iteration we follow the instructions below:</p><ul><li>Divide:Divide the array into two n/2 subarray.</li><li>Conquer: Sort the two array recursively using merge sort</li><li>Combine: Merge the two sorted subarray</li></ul><p>对于每一次迭代，有3步走：</p><ul><li>切分为两部分，</li><li>对两部分迭代mergeSort算法</li><li>把排序过的两部分融合。</li></ul><p>通过把数列分解成单个元素，在融合单个元素的过程中在原位排序。</p><ul><li>pseudo code:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">MergeSort(A, startIndex, endIndex)      //to initialise the sorting, MergeSort(A,<span class="number">0</span>,A.length)</span><br><span class="line"><span class="keyword">if</span> startIndex &lt; endIndex :</span><br><span class="line">     midIndex = Math.round((startIndex + endIndex) / <span class="number">2</span> ); //divide</span><br><span class="line">     MergeSort(A,startIndex , midIndex);     //conquer</span><br><span class="line">     MergeSort(A,midIndex + <span class="number">1</span> , endIndex);</span><br><span class="line">     Merge(A , startIndex, endIndex);     //combine</span><br><span class="line"></span><br><span class="line">Merge(A, startIndex , midIndex , endIndex)</span><br><span class="line">n1 = midIndex - startIndex +<span class="number">1</span>;</span><br><span class="line">n2 = endIndex - midIndex ;</span><br><span class="line">let L[n1 + <span class="number">1</span>],R[n2 + <span class="number">1</span>] be new arrays;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">0</span> to n1 - <span class="number">1</span>:     //<span class="keyword">from</span> starIndex to midIndex</span><br><span class="line">     L[ i ] = A[startIndex + i ];</span><br><span class="line"><span class="keyword">for</span> j = <span class="number">0</span> to n2 <span class="number">-1</span>:     //<span class="keyword">from</span> midIndex + <span class="number">1</span> to endIndex</span><br><span class="line">     R[ j ] = A[(midIndex + <span class="number">1</span>) + j ];</span><br><span class="line">L[n1] = infinite;      //here use two infinite so that the <span class="keyword">for</span> loop below don`t need to decide whether any subarray are iterate out</span><br><span class="line">R[n2] = infinite;</span><br><span class="line">i = <span class="number">0</span> ;</span><br><span class="line">j = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> k = startIndex to endIndex:</span><br><span class="line">     <span class="keyword">if</span> L[i] &lt;= R[j]:</span><br><span class="line">          A[k] = L[i];</span><br><span class="line">          i = i + <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">else</span>:</span><br><span class="line">          A[k] = R[j];</span><br><span class="line">          j = j + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h1 id="Binary-converter"><a href="#Binary-converter" class="headerlink" title="Binary converter"></a>Binary converter</h1><p>Convert a Decimal number to binary sequence by applying Decimal-Binary convert algorithm.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(x / <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">          convert(x / <span class="number">2</span>);     <span class="comment">//recursion to the bound</span></span><br><span class="line">          print(<span class="string">"%d"</span>,x%<span class="number">2</span>);</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          print(<span class="string">"%d"</span>,x);      <span class="comment">//print the last bit</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Tips-For-XOR"><a href="#Tips-For-XOR" class="headerlink" title="Tips For XOR(^)"></a>Tips For XOR(^)</h1><ol><li><p>to perform NOT(!) on certain bit<br>ex. a = 01111010(binary) , b = 00001111(binary);<br>  c = a^b;<br>result of c is 01110101, which means a^b performs a NOT operation on last 4bits of a.</p></li><li><p>exchange two values of two variable without defining a temp variable .</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">swapNoTemp</span>(<span class="title">T</span> &amp;<span class="title">a</span>,<span class="title">T</span> &amp;<span class="title">b</span>)&#123;</span></span><br><span class="line">     <span class="keyword">if</span> (a != b)&#123; <span class="comment">// if a == b or &amp;a == &amp;b; than no need to swap</span></span><br><span class="line">          a = a^b;</span><br><span class="line">          b = b^a;</span><br><span class="line">          a = a^b;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Tips-For-AND-amp-and-OR"><a href="#Tips-For-AND-amp-and-OR" class="headerlink" title="Tips For AND(&amp;) and OR(|)"></a>Tips For AND(&amp;) and OR(|)</h1><ol><li><p>In bit manipulation, <code>&amp;</code> AND can be used to set some bits to zero while other bits remain its value. Set the mask byte the bit zero where you want to erase, and set one where you want to maintain its value.<br>ex.  n &amp; = 0xffffff00;//set the last 8 bits to zero and others bits remain the same. </p></li><li><p>Often used to manipulate bits that you can set certain bits to 1 while keep other bits. Set the bits in the mask to 1 where you want to set to 1 in the byte to be set, and set bits in mask 0 to remain the value of corresponding bits in the bits which you want to set.<br>ex.  n | = 0xff;// set last 8 bits of n to all one</p></li></ol><h1 id="KMP-String-Match-Algorithm-KMP字符串算法"><a href="#KMP-String-Match-Algorithm-KMP字符串算法" class="headerlink" title="KMP String Match Algorithm KMP字符串算法"></a>KMP String Match Algorithm KMP字符串算法</h1><p>已知，匹配字符串P = p0p1p2……pj-1pj;<br>目标字符串T = t0t1t2…..tn-1;</p><ul><li>特征向量N：用了表示模式P字符分布特征,N有时也称next数组<br>N =    n0n1n2….nm-1 ​;<br>N[j] 当j=0时N[j] = -1; 其他时候N[j] 等于j位置之前P的收尾最长匹配串长度k(意为，头尾两个可重叠的相等的子串的长度)。</li></ul><p>做法：<br>顺序从头开始对比P和T字符串：</p><ol><li>如果出现了不同pj和ti，查表N[j] = k;</li><li>用P[k]和当前出错的位置对齐开始比较</li></ol><p>KMPMatching c++ 实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMPStrMatching</span><span class="params">(<span class="built_in">string</span> T, <span class="built_in">string</span> P, <span class="keyword">int</span> *N, <span class="keyword">int</span> start)</span> </span>&#123; 、</span><br><span class="line">    <span class="keyword">int</span> j= <span class="number">0</span>;<span class="comment">// 模式的下标变量</span></span><br><span class="line">    <span class="keyword">int</span> i = start; <span class="comment">// 目标的下标变量</span></span><br><span class="line">    <span class="keyword">int</span> pLen = P.length( );<span class="comment">// 模式的长度</span></span><br><span class="line">    <span class="keyword">int</span> tLen = T.length( );  <span class="comment">// 目标的长度</span></span><br><span class="line">    <span class="keyword">if</span> (tLen - start &lt; pLen)</span><br><span class="line">         <span class="keyword">return</span> (<span class="number">-1</span>);   <span class="comment">// 若目标比模式短，匹配无法成功 </span></span><br><span class="line">    <span class="keyword">while</span> ( j &lt; pLen &amp;&amp; i &lt; tLen) &#123; <span class="comment">// 反复比较，进行匹配</span></span><br><span class="line">        <span class="keyword">if</span> ( j == <span class="number">-1</span> ||T[i] == P[j])</span><br><span class="line">             i++, j++;       </span><br><span class="line">        <span class="keyword">else</span> j = N[j];    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span> (j &gt;= pLen)       </span><br><span class="line">        <span class="keyword">return</span> (i-pLen);    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> (<span class="number">-1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>求特征向量N(Next)的函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findNext</span><span class="params">(<span class="built_in">string</span> P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, k;</span><br><span class="line">    <span class="keyword">int</span> m = P.length( );    <span class="comment">// m为模式P的长度</span></span><br><span class="line">    <span class="keyword">int</span> *next = <span class="keyword">new</span> <span class="keyword">int</span>[m];  <span class="comment">//动态存储区开辟整数数组</span></span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;  </span><br><span class="line">    j=<span class="number">0</span>; k=<span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">while</span> (j &lt; m<span class="number">-1</span>)&#123;    <span class="comment">//写成   j &lt; m 会越界          </span></span><br><span class="line">        <span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; P[k] != P[j])  <span class="comment">//若不等，采用 KMP 找首尾子串</span></span><br><span class="line">            k = next[k]; <span class="comment">// k 递归地向前找</span></span><br><span class="line">        j++; </span><br><span class="line">        k++;</span><br><span class="line">    <span class="keyword">if</span> (P[k] == P[j])            </span><br><span class="line">        next[j] = next[k];       <span class="comment">// 前面找 k 值，没有受优化的影响  </span></span><br><span class="line">    <span class="keyword">else</span> next[j] = k;            <span class="comment">// 取消if判断，则不优化</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> next; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> 算法总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>OC编程全解读书笔记</title>
      <link href="/2016/07/06/OC%E7%BC%96%E7%A8%8B%E5%85%A8%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2016/07/06/OC%E7%BC%96%E7%A8%8B%E5%85%A8%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="一、面向对象编程"><a href="#一、面向对象编程" class="headerlink" title="一、面向对象编程"></a>一、面向对象编程</h3><p>OC是接口和实现分开写的语言，类公开给外部的，关于如何使用这个类的信息叫做接口（interface）而内部实现和私有方法私有变量则外部不可见（implemetation）。</p><h3 id="二、类的定义"><a href="#二、类的定义" class="headerlink" title="二、类的定义"></a>二、类的定义</h3><p><code>className* object1 = [className new];className* object2 = [[className alloc] init];</code></p><p>new 等于 alloc＋ init 用alloc 和 init 显示调用可以调用不同的初始化方法用处更广泛。</p><h5 id="clang编译、连接、执行程序"><a href="#clang编译、连接、执行程序" class="headerlink" title="clang编译、连接、执行程序"></a>clang编译、连接、执行程序</h5><p>OC用clang编译链接代码，gcc无法使用ARC等不适合OC。</p><ul><li>编译：<code>$ clang -c file1.m file2.m</code></li><li>链接：<code>$ clang -o nameOfExe file1.o file2.o -framework Foundation</code>;</li><li><p>运行：<code>$ ./nameOfExe</code>;</p><a id="more"></a><h3 id="三、类的实现"><a href="#三、类的实现" class="headerlink" title="三、类的实现"></a>三、类的实现</h3><p>接口声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface 类名: 父类名</span><br><span class="line">&#123;</span><br><span class="line">     字段；</span><br><span class="line">&#125;</span><br><span class="line">方法；</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li><li><p>所有的OC编译指令都以@开头以便和C区分。</p></li><li>OC命名习惯：驼峰命名法，类首字母大写，方法首字母小写。</li></ul><h6 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h6><p>bool：C++标准数据类型 为true或false；<br>BOOL： OC或微软定义的别名数据类型，OC中char的别名，为0和非0；<br>Boolean：java基本数据类型，为true或false；</p><p>类实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@implementation 类名</span><br><span class="line">方法实现</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><ul><li>实现部分不需要再次声明父类</li><li>实现部分包含了接口部分声明的所有方法的实现</li><li>要实现私有变量和私有方法<ul><li>私有变量在实现的 .m文件内定义一个@interface 定义私有变量</li><li>私有方法，在接口里没有声明而实现里有的方法即为私有方法</li></ul></li></ul><h6 id="＃import-amp-＃include-amp-class"><a href="#＃import-amp-＃include-amp-class" class="headerlink" title="＃import &amp; ＃include &amp; @class"></a>＃import &amp; ＃include &amp; @class</h6><ul><li>＃include为c引用头文件方法</li><li>＃ import 优于include import可以解决重复引入头文件文件，import会做引用检查 ，如果有依赖引用关系则编译报错</li><li>@class 只告诉编译器后面要用某个类而不关心其他的，一般放在@interface中用来解决头文件循环引用问题，如果接口中有用到自定义类用@class可以提高编译速度，但如果有使用自定义类的具体成员或方法，则要引入头文件。</li></ul><h6 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h6><ul><li>子类中初始化方法一般有以下逻辑<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (id)init</span><br><span class="line">&#123;</span><br><span class="line">     self = [super init];</span><br><span class="line">     if (self != nil)&#123;</span><br><span class="line">         ….</span><br><span class="line">     &#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="四、动态绑定"><a href="#四、动态绑定" class="headerlink" title="四、动态绑定"></a>四、动态绑定</h3><h5 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Volume *v1,*v2; // 对象指针，存放在栈中</span><br><span class="line">v1 = [[Volume alloc] initWithMin:0 max:10 step:1]; // alloc返回在堆中的对象地址，与指针关联</span><br><span class="line">v2=v1;</span><br><span class="line">[v1 up];//给v1发送消息</span><br></pre></td></tr></table></figure><h5 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h5><pre><code>- nil：空的对象- NULL：空的基本数据类型，有时当0使用。</code></pre><p>当给空指针发送消息，运行时不会出错但也不会做任何事情。</p><h5 id="访问器"><a href="#访问器" class="headerlink" title="访问器"></a>访问器</h5><p>oc不能从外部之间访问和修改实列对象的属性，定义setter和getter方法来实现访问和修改。</p><pre><code>- (id) variable; // getter方法- (void) setVariable: (id)newValue;//setter方法</code></pre><p>使用getter和setter方法可以降低耦合，即如果类的结构发生变化，只要改变访问方法，外部不需要改变。</p><h5 id="作用域可见性修饰符"><a href="#作用域可见性修饰符" class="headerlink" title="作用域可见性修饰符"></a>作用域可见性修饰符</h5><ul><li>@private：只有本类内可访问，@implementation实现中定义变量的默认属性</li><li>@protected：本类和子类可访问，接口中默认实列变量属性</li><li>@public</li><li>@package:在框架内如public，在框架外如private</li></ul><table><thead><tr><th></th><th>@private</th><th>@protected</th><th>@public      </th></tr></thead><tbody><tr><td>同一个类</td><td>yes</td><td>yes</td><td>yes</td></tr><tr><td>同一类 -&gt;</td><td>yes</td><td>yes</td><td>yes</td></tr><tr><td>子类</td><td>no</td><td>yes</td><td>yes</td></tr><tr><td>子类 -&gt;</td><td>no</td><td>no</td><td>yes</td></tr><tr><td>任意</td><td>no</td><td>no</td><td>yes</td></tr></tbody></table><h5 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h5><p>oc把类作为对象看待，认为类自身也是有行为的。类的变量和方法被称为类变量和类方法，OC中只有类方法没有类变量。OC中类对象也称为工厂facotry，类方法也称为方法工厂factory method。</p><p>类方法用于创建实例对象，通过对对象发送alloc消息实现。alloc定义在NSObject中。</p><p>class对象类型：OC定义了Class类型来表示类对象，所有类对象都是Class类型。</p><p>class方法：NSObject有一个class实列方法，用于返回对象所输的类对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class theClass = flag ? [Volume class] : [MuteVolume class];//对两个类发送类方法消息，返回的类对象被theClass指向</span><br></pre></td></tr></table></figure><h5 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h5><p>C的函数和在函数外部定义的变量作用域为整个源程序。如果给他们加上static修饰符，则其作用域变为在其所在文件内有效，同一程序的其它文件则不能使用它。</p><h5 id="常量const与指针用法"><a href="#常量const与指针用法" class="headerlink" title="常量const与指针用法"></a>常量const与指针用法</h5><ul><li>指针常量：int * const p = &a;// p指向的地址为常量，即p内的地址是不可以改变的，但地址存的内容是可以改变的。</li><li>常量指针：const int* p1 = &b;//p1指向的内容为常量，即本例为指向const int 即指向的内容不可变,但p1指向的地址可以改变。</li></ul><h5 id="初始化方法的返回值类型-id"><a href="#初始化方法的返回值类型-id" class="headerlink" title="初始化方法的返回值类型(id)"></a>初始化方法的返回值类型(id)</h5><p>在继承存在的情况下，要尽可能避免使用静态类型把代码写死。当初始化方法返回类型为 id时，子类也可以原封不动的使用这个父类的初始化方法而返回到子类的类型。</p><h3 id="五、内存管理"><a href="#五、内存管理" class="headerlink" title="五、内存管理"></a>五、内存管理</h3><p>oc提供自动引用计数，手动引用计数和垃圾回收(iOS不支持)三种方式。</p><h5 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h5><ul><li>retain：引用计数增加1，一定要显示的发生retain来增加引用计数，光使一个指针指向对象不会增加引用计数。</li><li>release：计数减少1</li><li>dealloc：释放内存空间，当一个对象引用计数为0时，系统自动调用dealloc消息释放内存，一般不允许在程序内直接调用dealloc方法。</li></ul><h5 id="自动释放"><a href="#自动释放" class="headerlink" title="自动释放"></a>自动释放</h5><p>autorelease 必须和NAAutoreleasePool对象(非ARC)一起使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id pool = [[NSAutoreleasePool alloc] init];</span><br><span class="line">…...</span><br><span class="line"></span><br><span class="line">[pool release];</span><br></pre></td></tr></table></figure></p><p>ARC 使用@autoreleasPool｛｝块</p><h5 id="临时对象"><a href="#临时对象" class="headerlink" title="临时对象"></a>临时对象</h5><p>在类方法中不以init开头，而以生成对象的类型开头的方法为生成临时对象的方法，通过这种方法创建的对象直接加入内部自动释放池，不需要关注如何销毁，如：<code>+ (id) stringWithUTF8String: (const char *) bytes</code><br>这种函数时便利构造函数，为调用其它构造函数来生成对象。</p><h5 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h5><p>编译器会根据赋值操作、初始化、生命周期等因素，自动加入retain、release代码。</p><ul><li>ARC有效程序不能调用引用计数相关方法。retain、release、autorelease等</li><li>ARC禁止使用NSAutoReleasePool，而使用@autoreleasepool来管理自动释放池。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="强引用弱引用"><a href="#强引用弱引用" class="headerlink" title="强引用弱引用"></a>强引用弱引用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_ _ weak id temp;</span><br><span class="line">_ _strong NSObject *obj;</span><br><span class="line">NSObject * _ _ weak e, * _ _ weak f;</span><br></pre></td></tr></table></figure><p>这种用于修饰指针类型变量的修饰符叫做生命周期修饰符，除strong、weak以外还有autoreleasing、unsafe和unretained等。</p><h3 id="六、垃圾回收"><a href="#六、垃圾回收" class="headerlink" title="六、垃圾回收"></a>六、垃圾回收</h3><h5 id="跟集合"><a href="#跟集合" class="headerlink" title="跟集合"></a>跟集合</h5><p>全局变量和静态变量、栈内临时变量对象称为根集合。被根集合引用或被根集合引用对象引用的对象不可回收。<br>只要是从根集合出发无法达到的对象都属于垃圾回收的目标。</p><h5 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h5><p>运行自适应，当程序运行分配内存超过一定量则自动被触发。触发后先找到所有不用的对象，给这些对象发送<code>finalize</code>消息。等所有对象响应了消息后，才释放这些对象。我们可以通过给NSGarbageCollector发送<code>collectIfNeeded</code>消息来启动垃圾收集器。</p><h5 id="drain"><a href="#drain" class="headerlink" title="drain"></a>drain</h5><p><code>- (void) drain</code></p><ul><li>在引用计数内存管理中drain方法和release方法具有同样功能即释放自动释放池。</li><li>在垃圾回收内存管理中，drain方法表示申请垃圾回收，与collectIfNeeded方法有相同功能。</li></ul><h3 id="七、属性"><a href="#七、属性" class="headerlink" title="七、属性"></a>七、属性</h3><p>访问方法的目标一般被称为属性，属性可以用点操作符访问方法，只要定义了访问方法就可以用点操作符。</p><h5 id="显示声明"><a href="#显示声明" class="headerlink" title="显示声明"></a>显示声明</h5><p><code>@property (指令) int hitPoint</code> ：声明属性，一行可多个<br><code>@synthesize hitPoint</code>：在实现中可以自动生成getter和setter方法 一行可声明多个<br><code>@dynamic</code>:告诉编译器自动合成无效。</p><h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><p>原子性是多线程的一个概念<br>原子的（atomic）：多线程环境下访问属性是安全的，在执行过程中不会被打断。<br>非原子的（nonatomic）：访问方法在执行过程中可以被打断。缺省情况下访问方法是原子的。</p><h3 id="八、NSObject"><a href="#八、NSObject" class="headerlink" title="八、NSObject"></a>八、NSObject</h3><p>根类相当于运行时系统的一个接口。继承了NSObject的所有类都可以使用运行时系统的功能。<br>有很大方法具体参考书。</p><h5 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h5><p>IMP：implementation的缩写，一个OC函数指针，IMP定义为：<br><code>typedef id (*IMP)(id,SEL,….);</code></p><p>函数指针指向函数代码首地址。函数指针可以复制给变量或数组，可以以作为气体函数的参数。</p><ul><li><p>声明一个函数指针：<br><code>int (*p)(double,int *);</code></p></li><li><p>指向一个定义好的函数<br><code>int (*p)(double,int *)  = &amp;funcA ;</code> &amp; 可省略</p></li><li><p>调用指针<br><code>x = (*p)(1.42,&amp;error);</code>也可以像调用函数一样使用p(1,42,&amp;error);</p></li></ul><p>可以使用typedef来定义一个函数指针类型：<br><code>typedef int (*t_fuc)(double,int *);</code><br>其中 t_func 为新的类型名，可以用<code>t_func p</code>形式来声明指针变量。</p><h3 id="九、Foundation常用类"><a href="#九、Foundation常用类" class="headerlink" title="九、Foundation常用类"></a>九、Foundation常用类</h3><p>  对数据区分可变和不可变类，原因是从实现复杂度方面考虑。如果数据结构是可变的那么开始就应该设计好操作对应的数据结构和方法。</p><ul><li>可变对象的生成<br>可变类是其不可变类的子类，所以可变类可以当做不可变对象的实列变量来用，于此相反不可变对象不能当做可变对象来用。<br>用不可变对象创建可变副本用方法<code>- (id) mutableCopy</code></li></ul><h5 id="NSString-主要方法"><a href="#NSString-主要方法" class="headerlink" title="NSString 主要方法"></a>NSString 主要方法</h5><h6 id="Unicode编码："><a href="#Unicode编码：" class="headerlink" title="Unicode编码："></a>Unicode编码：</h6><ul><li>-(id) initWithUTF8String: (const char *) bytes:用以UTF－8编码的NULL结束的C字符串中复制信息生成NSString对象。</li><li>-(__ strong const char *) UTF8String : 返回以UTF8编码NULL结尾的C字符串指针。</li><li>-(NSUInteger) length:返回NSString中Unicode字符个数。</li><li>-(unichar) characterAtIndex:(NSUInteger) index:返回索引位置的字符。</li><li>-(id) initWithCharacters : (const unichar *) characters length:(NSUInterger ) length:用characters指针指向的长为length的字符串初始化并返回一个NSString对象。</li><li>-(void) getCharacters: (unichar *) buffer range:(NSRange) aRange:把NSString的范围为aRange的字符串写入buffer里。</li></ul><h6 id="编码转换：C风格或字节类型的字符串和NSString之间可以相互转换。"><a href="#编码转换：C风格或字节类型的字符串和NSString之间可以相互转换。" class="headerlink" title="编码转换：C风格或字节类型的字符串和NSString之间可以相互转换。"></a>编码转换：C风格或字节类型的字符串和NSString之间可以相互转换。</h6><ul><li>-(id) initWithCString: (const char *) nullTerminatedCString encoding: (NSStringEncodeing) encoding :用C字符串初始化一个NSString对象，C风格字符串编码方式为encoding。</li><li>-(__strong const char *) cStringUsingEncoding:(NSStringEncoding) encoding :把一个NSString用encoding编码返回一个C风格字符串。</li><li>-(id ) initWithData: (NSData *) data encoding: (NSStringEncoding) encoding : 用NSData 中的二进制初始化NSString对象。 data中二机制编码为encoding返回NS     `     ｀String对象编码是Unicode。</li><li>-(BOOL) canBeConvertedToEncoding: (NSStringEncoding) encoding : 测试NSString能否转换为encoding编码。</li></ul><h6 id="生成指定格式的字符串"><a href="#生成指定格式的字符串" class="headerlink" title="生成指定格式的字符串"></a>生成指定格式的字符串</h6><ul><li>-(id) initWithFormat: (NSString *) format,… : 生成NSString 用类似C中printf()的方式。</li></ul><h6 id="NSString-比较方法"><a href="#NSString-比较方法" class="headerlink" title="NSString 比较方法"></a>NSString 比较方法</h6><ul><li>-(NSComparisonResult) compare:(NSString *) aString : 触发 - compare:options:range:locale: 函数且options 为nil，range字符串全部范围，locale为nil。结果返回NSComparsonResult 包括NSOrderedAscending 、Same、Descending，比较词汇值大小。</li><li>-(NSComparisonResult) caseInsensitiveCompare:(NSString *) aString :不区分大小写的比较</li><li>-(NSComparisonResult) localizedStandardCompare: (NSString *) aString :按照Mac的Finder排序规则排序。</li><li>-(BOOL) isEqualToString: (NSString *) aString :比较两个String是否相等。</li><li>-(BOOL) hasPrefix: (NSString *) aString : 检查是否以aString开头用-hasSuffix:判断是否以字符串结尾。</li></ul><h6 id="为字符串追加内容"><a href="#为字符串追加内容" class="headerlink" title="为字符串追加内容"></a>为字符串追加内容</h6><ul><li>-(NSString <em>) stringByAppendingString: (NSString </em>) aString: 在接收者字符串后加上aString，返回新字符串。</li><li>-(NSString <em>) stringByAppendingFormat: (NSString </em>) format: 接字符串并返回新字符串，接的字符串格式由format指定。</li></ul><h6 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h6><ul><li>-(NSString *) substringToIndex:(NSUInteger) anIndex :截取从头到index的字符串返回新的copy</li><li>-(NSString *) substringFromIndex: (NSUInteger) anIndex:  截取从index到结尾字符串</li><li>-(NSString *) substringWithRange: (NSRange) aRange: 返回新字符串，为接收字符串range的位子的子字符串</li></ul><h6 id="检索置换"><a href="#检索置换" class="headerlink" title="检索置换"></a>检索置换</h6><ul><li>-(NSRange) rangeOfString: (NSString *) aString:查找aString如果存在返回其位置range，否则返回NSNotFound</li><li>-(NSString <em>) stringByReplacingCharactersInRange: (NSRange) range withString: (NSString </em>) replacement: 替换range内容为replacement</li><li>-(NSString <em>) stringByReplacingOccurrencesOfString: (NSString </em>) target withString: (NSString *) replacement:替换target为replacement</li></ul><h6 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h6><ul><li>-lowercaseString,-uppercaseString：用于将字符串全部转化为大小写</li><li>-capitalizedString: 将所有单词首字母大写，其它字母小写</li></ul><h6 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h6><ul><li>-doubleValue, -floatValue, -intValue, -integerValue, -boolValue： 返回对应类型值</li></ul><h6 id="路径处理"><a href="#路径处理" class="headerlink" title="路径处理"></a>路径处理</h6><ul><li>-(NSString *) lastPathComponent: 文件路径中最后一部分</li><li>-(NSString <em>) stringByAppendingPathComponent: (NSString </em>) aStr : 将aStr加到字符串末尾返回</li><li>-(NSString *) stringByDeletingLastPathComponent: 删除最后一个部分</li><li>-(NSString *) pathExtension : 返回文件扩展名</li><li>-(NSString <em>) stringByAppendingPathExtension: (NSString </em>) aStr , -(NSString *) stringByDeletingPathExtension :操作扩展名</li><li>-(BOOL) isAbsolutePath : 判断是否是绝对路径</li><li>+(BSString <em>) pathWithComponents: (NSArray </em>) components:使用components中的元素来构建路径，自动添加路径分隔符“／”</li><li>-(NSArray *) pathComponents : 将路径的各个部分放入数组中。</li></ul><h6 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h6><ul><li>-(id) initWithContentsOfFile: (NSString *) path encoding: (NSStringEncoding) enc error: (NSError **) error : path中的内容来初始化一个NSString，文件编码enc。读取文件失败会释放调用者,并返回nil的同时将错误信息写入error。</li><li>-(Bool) writeToFile: (NSString *) path atomically: (BOOL) useAuxiliaryFile encoding: (NSStringEncoding) enc error:(NSError **) error : 将字符串写入以path为路径的文件中，useAuxiliaryfile为Yes则先新建临时文件写入，这样可以不损坏原文件。</li></ul><h5 id="NSData-Cocoa对2进制的封装，包括指向2进制的C指针和2进制数据长度"><a href="#NSData-Cocoa对2进制的封装，包括指向2进制的C指针和2进制数据长度" class="headerlink" title="NSData(Cocoa对2进制的封装，包括指向2进制的C指针和2进制数据长度)"></a>NSData(Cocoa对2进制的封装，包括指向2进制的C指针和2进制数据长度)</h5><ul><li>-(id) initWithBytes: (const void *) bytes length: (NSUInteger) length:复制以bytes开头、长度为length的数据。</li><li>-(id) initWithData: (NSData *) aData: 用指定的NSData对象aData来创建一个新NSData对象。</li><li>-(NSUInteger) length:返回数据长度</li><li>-(const void *) bytes:返回数据C指针</li><li>-(void) getBytes:(void <em>) buffer length:(NSUInteger) length, -(NSData </em>) subdataWithRange: (NSRange) range:取得部分data数据</li><li>-(BOOL) isEqualToData : (id) anObject:比较恋歌NSData是否一样</li><li>-(NSString *) description:返回ASC2格式字符串，采用NSData属性列表格式。</li><li>-(id) initWithContentsOfFile:(NSString *) path options: (NSUInteger) mask error: (NSError **) errorPtr:从path指定文件读入二进制数据，mask用于指定是否使用虚拟内存。</li><li>-(BOOL) writeToFile: (NSString *) path atomically:(BOOL) flag:将二进制写入path指定的文件中，flag用于写安全操作。</li></ul><h5 id="数组-NSArray-NSMutableArray"><a href="#数组-NSArray-NSMutableArray" class="headerlink" title="数组 NSArray,NSMutableArray"></a>数组 NSArray,NSMutableArray</h5><ul><li>+(id) array:返回一个空的数组对象，NSMutableArray常用这个方法。</li><li>+(id) arrayWithObject:(id) anObject : 返回只包含一个anObject元素的数组。</li><li>-(id) initWithObjects: (id) firstObj,…. : 返回包含objects的数组。</li><li>-(id) initWithArray:(NSArray *) anArray: 用anArray初始化一个新数组。</li><li>-(NSUInteger) count:数组元素个数</li><li>-(NSUInteger) indexOfObject: (id) anObject : 查看是否有与anObject相等的元素，如有返回索引，否则NSNotFound。</li><li>-(id) objectAtIndex: (NSUInteger) index: 返回index处的元素。</li><li>-(id) lastObject, -(id) firstObject: 访问元素。</li><li>-(void) getObjects: (id __unsafe_unretained []) aBuffer range:(NSRange) aRange:将aRange指定范围内对象复制到aBuffer指定的C语言缓冲区。只复制指针，引用计数不发生变化。</li><li>-(NSArray *) subarrayWithRange: (NSRange) range: 抽取原数组一部分生成新的子数组。</li><li>-(BOOL) isEqualToArray: (id) anObject : 比较两个数组是否一致。</li><li>-(id) firstObjectCommonWithArray: (NSArray *) otherArray : 返回第一个两个数组相同的元素。</li></ul><h6 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h6><ul><li>-(NSArray <em>) sortedArrayUsingSelector:(SEL) comparator, -(NSArray </em>) sortedArrayUsingFunction: (NSInteger(<em>) (id,id,void </em>))comparator context: (void *)context :排序方法，第一个用数列内元素自身有的排序方法，如果自己设计要用范畴（category）第二个用函数指针，只要把函数名称传入就可以了。比较方法要返回NSCompareResult用于数组排序，排序结果是之前数组元素引用的数组，没有拷贝。NSCompareResult是NSUInteger的别名，三个量为-1,0,1。<h6 id="给数组各元素发消息"><a href="#给数组各元素发消息" class="headerlink" title="给数组各元素发消息"></a>给数组各元素发消息</h6></li><li>-(void) makeObjectsPerformSelector:(SEL) aSelector:</li><li>-(void) makeObjectsPerformSelector:(SEL) aSelector withObject: (id) anObj:给每一个元素发消息带一个参数<h6 id="返回枚举器"><a href="#返回枚举器" class="headerlink" title="返回枚举器"></a>返回枚举器</h6></li><li>-(NSEnumerator <em>) objectEnumerator, -(NSEnumerator </em>) reverseObjectEnumerator</li></ul><h5 id="枚举器NSEnumerator"><a href="#枚举器NSEnumerator" class="headerlink" title="枚举器NSEnumerator"></a>枚举器NSEnumerator</h5><p>用来遍历集合类中元素对象的抽象类，除了for..in 语法外其也可以便利，不能创建实列，只能用集合对象返回的枚举对象。</p><ul><li>-(id) nextObject:用来遍历每个集合元素。</li><li>-(NSArray *) allObjects:返回集合中未被便利的元素的数组。<br>使用枚举器的例子：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSArray *myarray;</span><br><span class="line">id obj;</span><br><span class="line">NSEnumerator *enumerator;</span><br><span class="line">enumerator = [myarray objectEnumerator];</span><br><span class="line">while((obj = [enumerator nextObject]) != nil)&#123;</span><br><span class="line">/* operations*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="NSSet-NSMutableSet"><a href="#NSSet-NSMutableSet" class="headerlink" title="NSSet NSMutableSet"></a>NSSet NSMutableSet</h5><ul><li>+(id) set :返回一个临时的空的集合对象。</li><li>-(id) initWithArray: (NSArray *) array: 用array中元素初始化一个集合，相同元素只保留一个。</li><li>-(NSArray *) allObjects:将所有元素以数组形势返回。</li><li>-(BOOL) containsObject: (id) anObject:判断是否有指定元素。</li><li>-(BOOL) intersectsSet: (NSSet *) otherSet:判断是否有共同元素</li><li>-(void) unionSet: (NSSet *) otherSet:将otherSet融合到当前MutableSet中去。</li></ul><h6 id="NSDictionary-NSMutableDictionary"><a href="#NSDictionary-NSMutableDictionary" class="headerlink" title="NSDictionary NSMutableDictionary"></a>NSDictionary NSMutableDictionary</h6><ul><li>+(id) dictionaryWithObject: (id) anObject forKeys: (id) aKey :返回一个词典对象，只有一个键值对。</li><li>-(id) initWithObjects: (NSArray <em>) objects forKeys: (NSArray </em>) keys:用两个数组初始化。</li><li>-(id) initWithObjectsAndKeys: (id) object, (id) key,… : 用值和键初始化。</li><li>-(id) objectForKey: (id) aKey:访问对应值</li><li>-(NSArray *) allKeys: 返回一个包含所有对象键的数组。</li><li><p>-(NSEnumerator *) keyEnumerator:返回枚举器</p></li><li><p>-(void) setObject: (id) anObject forKey: (id) aKey:向可变字典中添加元素。</p></li><li>-(void) addEntriesFromDictionary: (NSDictionary *) otherDic:将otherDic中数据添加到当前字典中，有重复以otherDic为准</li><li>-(void) removeObjectForKey: (id) aKey:删除一个项</li><li>-(void) removeObjectsForKeys: (NSArray *) keyArray:删除keyArray中的项</li><li>-(void) removeAllObjects:删除全部</li></ul><h5 id="包裹类"><a href="#包裹类" class="headerlink" title="包裹类"></a>包裹类</h5><h6 id="NSNumber"><a href="#NSNumber" class="headerlink" title="NSNumber"></a>NSNumber</h6><p>包裹C基本数据类型</p><ul><li>-(id) initWith元素类型：(类型) value：初始化方法</li><li>-(类型) 类型Value: 获取值的访问方法。</li></ul><h6 id="NSValue"><a href="#NSValue" class="headerlink" title="NSValue"></a>NSValue</h6><p>用于包裹指针，结构体等数据。</p><ul><li>-(id) initWithBytes: (const void <em>) value objCType: (const char </em>) type:包裹结构体方法 objCType用@encode(结构体)取得。＃</li></ul><h6 id="NSNull"><a href="#NSNull" class="headerlink" title="NSNull"></a>NSNull</h6><p>包裹null</p><h5 id="NSURL"><a href="#NSURL" class="headerlink" title="NSURL"></a>NSURL</h5><ul><li>-(id) initWithString: (NSStrirng *) URLString :初始化方法。</li><li>-(BOOL) getResourcceValue: (out id <em>) value forKey: (NSString </em>) key error: (out NSError **) error:获取NSURL表示文件的属性，如大小、修改时间，权限等。</li></ul><h3 id="十、范畴"><a href="#十、范畴" class="headerlink" title="十、范畴"></a>十、范畴</h3><h5 id="范畴"><a href="#范畴" class="headerlink" title="范畴"></a>范畴</h5><p>实现某个类一部分方法的模块叫做范畴或类别(category)，包括接口文件和类文件实现，但范畴不能声明实列变量。其声明语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface 类名 ( 范畴名 )</span><br><span class="line">／＊ 方法＊／</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation 类名 （范畴名）</span><br><span class="line">／＊实现＊／</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>oc中吧关系紧密的方法们作为一个范畴来分类。把类按照范畴分类，和C中把某些函数保存在同一个文件中相似。把实现方法互相依赖或公用同一个局部变量的方法定义为范畴，则类中依赖性较高的一部分会被归纳出来，开发也会容易。</li></ul><h5 id="关联引用"><a href="#关联引用" class="headerlink" title="关联引用"></a>关联引用</h5><p> 通过关联引用可以为已经存在的对象增加实列变量，这个功能叫做关联引用。与范畴组合起来可以实现对类的动态扩展。</p><ul><li>void objc_setAssociatedObject(id object, void *key, id value, object_AssociationPolicy policy):为对象object添加以key指定的地址作为关键字、以value为值的关联引用。</li><li>id objc_getAssociatedObject(id object, void *key): 返回object以key为关键字的对象。</li><li>void objc_removeAssociatedObjects(id object) : 断开object的所有关联。</li></ul><h5 id="类扩展（extension）"><a href="#类扩展（extension）" class="headerlink" title="类扩展（extension）"></a>类扩展（extension）</h5><p>类扩展声明可以扩展变量和方法，扩展中声明的实列变量只能在引入类主接口可扩展声明的范畴中使用。声明和范畴相似，只是圆括号之际没有文本，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface Card ()&#123;</span><br><span class="line">     BOOL flag;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL) hasSameSuit;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h5 id="可变参数方法的定义-OC同C／C＋＋"><a href="#可变参数方法的定义-OC同C／C＋＋" class="headerlink" title="可变参数方法的定义 OC同C／C＋＋"></a>可变参数方法的定义 OC同C／C＋＋</h5><p>类似printf() 可变参数函数定义方法，OC与C和C＋＋都是相同的，首先有如下限制：</p><ul><li>参数猎豹中不能只有可变参数</li><li>可变参数必须出现在参数列表最后</li><li><p>可变参数类型必须由程序来管理</p><p>定义可变参数函数时先引入头文件stdarg.h。用…表示可变参数。获取可变参数前需要定义一个va_list类型变量。代码如下：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">va_list pvar;</span><br><span class="line">va_start(pvar, 可变参数前一个变量名);</span><br><span class="line">f = va_arg(pvar , 类型名 );</span><br><span class="line">va_end(pvar );</span><br></pre></td></tr></table></figure><p>va_start() 为访问可变参数进行准备，va_arg()获取参数值，va_end()关闭paar指针。</p><h3 id="十一、抽象类、类簇"><a href="#十一、抽象类、类簇" class="headerlink" title="十一、抽象类、类簇"></a>十一、抽象类、类簇</h3><ul><li><p>OC在语法上没有特别的机制来区分抽象类。</p></li><li><p>类簇就是定义相同的接口并提供相同功能的一组类的集合。类簇有一个机制，可以从多个已存在的类中挑选出最适合当前场景的类并启用。Foundation框架的类基本都是类簇。</p></li></ul><h3 id="十二、协议"><a href="#十二、协议" class="headerlink" title="十二、协议"></a>十二、协议</h3><p>表示对象作用和行为的方法集合体称为协议。<br>协议声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@protocol 协议名</span><br><span class="line">/* 内容*/</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>协议的采用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface 类名 ：父类名 &lt;协议名&gt;｛</span><br><span class="line">／＊内容＊／</span><br><span class="line">｝</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>协议继承：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@protocol 协议1 &lt;协议2&gt;</span><br><span class="line">／＊内容＊／</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>指定协议类型声明：<br><code>id &lt;S&gt; obj;</code></p><p>协议适用性检查:</p><ul><li>-(BOOL) conformsToProtocol: (Protocol *) aProtocol: 接收者与aProtocol指定协议适用是返回，YES</li></ul><p>必选功能和可选功能：<br>在函数前用@optional 和@required表示可选和必选。</p><h3 id="十三、对象的复制和存储"><a href="#十三、对象的复制和存储" class="headerlink" title="十三、对象的复制和存储"></a>十三、对象的复制和存储</h3><ul><li>指针复制：变量A指向一个对象，把变量A复制到变量B时，只是指针赋相同值，是对象代入到变量。</li><li>浅复制：将变量A指向的对象复制一份，让B指向复制对象。不继续递归复制，对象内的实列变量用指针共享。</li><li>深复制：使B指向的对象递归的复制A对象的所有内容。</li></ul><h5 id="归档"><a href="#归档" class="headerlink" title="归档"></a>归档</h5><p>Foundation框架中，可以把相互关联的多个对象归档为二进制文件，还能将对象的关系从二进制文件中还原回来。这个过程称为归档和解档。<br>可以使用NSKeyedArchiver和NSKeyedUnarchiver完成归档和解档，他们都是NSCoder的子类。<br>所有可以归档的对象都必须要适用于协议NSCoding。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@protocol NSCoding</span><br><span class="line">- (void) encodeWithCoder: (NSCoder *) aCoder;</span><br><span class="line">- (id) initWithCoder: (NSCoder *) aDecoder;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>编解码方法：</p><ul><li>-(void) encodeObject: (id) objv forKey: (NSString *) key:用字符串作为键编码对象。</li><li>-(void) encodeConditionalObject: (id) obj forKey: (NSString *) key: 需要时编码。</li><li>-(void) decodeObjectForKey: (NSString *) key:还原编码对象。</li></ul><h5 id="属性列表"><a href="#属性列表" class="headerlink" title="属性列表"></a>属性列表</h5><p>属性列表(property list) 是Cocoa中表示或保存信息的标准数据形式。可以将数组、词典、字符串、数据保存在文件中。</p><ul><li><p>ASCII 字符串属性列表：<br>对NSArray和NSDictionary发生description消息获得NSString中的ASCII属性列表<br>对 NSString发送 <code>- (id) propertyList</code> 消息返回对应对象结构</p></li><li><p>XML 格式属性列表<br>对NSArray或NSDictionary实列使用方法<code>writeToFile:atomically:</code>可以获得XML格式属性列表<br>使用方法<code>initWithContentsOfFile:</code>从属性列表中恢复数据</p></li></ul><p>属性列表转换：</p><ul><li>+(NSData *) dataWithPropertyList: (id) plist format: (NSPropertyListFormat) format options: (NSPropertyListWriteOptions) opt error: (NSError **) error: 参数plist是要转换的对象（数组、字典）将他转换为指定属性列表格式(XML或二进制)。</li><li>+(id) propertyListWithData: (NSData <em>) data options: (NSPropertyListReadOptions) opt format: (NSPropertyListFormat </em>) format error: (NSError **) error :从存储者任意种格式的属性列表的数据对象中将对象结构复原。</li></ul><h3 id="十四、块对象、闭包"><a href="#十四、块对象、闭包" class="headerlink" title="十四、块对象、闭包"></a>十四、块对象、闭包</h3><ul><li>声明和定义：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void (^b) (int) = ^&#123;参数&#125;&#123;实现&#125;；</span><br></pre></td></tr></table></figure></li></ul><p>闭包块的声明和函数指针使用相同的书写方法，只是函数指针声明使用＊，块对象使用^。</p><ul><li><p>类型声明：<br>用typedef声明类型简化代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef int (^myBlockType) (int);</span><br><span class="line"></span><br><span class="line">void func (myBlockType block)&#123;</span><br><span class="line">     /*...*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>块对象中的变量行为</p></li><li><p>块句法中，除块句法内部的局部变量和形参外，还有块句法位置处可以访问的变量。其中有外部变量和局部变量，即捕捉到的附近的变量。</p></li><li>块内部可以访问外部变量和静态变量，也可以直接改变变量值。</li><li><p>在书写块句法时，局部变量会被保存起来所以即使之后局部变量值改变块对象也不知道，变量值可以读取不能改变，变量不能为数组，否则报错。</p></li><li><p>和函数指针的区别：<br>使用函数指针，需要不同函数应对不同功能，为给函数传递附加信息，还要用多余的参数，不能使代码简单独立。<br>闭包块有捕获上文变量的功能，所以可以少传递不传递参数，使用灵活。</p></li><li><p>块的循环引用<br>在ARC内存管理下当块变量出现循环强引用时会发生内存泄漏，使用<code>_ _ weak Logger *weakLog = logger;</code> weak修饰符表示若引用来解决循环强引用问题。</p></li></ul><h5 id="一些实用块的方法"><a href="#一些实用块的方法" class="headerlink" title="一些实用块的方法"></a>一些实用块的方法</h5><p>NSArray中有一个排序方法：</p><ul><li>-(NSArray *) sortedArrayUsingComparator: (NSComparator) cmptr; NSComparator 是一个闭包的别名<code>typedef NSComparisonResult (^NSComparator) (id obj1, id obj2);</code></li><li>-(NSUInteger) indexOfObjectPassingTest: (BOOL (^) (id obj, NSUInteger idx, BOOL *stop)) predicate:实现从数组返回满足块对象指定条件的最初元素索引。当stop为YES是可以打断循环。<br>NSDictionary中遍历方法：</li><li>-(void) enumerateKeysAndObjectsUsingBlock: (void (^) (id key, id obj , BOOL *stop)) block:遍历键值对象，操作。</li></ul><h4 id="块的值捕获"><a href="#块的值捕获" class="headerlink" title="块的值捕获"></a>块的值捕获</h4><p>我们把闭包引用，读取外部变量称为捕获。</p><ul><li>块内部可以识别块内部的变量和块当前位置可以访问的外部变量。</li><li>块对象内部可以访问全局变量和静态变量，可以改变变量值。</li><li>虽然可以在内部访问块外部的自动变量值，但不可以给变量赋值。</li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>MIT6.006_DataStructureAndAlgorithms</title>
      <link href="/2016/06/05/MIT6-006-DataStructureAndAlgorithms/"/>
      <url>/2016/06/05/MIT6-006-DataStructureAndAlgorithms/</url>
      <content type="html"><![CDATA[<h4 id="lecture-2"><a href="#lecture-2" class="headerlink" title="lecture 2:"></a>lecture 2:</h4><p>Document  distance problem : d(D1,D2)?<br>-document = sequence of words.<br>-word = string of chars.<br>distance : look at the shared words</p><h4 id="lecture3-binary-search"><a href="#lecture3-binary-search" class="headerlink" title="lecture3:binary search"></a>lecture3:binary search</h4><h4 id="4-Heap-and-heap-sort"><a href="#4-Heap-and-heap-sort" class="headerlink" title="4.Heap and heap sort"></a>4.Heap and heap sort</h4><p>Heap also called priority queue , its the implementation of a priority queue,and by putting the elements of this queue into a tree we have heap, the relation of array index in the tree is as follow:<br>     1.root :first element<br>     2.parent(i)  = floor(i/2);//index of i<code>s parent     3.left(i) = 2i + 1; right(i) = 2i;     //index of i</code>s children</p><p>heap property:</p><ul><li>Max heap: for every node i : <code>A[parent(i)] &gt;= A[i] ;</code></li><li>Min heap: for every node i: <code>A[parent(i)] &lt;= A[i] ;</code></li></ul><h5 id="Max-heapify-A-i"><a href="#Max-heapify-A-i" class="headerlink" title="Max_heapify(A,i):"></a>Max_heapify(A,i):</h5><p>Assume that the tree rooted at left(i) and right(i) are maxheap check the value of element i and left(i) right(i) exchange the largest with element i</p><h5 id="max-Heap"><a href="#max-Heap" class="headerlink" title="max Heap:"></a>max Heap:</h5><p>the key of a node is &gt;= the keys of its children<br>build max-Heap(A):</p><pre><code>for i =n/2 down to 1      //here [n/2 - n] is all leaves as is tree`s propertydo max_heapify(A,i);</code></pre><h5 id="heap-sort"><a href="#heap-sort" class="headerlink" title="heap sort:"></a>heap sort:</h5><p>1.build max_heap from unordered array<br>2.find A[i] which is the top element<br>3.swap element A[n] with A[1] and the max element is at the end of the array<br>4.discard node A[n] from the heap by decrementing heap size<br>5.new root may violate max property but its children are max heap so run max_heapify the tree<br>6.goto step 2<br><a id="more"></a></p><h4 id="5-Binary-Search-Tree-BST-in-order-by-building-the-tree-from-array"><a href="#5-Binary-Search-Tree-BST-in-order-by-building-the-tree-from-array" class="headerlink" title="5.Binary Search Tree:BST in order by building the tree from array"></a>5.Binary Search Tree:BST in order by building the tree from array</h4><h5 id="PROPERTY"><a href="#PROPERTY" class="headerlink" title="PROPERTY:"></a>PROPERTY:</h5><p>For all node x, if y is in the left subtree of x then val(y) &lt;= val(x);<br>If y is in the right subtree of x then val(y) &gt;= val(x);</p><h5 id="INSERTION-with-check-o-h-time-with-h-equals-to-the-hight-of-the-tree"><a href="#INSERTION-with-check-o-h-time-with-h-equals-to-the-hight-of-the-tree" class="headerlink" title="INSERTION with check: o(h) time with h equals to the hight of the tree"></a>INSERTION with check: o(h) time with h equals to the hight of the tree</h5><p>Operations:<br>     find-min():go to the left with o(h);<br>     find-max():go to the right with o(h);                             </p><p>5.recitation:Augment the BTS structure:<br>data structure: a bunch of algorithms that help you store and retrieve information          </p><p>queries : MAX,Min,Next-larger,Search  //ask questions to the data structure and it dose not change<br>updates: Insert,Delete  </p><p>check RI(representation invariant):check the entire data structure and make sure the RI holds, if it dose not it raise an exception                                                      </p><p>Next-Larger:given a node find the next node which is just larger then this node but smaller then any other node<br>1.go to the right node of the given node.<br>2.go all the way left in this sub tree to find the smallest<br>3.if the given node does not have a right sub tree then the next-larger will be:<br>if given node is the left child of his parent then his parent node  will be<br>if given node is the right child then no next-larger          </p><p>Deletion:to delete one node ,first the the next-larger of this node, then replace the node you want to delete with the next-larger node. //1.set the value of node to delete to the value of the next larger, 2. delete the next larger.</p><h4 id="lecture-6-ALV-tree-ALV-sort"><a href="#lecture-6-ALV-tree-ALV-sort" class="headerlink" title="lecture 6. ALV tree,ALV sort"></a>lecture 6. ALV tree,ALV sort</h4><p>hight of BST:length of the longest path,in a balanced tree o(log n);<br>hight of a node:length of the longest path from it down to a leaf;<br>Compute the length of a node : Max(length(node.left),length(node.right)) + 1;</p><p>AVL Trees<br>AVL property：require hight of left and right children of every node to differ by at most 1;</p><p>Nh = min. #nodes in an AVL tree of hight h;<br>Nh = 1 + Nh-1(number of nodes in the right sub tree)+ Nh-2( number of nodes in the left sub tree)<br>Nh = 1 + Nh-1 + Nh-2 &gt;1 + 2<em>Nh-2 &gt; 2</em>Nh-2 = o(2^(h/2))<br>so =&gt; h &lt; 2 <em>lgN and the exact result is 1.44 </em> lgN calculated by the fibonacci series bound</p><p>AVL Insertion</p><ul><li>simple  BST insertion</li><li><p>fix AVL property from change node up</p></li><li><p>suppose x is lowest node violating AVL</p></li><li>assume x.right higher</li><li>if x`s right child is right-heavy or balanced right rotate x</li><li>else if right child is left-heavy right rotate x`s right child ad left rotate x;</li></ul><p>Rotation:<br>left rotate:roof goes to the left<br>right rotate:roof goes to the right</p><p>AVL sort:</p><ul><li>do AVL insert to insert the n items of the array which needs to be sorted; o(n*log n )</li><li>do inorder traverse to get the sorted array;   ;o(n)</li></ul><p>AVL rep invariant:</p><ul><li>BST</li><li>for any node  | hr - hl|&lt;=1;</li></ul><h4 id="lecture-7"><a href="#lecture-7" class="headerlink" title="lecture : 7"></a>lecture : 7</h4><ul><li>comparison model</li><li>lower bounds<ul><li>searching: o(lgn)</li><li>sorting : o(n * lgn)</li></ul></li><li>o(n) sorting algorithms<ul><li>counting sort</li><li>radix sort</li></ul></li></ul><p>Comparison Model</p><ul><li>all input items are black boxes (abstract data structure )</li><li>only operation allowed are comparisons</li><li>time cost = # comparison</li></ul><p>Decision Tree<br>     any comparison algorithm can be viewed as a tree of all possible comparisons and their outcomes and resulting answers,for any particular n item<br>e.g. binary search algorithm with n =3</p><table><thead><tr><th>decision tree</th><th>algorithm</th></tr></thead><tbody><tr><td>internal node</td><td>binary decisions</td></tr><tr><td>leaf</td><td>found answer</td></tr><tr><td>root to leaf</td><td>algo execution</td></tr><tr><td>length of path</td><td>running time</td></tr><tr><td>the hight of the tree</td><td>worst running time</td></tr></tbody></table><p>Searching lower bound<br> n preprocessed items , finding a given item among them in comparison model require  o(lgn) in worst case,for lgn<br>is the tree which have the lowest hight and maximum nodes when you look at the decision tree.</p><p>Sorting lower bound<br>  number of  leaves &gt;= number of  possible answers n!<br>     hight &gt;= n! &gt;= n *lgn</p><p>Counting Sort : o(n+k)</p><ol><li>initialize an array with length the maximum value +1 of the ints you want to sort</li><li>iterate all the values of the ints increment the array with the subscription identical to the values of the ints</li><li><p>output the values of the array,output value is the subscription of the array and number of value equals to the value of the specific value of</p><pre><code>L:array of K empty listsfor i in range(n);     L(key(A[j])).append(A[j]);outPut = [];for i in range(K);     outPut.extend(L[i]);</code></pre></li></ol><p>counting sort:with position array</p><pre><code>sum = k // length of the original array which is the ints to be sorted;for i =k-1 to 0     pos[i] = sum - pos[i];//in place changing from the counting array got above to the position array , start with pass0     sum = pos[i]       //end with pass1out = [  ];for i = 0 to k-1     out[pos[a[i]]] = a[i]; // a[i] is the array needs to be sorted ,basically a[i] value refers to pos`s index and pos`s value refer to out[]`s index     pos[a[i]] = pos[a[i]] + 1; //by incrementing pos[]</code></pre><p>property stable: counting sort will items to be sorted the same way as they are unsorted if the items are identical, it does not break the relative relationship  between items if they are the same. stable algorithm is important because in some context,some complex obj will be mapped to numbers and maybe two different obj have the same number. So we want to keep the relative order of the object the same after sorting, if they are mapped to the same numbers.</p><p>Radix Sort: d rounds of counting sort             </p><ul><li>imagine each integer as  base b</li><li>#digits = d = logb K</li><li>sort ints by  the least significant digit using counting sort<br>……</li><li>sort  by the least significant digit  to the most significant digit using counting sort<br>total time : o(n* logn K);</li></ul><h5 id="lecture-8-Hashing"><a href="#lecture-8-Hashing" class="headerlink" title="lecture 8 Hashing"></a>lecture 8 Hashing</h5><ul><li>Dictionary</li><li>Motivation</li><li>Prehashing</li><li>Hashing</li><li>Chaining</li><li>Simple Uniforme Hashing</li><li>Good Hash Function</li></ul><h6 id="Dictionary-abstract-data-type"><a href="#Dictionary-abstract-data-type" class="headerlink" title="Dictionary : abstract data type"></a>Dictionary : abstract data type</h6><p>maintain a set of items with each item mapped with a key</p><ul><li><code>insert(item);</code> :will overwrite any existing key</li><li><code>delete(item);</code></li><li><code>search(key);</code> : return the item of the given key or report error</li></ul><h6 id="python-dict"><a href="#python-dict" class="headerlink" title="python: dict"></a>python: dict</h6><p>D[key] ~ search<br>D[key] = val ~ insert<br>dele D[key] ~ deletion          </p><p>item = ( key, val )</p><h6 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h6><ul><li>docDict</li><li>database</li><li>interpreter</li></ul><h6 id="simple-approach"><a href="#simple-approach" class="headerlink" title="simple approach:"></a>simple approach:</h6><p>Direct - access table:store items in an array, index by key</p><h6 id="prehasing"><a href="#prehasing" class="headerlink" title="prehasing"></a>prehasing</h6><ul><li>map keys to none negative integers</li></ul><h6 id="hasing"><a href="#hasing" class="headerlink" title="hasing"></a>hasing</h6><ul><li>reduce universe of all keys down to a small set of integers<br>idea :  space m = o(n) ; m is the size of hash table and n is number of keys<br>collision : h(ki) = h(kj) while ki != kj</li></ul><h6 id="chaining"><a href="#chaining" class="headerlink" title="chaining"></a>chaining</h6><p>linked list of colliding elements in each slot of hash table</p><h6 id="hash-functions"><a href="#hash-functions" class="headerlink" title="hash functions"></a>hash functions</h6><ul><li>division method: hash(key)  = key mod m ; m is the size of your hash table</li><li>multiplication: hash(key) = [(a*key) mod 2^w]&gt;&gt; ( w - r ); w is the number of bits of key which means key has w bits , a is a random integer; m = 2^r;</li><li>universal hashing:  hash(key) = [(a*key + b) mod p] mod m; a and b are random numbers {0 …. p-1} ,p is the prime number which is bigger than the universe</li></ul><h5 id="lecture-9-Table-Doubling-Karp-Rabin"><a href="#lecture-9-Table-Doubling-Karp-Rabin" class="headerlink" title="lecture 9 Table Doubling, Karp-Rabin"></a>lecture 9 Table Doubling, Karp-Rabin</h5><ul><li><p>Rolling hash:<br>is a hash function where the input is hashed in a window that moves through the input. One of the main application is Rabin-Karp String search algorithm.</p><ul><li>r.append(c) : add char c to the end of x</li><li>r.skip(c) : delete first char of x</li><li>r() :  hash value of x r() = h(x);<br>ps: through the operation above,  we can move the sliding window of rolling hash through out the text we want to hash and get the hash result fast.</li></ul></li><li><p>Karp - Rabin algorithm<br>using hash function in string matching , using rolling hash to quickly compute the hash of strings to match, if the target and the sample`s hash results matches then check the two strings is the same or not, if not continue otherwise return result.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function RabinKarp(string s[<span class="number">1.</span>.n], string pattern[<span class="number">1.</span>.m])</span><br><span class="line">  hpattern := hash(pattern[<span class="number">1.</span>.m]);  hs := hash(s[<span class="number">1.</span>.m]) //预处理两个hash值</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">from</span> <span class="number">1</span> to n-m+<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> hs = hpattern</span><br><span class="line">      <span class="keyword">if</span> s[i..i+m<span class="number">-1</span>] = pattern[<span class="number">1.</span>.m] // 如果hash值相同且字符串相同则返回结果</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    hs := hash(s[i+<span class="number">1.</span>.i+m]) //否则rolling hash到下一个字节</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">not</span> found</span><br></pre></td></tr></table></figure></li></ul><h4 id="lecture-10-Open-Addressing-cryptographic-Hashing"><a href="#lecture-10-Open-Addressing-cryptographic-Hashing" class="headerlink" title="lecture 10 Open Addressing cryptographic Hashing"></a>lecture 10 Open Addressing cryptographic Hashing</h4><ul><li>Open Addressing</li><li>Uniform hashing analysis</li><li>Cryptographic hashing</li></ul><h5 id="Open-Addressing"><a href="#Open-Addressing" class="headerlink" title="Open Addressing"></a>Open Addressing</h5><p>no chaining to deal with collision<br>M ( slot in the hash table using array) N( numbers of elements)<br>M &gt;= N</p><ul><li>Probing</li></ul><p>meaning when do hashing trying to insert each item to the table,if it fails which means the given key`s item array is full, then recompute the hash using a different hash function.</p><p>Hash function specifies order of slots to probe a key. hash will take U(universe of keys) and C(trial count) to produce keys{1- m-1}</p><p>arbitrary K h(k,1),h(k,2)…….h(k,m-1) to be the permutation of 0 , 1 , 2 ,….m-1 which is the slot in the hash table</p><ul><li><p>Insert(k,v)</p><p>   keep probing until an empty slot is founded including delete me flag and none,insert item when found</p></li><li><p>Search(k)</p><p>   As long as the slots probing encountered are occupied by keys != k ,keep probing until encounter k or find an empty slot which means fails to find k in the keys. If encountered delete me keep on probing.</p></li><li><p>Delete(k)</p><p>   As long as the slots probing encountered are not k, keep probing until encounter k and replace the slot with “delete me”.If encounter empty slot then fails to delete.</p></li></ul><h5 id="Probing-strategies"><a href="#Probing-strategies" class="headerlink" title="Probing strategies"></a>Probing strategies</h5><ul><li><p>linear probing: h(k,i) = ( h<code>(k) + i ) mod m; h</code>(k) is an ordinary hash function<br>problems: not random and cluster. once there is a cluster you have to do more operations that works for nothing</p></li><li><p>double hashing : h(k,i ) = ( h1(k) + i* h2(k) ) mod m;<br>If h2(k) is relatively prime to m then we are certain that h(k,i) will have a permutation</p></li></ul><h4 id="lecture-11-Integer-arithmetic-Karatsuba-Multiplication"><a href="#lecture-11-Integer-arithmetic-Karatsuba-Multiplication" class="headerlink" title="lecture 11. Integer arithmetic , Karatsuba Multiplication"></a>lecture 11. Integer arithmetic , Karatsuba Multiplication</h4><ul><li>Irrationals</li><li>Newton`s Method</li><li>High Precision Multiplication</li></ul><h5 id="Irrationals"><a href="#Irrationals" class="headerlink" title="Irrationals"></a>Irrationals</h5><ul><li><p>Catalan numbers<br>Set P of balanced parentheses strings</p></li><li><p>λ ∈ P (λ is the empty string)</p></li><li>If α ,β ∈ P , then (α)β ∈P</li></ul><h5 id="Newton-s-Method"><a href="#Newton-s-Method" class="headerlink" title="Newton`s Method"></a>Newton`s Method</h5><p>－ Root of f(x) = 0 through successive approximation<br><code>xi+1 = xi  - f(xi) / f</code> (xi) ;`</p><ul><li><p>High precision  multiplication<br>2 n-digits numbers  ( radix r = 2 , 10)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0&lt;= x, y &lt;= r^n ;</span><br><span class="line"></span><br><span class="line">x = x1 * r^(n/2) + x0;     //x1:high half , x0: low half</span><br><span class="line">y = y1 * r^(n/2) + y0;</span><br><span class="line"></span><br><span class="line">0 &lt;= x0,x1 &lt;  r^(n/2);</span><br><span class="line">0 &lt;= y0,y1 &lt;  r^(n/2);</span><br><span class="line"></span><br><span class="line">let</span><br><span class="line">z0 = x0 * y0;</span><br><span class="line">z1 = ( x0*y1 + x1*y0 );</span><br><span class="line">z2 = x2 * y2 ;</span><br><span class="line"></span><br><span class="line">z = x*y = x1*y1*r^n + (x0*y1 + x1*y0) * r^(n/2) + x0*y0</span><br></pre></td></tr></table></figure></li><li><p>karatsuba algorithm<br>for improving the multiplication process<br>z0 = x0 <em> y0;<br>z2 = x2 </em> y2;<br>z1 = (x0 + x1 )* ( y0 + y1) - z0 - z1;</p></li></ul><h4 id="recitation-11-Principal-of-Algorithm-Design"><a href="#recitation-11-Principal-of-Algorithm-Design" class="headerlink" title="recitation 11 Principal of Algorithm Design"></a>recitation 11 Principal of Algorithm Design</h4><ul><li><p>Given a shifted sorted array, find the K element where the biggest mets the smallest number in binary search tree.<br>example:<br>   7, 8 , 9, 1 , 2 , 3 , 4 , 5 , 6</p></li><li><p>the first element, here is 7,is the most important find the first element in binary search.</p></li><li><p>if middle is bigger ,search recursively right,otherwise on the left.(if big find bigger , if small find smaller) to find the point where two subarray joined.</p></li><li><p>Find Kth smallest element in a minimum heap.</p></li></ul><ol><li>because of minimum heap, we can use heap property. Because the root is the smallest element, we use:</li></ol><p><code>A.pop(root);</code></p><p>Kth times to get the element we want in O(K * logN) time because retain heap property requires logN time.</p><ol start="2"><li>First chop heap from root to height K,because all paths of length K end to K level and beyond K the element will always be bigger than K because its a min heap.Then find Kth smallest in the heap recursively. Second, set up a augmented heap called horizon which is the container to do the iteration, each time extract-min from it , fill in the min`s children to replace min for that these are the element to find the next min.</li></ol><p>pseudo code:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">H &lt;- minheap ;</span><br><span class="line">Z &lt;- minheap ; //augmented <span class="keyword">with</span> index of each element to store the min k element</span><br><span class="line">Z.insert( H[<span class="number">1</span>] , <span class="number">1</span> ) ;  //</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>…k)</span><br><span class="line">     (value,index) = Z.extract-min // get out the min element <span class="keyword">and</span> replace <span class="keyword">with</span> its children to compare</span><br><span class="line">     Z.insert( H[<span class="number">2j</span>] , <span class="number">2j</span> );</span><br><span class="line">     Z.insert( H[<span class="number">2j</span> + <span class="number">1</span>] , <span class="number">2j</span> + <span class="number">1</span> );</span><br><span class="line"><span class="keyword">return</span> index;</span><br></pre></td></tr></table></figure></p><p>this gives you O(K * logK) running times.</p><h4 id="lecture-12-Square-Root-Newton-s-Method"><a href="#lecture-12-Square-Root-Newton-s-Method" class="headerlink" title="lecture 12 Square Root, Newton`s Method"></a>lecture 12 Square Root, Newton`s Method</h4><ul><li>Multiplication , Division</li><li>Algorithm Complexity</li></ul><h5 id="High-precision-Division"><a href="#High-precision-Division" class="headerlink" title="High-precision Division"></a>High-precision Division</h5><ul><li>set f(x) = 1/x - b/R ;<br>so when we trying to do f(x) = 0, we will get 1/x = b/R  so x = R/b;<br>applying Newton iteration:<br>Xi+1 = Xi - f(Xi)/f`(Xi) = 2Xi - (b*Xi^2)/R</li></ul><h4 id="Recitation"><a href="#Recitation" class="headerlink" title="Recitation"></a>Recitation</h4><h5 id="Karatsuba-Multiplication"><a href="#Karatsuba-Multiplication" class="headerlink" title="Karatsuba Multiplication"></a>Karatsuba Multiplication</h5><p>usually multiplication take a time of O(N^2) complexity whereas KM takes O( N * log2 3).<br>It takes 2 N numbers, split it into N/2 numbers and do 3 multiplications and addition then we have T(n) = 3T(N/2) + O(N).</p><h4 id="lecture-13-Breadth-First-Search-BFS"><a href="#lecture-13-Breadth-First-Search-BFS" class="headerlink" title="lecture 13 Breadth First Search (BFS)"></a>lecture 13 Breadth First Search (BFS)</h4><h5 id="Graph-Search"><a href="#Graph-Search" class="headerlink" title="Graph Search"></a>Graph Search</h5><p>graph G = ( V , E ); V is a set of vertices and E is a set of edges.<br>if the edges have directions then the G is directed graph otherwise is undirected graph.</p><p>Applications:</p><ul><li>web crawling</li><li>social networking</li><li>network broadcast</li><li>garbage collection</li><li>model checking</li><li>solve puzzles and games</li></ul><p>Graph representation:</p><ul><li>adjacent list:<br>array Adj of size |V|;<br>each element in the array is a pointer to link list;<br>the array is indexed by the vertex so for every vertex v,<br>Adj[v] = {one step accessible neighbours of v };</li></ul><h5 id="Breadth-first-search"><a href="#Breadth-first-search" class="headerlink" title="Breadth first search"></a>Breadth first search</h5><ul><li>visit all node s reachable from given set V</li><li>O (V + E ) time</li><li>look at nodes reachable in 1 moves , 2 moves ……</li><li>carefully avoid duplicates , not revisiting vertices.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">BFS(s,Adj):</span><br><span class="line">level = &#123;s:none&#125;;// dictionary <span class="keyword">with</span> key s <span class="keyword">and</span> value none;</span><br><span class="line">parent = &#123;s: none&#125;</span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line">frontier = [s];</span><br><span class="line"><span class="keyword">while</span>  frontier:</span><br><span class="line">     next = [];</span><br><span class="line">          <span class="keyword">for</span>  u <span class="keyword">in</span> frontier:</span><br><span class="line">               <span class="keyword">for</span> v <span class="keyword">in</span> Adj[u]:</span><br><span class="line">                    <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> level:</span><br><span class="line">                         leve[v] = i;</span><br><span class="line">                         parent[v] = u;</span><br><span class="line">                         next.append(v);</span><br><span class="line">frontier = next;</span><br><span class="line">i += <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="lecture-14-Depth-First-Search-DFS"><a href="#lecture-14-Depth-First-Search-DFS" class="headerlink" title="lecture 14 Depth First Search (DFS)"></a>lecture 14 Depth First Search (DFS)</h4><ul><li>recursively explore the graph,back tracking as necessary</li><li>careful not to repeat vertices</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">parent = &#123;s : none&#125;;<span class="comment">#dictionary to prevent repeat</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DFS</span> - <span class="title">Visit</span><span class="params">( V , Adj , s )</span>:</span> <span class="comment">#can visit vertices reachable from s</span></span><br><span class="line">          <span class="keyword">for</span> v <span class="keyword">in</span> Adj[s]:</span><br><span class="line">               <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> parent:</span><br><span class="line">                    parent[v] = s;</span><br><span class="line">                    DFS-Visit(V,Adj,v);</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DFS</span><span class="params">( V , Adj )</span>:</span> <span class="comment"># top level algorithm</span></span><br><span class="line">parent = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> V:</span><br><span class="line">     <span class="keyword">if</span> s <span class="keyword">not</span> <span class="keyword">in</span> parent:</span><br><span class="line">          parent[s] = <span class="keyword">None</span></span><br><span class="line">          DFS-Visit( V , Adj , s)</span><br></pre></td></tr></table></figure><p>Analysis: O (V + E );linear time</p><h5 id="Edge-Classification"><a href="#Edge-Classification" class="headerlink" title="Edge Classification:"></a>Edge Classification:</h5><ul><li>tree edge: (parent pointer) visit new vertex via edge</li><li>forward edges: node -&gt; descendent</li><li>backward edges: node -&gt; ancestor</li><li>crossward edges: all other edges beside the two above, between sibling vertices</li></ul><h5 id="Cycle-Detection"><a href="#Cycle-Detection" class="headerlink" title="Cycle Detection:"></a>Cycle Detection:</h5><p>G has a cycle &lt;=&gt; G has a back edge</p><h5 id="Topological-Sort"><a href="#Topological-Sort" class="headerlink" title="Topological Sort:"></a>Topological Sort:</h5><ul><li><p>Job scheduling:<br>given a undirected acyclic graph (DAG),order vertices so that all edges point from lower order to higher order.</p></li><li><p>sort:<br>run DFS , output the reverse of finish times of vertices</p></li></ul><h4 id="lecture-15-Single-Source-Shortest-Paths-Problem"><a href="#lecture-15-Single-Source-Shortest-Paths-Problem" class="headerlink" title="lecture 15 Single-Source Shortest Paths Problem"></a>lecture 15 Single-Source Shortest Paths Problem</h4><ul><li><p>Dijkstra: non-negative weight edges<br>complexity: O( v*(lg v) + E);</p></li><li><p>Bellman-Ford :+/- weight edges<br>complexity: O ( v*E ) ;<br>negative circle can make path weight to infinite</p></li></ul><h5 id="weighted-graphs"><a href="#weighted-graphs" class="headerlink" title="weighted graphs"></a>weighted graphs</h5><p>shortest path from u to v is :<br>delta(u,v) = min { path(u -&gt; v) } if path exist, else  infinite;<br>d(u) is the current weight represented in side vertices;<br>Pi[v] is the predecessor vertex on the best path to v; Pi[source] = nil</p><h5 id="general-structure-of-shortest-path-algorithm-none-negative-value"><a href="#general-structure-of-shortest-path-algorithm-none-negative-value" class="headerlink" title="general structure of shortest path algorithm // none negative value"></a>general structure of shortest path algorithm // none negative value</h5><p>initialise for all u ∈ V  , set d(V) = infinite , set Pi[V] = nil<br>d(source) = 0;<br>Repeat select edge(u,v): // somehow<br>     Relax edge(u,v):<br>          if d(v) &gt; d(u) + w(u,v):<br>               d(v) = d(u) + w(u,v);<br>               Pi(v) = u;<br> until all edges have d(v) &lt;= d(u) + w(u,v);</p><h5 id="optimum-substructure-property"><a href="#optimum-substructure-property" class="headerlink" title="optimum substructure property"></a>optimum substructure property</h5><ul><li>Subpaths of a shortest path are shortest paths</li></ul><h4 id="lecture-16-Dijkstra-s-Algorithm"><a href="#lecture-16-Dijkstra-s-Algorithm" class="headerlink" title="lecture 16    Dijkstra`s Algorithm"></a>lecture 16    Dijkstra`s Algorithm</h4><p>Relaxation:<br>d[v] : length of current vertex from source<br>w(s,v):length of a shortest path from s to v<br>π[v] : predecessor of v in the path from s to v<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Relax( u, v, w  )</span><br><span class="line">    <span class="keyword">if</span> d[v] &gt; d[u] + w(u,v)</span><br><span class="line">        d[v]  = d[u] + w(u,v)</span><br><span class="line">        π[v] = u</span><br></pre></td></tr></table></figure></p><p>Relaxation is safe</p><p>Dijkstra:</p><pre><code class="python">Dijkstra(G,w,s) // G graph, w weight, s source    Initialise(G,s)  ;      S = NULL;    Q = V[G];   // S <span class="keyword">is</span> empty set, Q <span class="keyword">is</span> the set of all vertexes //initialise set d[s] = <span class="number">0</span>    <span class="keyword">while</span> Q != NULL        u = Extract_Min(Q);        //delete u <span class="keyword">from</span> q        S = S + u;        <span class="keyword">for</span> each vertex v belonging to Adjacent(u):            Relax(u,v,w);</code></pre>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LintCode &amp; LeetCode algorithms Easy</title>
      <link href="/2016/05/05/LintCode-LeetCode-algorithms-Easy/"/>
      <url>/2016/05/05/LintCode-LeetCode-algorithms-Easy/</url>
      <content type="html"><![CDATA[<h4 id="Merge-Sorted-Array-II"><a href="#Merge-Sorted-Array-II" class="headerlink" title="Merge Sorted Array II"></a>Merge Sorted Array II</h4><p>Merge two given sorted integer array A and B into a new sorted integer array.<br>两数组从大到小排列合并算法<br>Example<br>A=[1,2,3,4]<br>B=[2,4,5,6]<br>return [1,2,2,3,4,4,5,6]<br>solution:<br>// 因为数组有排序过 通过从数组尾到头 一个个比较 之后把大的元素插入新数组 实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] mergeSortedArray(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B) &#123;</span><br><span class="line">       <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[A.length + B.length];</span><br><span class="line">       <span class="keyword">int</span> i = A.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> j = B.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> index = i + j + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span> (A[i] &gt; B[j])&#123;</span><br><span class="line">           result[index--] = A[i--];&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               result[index--] = B[j--];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">           result[index--] = A[i--];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">           result[index--] = B[j--];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="First-Position-of-Target"><a href="#First-Position-of-Target" class="headerlink" title="First Position of Target"></a>First Position of Target</h4><p>二分法查询实现：<br>For a given sorted array (ascending order) and a target number, find the first index of this number in O(log n) time complexity. If the target number does not exist in the array, return -1.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end) &#123;  <span class="comment">//这里由于求mid取整所以不会收缩到一个结果只会到最后两个结果 所以要＋1</span></span><br><span class="line">          <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">              start = mid;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              end = mid;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (nums[start] == target) &#123;</span><br><span class="line">          <span class="keyword">return</span> start;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (nums[end] == target) &#123;</span><br><span class="line">          <span class="keyword">return</span> end;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h4 id="Insert-Interval"><a href="#Insert-Interval" class="headerlink" title="Insert Interval"></a>Insert Interval</h4><p>对象合并范围，用到arrayList，中心思想是通过比较范围，向新List里插入对象<br>Given a non-overlapping interval list which is sorted by start point.<br>Insert a new interval into it, make sure the list is still in order and non-overlapping (merge intervals if necessary).<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Interval&gt; <span class="title">insert</span><span class="params">(ArrayList&lt;Interval&gt; intervals, Interval newInterval)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (newInterval == <span class="keyword">null</span> || intervals == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> intervals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Interval&gt; results = <span class="keyword">new</span> ArrayList&lt;Interval&gt;();</span><br><span class="line">    <span class="keyword">int</span> insertPos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Interval interval : intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (interval.end &lt; newInterval.start) &#123;</span><br><span class="line">            results.add(interval);</span><br><span class="line">            insertPos++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (interval.start &gt; newInterval.end) &#123;</span><br><span class="line">            results.add(interval);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newInterval.start = Math.min(interval.start, newInterval.start);</span><br><span class="line">            newInterval.end = Math.max(interval.end, newInterval.end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    results.add(insertPos, newInterval);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Merge-Intervals"><a href="#Merge-Intervals" class="headerlink" title="Merge Intervals"></a>Merge Intervals</h4><p>给一组区间，合并区间，办法是另建一个容器（arrayList）然后插入区间，这里有点小技巧<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">merge</span><span class="params">(List&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Interval&gt; result = <span class="keyword">new</span> ArrayList&lt;Interval&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;intervals.size();i++)&#123;<span class="comment">//遍历原来的列表 插入区间到结果列表</span></span><br><span class="line">        insert(result,intervals.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">List&lt;Interval&gt; <span class="title">insert</span><span class="params">(List&lt;Interval&gt; result, Interval newInterval)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(index &lt; result.size())&#123;遍历结果列表</span><br><span class="line">        <span class="keyword">if</span>(newInterval.end &lt; result.get(index).start)&#123;<span class="comment">//如果插入元素比当前index小则插入到当前index，返回</span></span><br><span class="line">            result.add(index,newInterval);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(newInterval.start &gt;result.get(index).end)&#123;<span class="comment">//如果比当前index大则到下一个区间比较</span></span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果区间有重叠则比较当前index和插入元素的开始结尾，保留大的边界，在结果列表删除当前index的元素，删除结果列表当前区间之后再循环，可以解决结果列表之后还有区间与插入区间重叠问题，</span></span><br><span class="line">            newInterval.start = Math.min(newInterval.start,result.get(index).start);</span><br><span class="line">            newInterval.end = Math.max(newInterval.end,result.get(index).end);</span><br><span class="line">            result.remove(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result.add(newInterval);<span class="comment">//当index遍历完结果列表，加入到最后</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Reverse-Linked-List"><a href="#Reverse-Linked-List" class="headerlink" title="Reverse Linked List"></a>Reverse Linked List</h4><p>一个链表1-&gt;2-&gt;3-&gt;null 实现反转 3-&gt;2-&gt;1-&gt;null<br>方法是建立一个null链表 ，把目前head.next指向的对象先存下来，head.next指向新建链表，让新建列表头进一步到head，head进一步成为之前存下对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode temp = head.next;</span><br><span class="line">        head.next = prev;</span><br><span class="line">        prev = head;</span><br><span class="line">        head = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Recover-Rotated-Sorted-Array"><a href="#Recover-Rotated-Sorted-Array" class="headerlink" title="Recover Rotated Sorted Array"></a>Recover Rotated Sorted Array</h4><p>三步反转法对顺序轮转过的序列排序<br>三步反转法：对一个轮转过的顺序序列，找到序列中最大最小连接点的index，1.反转0到index子序列 2.反转index到列尾子序列 3.反转整个序列  即可得到顺序列  PS：此方法只对顺序轮转序列有效</p><p>Given a rotated sorted array, recover it to sorted array in-place.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(ArrayList&lt;Integer&gt; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;<span class="comment">//swap 交换函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums.get(i);</span><br><span class="line">        nums.set(i, nums.get(j));</span><br><span class="line">        nums.set(j, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverRotatedSortedArray</span><span class="params">(ArrayList&lt;Integer&gt; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; nums.size() - <span class="number">1</span>; index++) &#123;<span class="comment">//三步反转法</span></span><br><span class="line">        <span class="keyword">if</span> (nums.get(index) &gt; nums.get(index + <span class="number">1</span>)) &#123;<span class="comment">//找到index连接点</span></span><br><span class="line">            reverse(nums, <span class="number">0</span>, index);     <span class="comment">//1</span></span><br><span class="line">            reverse(nums, index + <span class="number">1</span>, nums.size() - <span class="number">1</span>);     <span class="comment">//2</span></span><br><span class="line">            reverse(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);     <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Maximum-Subarray"><a href="#Maximum-Subarray" class="headerlink" title="Maximum Subarray"></a>Maximum Subarray</h4><p>动态规划求子数组合最大值<br>Given an array of integers, find a contiguous subarray which has the largest sum.<br>Example<br>Given the array [−2,2,−3,4,−1,2,1,−5,3], the contiguous subarray [4,−1,2,1] has the largest sum = 6.</p><h6 id="Version-1-Greedy"><a href="#Version-1-Greedy" class="headerlink" title="// Version 1: Greedy"></a>// Version 1: Greedy</h6><p>动态规划贪心：只要数组加合结果大于0就一直加，把加合最大值记下来<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">        sum += A[i];<span class="comment">//加合</span></span><br><span class="line">        max = Math.max(max, sum);<span class="comment">//记录最大最</span></span><br><span class="line">        sum = Math.max(sum, <span class="number">0</span>);<span class="comment">//加合大于0就继续加 否则从新开始新序列头开始加合</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h6 id="version2-动规"><a href="#version2-动规" class="headerlink" title="//version2:动规"></a>//version2:动规</h6><pre><code>// LintCode, Maximum Subarray       // 时间复杂度 O(n),空间复杂度 O(1)                </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这个算法关键在于，之前加合的值如果为负则抛弃之前加合的子序列从当前开始，于此同时记录加合最大值        </span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = INT_MIN, f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); ++i) &#123;</span><br><span class="line">           f = max(f + A[i], A[i]);      <span class="comment">//   比较目前值与之前加合值</span></span><br><span class="line">           result = max(result, f);    <span class="comment">// 记录最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h4 id="Binary-Tree-Preorder-Traversal"><a href="#Binary-Tree-Preorder-Traversal" class="headerlink" title="Binary Tree Preorder Traversal"></a>Binary Tree Preorder Traversal</h4><p>//二叉树先序遍历<br>前序遍历：根节点-&gt;左子树-&gt;右子树<br>中序遍历：左子树-&gt;根节点-&gt;右子树<br>后序遍历：左子树-&gt;右子树-&gt;根节点</p><p>先序遍历(Pre-Order Traversal)<br>指先访问根，然后访问孩子的遍历方式，其C代码如下<br>使用栈,时间复杂度 O(n),空间复杂度 O(n)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;<span class="comment">//先访问的后入栈</span></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    List&lt;Integer&gt; preorder = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> preorder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        preorder.add(node.val);</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> preorder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用迭代法实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    traverse(root, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把root为跟的preorder加入result里面</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result.add(root.val);</span><br><span class="line">    traverse(root.left, result);</span><br><span class="line">    traverse(root.right, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Binary-Tree-Inorder-Traversal"><a href="#Binary-Tree-Inorder-Traversal" class="headerlink" title="Binary Tree Inorder Traversal"></a>Binary Tree Inorder Traversal</h4><p>//中序遍历 思想：先把左侧所有节点入栈直到目前节点为null，出栈节点并记录，当前节点去出栈节点的右节点，之后重复循环<br>中心思想：把一个节点的左节点搜索到头然后弹出并记录他 之后搜索他的右节点的左字节点 栈方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        TreeNode curt = root;</span><br><span class="line">        <span class="keyword">while</span> (curt != <span class="keyword">null</span> || !stack.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (curt != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(curt);</span><br><span class="line">                curt = curt.left;</span><br><span class="line">            &#125;</span><br><span class="line">            curt = stack.pop();</span><br><span class="line">            result.add(curt.val);</span><br><span class="line">            curt = curt.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>递归循环方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();</span></span><br><span class="line">          ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">          traverse(root,result);</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root,ArrayList&lt;Integer&gt; result)</span></span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          traverse(root.left,result);</span><br><span class="line">          result.add(root.val);</span><br><span class="line">          traverse(root.right,result);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><h4 id="Binary-Tree-Postorder-Traversal"><a href="#Binary-Tree-Postorder-Traversal" class="headerlink" title="Binary Tree Postorder Traversal"></a>Binary Tree Postorder Traversal</h4><p>//迭代循环方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">      ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">      Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">      TreeNode prev = <span class="keyword">null</span>; <span class="comment">// previously traversed node</span></span><br><span class="line">      TreeNode curr = root;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      stack.push(root);</span><br><span class="line">      <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">          curr = stack.peek();</span><br><span class="line">          <span class="keyword">if</span> (prev == <span class="keyword">null</span> || prev.left == curr || prev.right == curr) &#123; <span class="comment">// traverse down the tree</span></span><br><span class="line">              <span class="keyword">if</span> (curr.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  stack.push(curr.left);</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curr.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  stack.push(curr.right);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curr.left == prev) &#123; <span class="comment">// traverse up the tree from the left</span></span><br><span class="line">              <span class="keyword">if</span> (curr.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  stack.push(curr.right);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123; <span class="comment">// traverse up the tree from the right</span></span><br><span class="line">              result.add(curr.val);</span><br><span class="line">              stack.pop();</span><br><span class="line">          &#125;</span><br><span class="line">          prev = curr;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>//递归方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">          ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">          traverse(root,result);</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; result)</span></span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          traverse(root.left,result);</span><br><span class="line">          traverse(root.right,result);</span><br><span class="line">          result.add(root.val);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><h4 id="Single-Number"><a href="#Single-Number" class="headerlink" title="Single Number"></a>Single Number</h4><p>//一个2n＋1长度数组，除了一个元素出现一次其他元素出现两次，找出现一次的元素<br>用亦或运算累加，出现两次的全部加为0<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A == <span class="keyword">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rst = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">        rst ^= A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Insert-Node-in-a-Binary-Search-Tree"><a href="#Insert-Node-in-a-Binary-Search-Tree" class="headerlink" title="Insert Node in a Binary Search Tree"></a>Insert Node in a Binary Search Tree</h4><p>//中序遍历顺序的树，现在给出一个节点让放入正确位置。</p><pre><code>example:  2             2 / \           / \1   4   --&gt;   1   4   /             / \  3             3   6</code></pre><p>想法是看这个节点的值，如果大于父节点则在右枝否则在左枝，然后用递归循环<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertNode</span><span class="params">(TreeNode root, TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="comment">//这里很重要 循环到没有节点时返回目标节点赋值</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; node.val) &#123;<span class="comment">//判断向左还是向右</span></span><br><span class="line">        root.left = insertNode(root.left, node);<span class="comment">//递归 注意函数返回值是新的父节点所以可以这么赋值 当递归到最后 即当前父节点的左右均为null 则这里赋值到左右。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root.right = insertNode(root.right, node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;<span class="comment">// 返回新的父节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Partition-List"><a href="#Partition-List" class="headerlink" title="Partition List"></a>Partition List</h4><p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions.<br>//给一个数，使一个链表中大于等于这个数字的元素排后面，小于这个元素的排前面且不改变原始的相对位置。方法为新设两个链表和两个指针，遍历原链表，小的放在小链表大的放在大链表然后把大链表接在小链表后面。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (head == <span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ListNode leftStart = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">   ListNode rightEnd = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">   ListNode left = leftStart;</span><br><span class="line">   ListNode right = rightEnd;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="keyword">if</span> (head.val &lt; x)&#123;</span><br><span class="line">           left.next = head;</span><br><span class="line">           left = left.next;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           right.next = head;</span><br><span class="line">           right = right.next;</span><br><span class="line">       &#125;</span><br><span class="line">       head = head.next;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   right.next = <span class="keyword">null</span>;</span><br><span class="line">   left.next = rightEnd.next;</span><br><span class="line">   <span class="keyword">return</span> leftStart.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Maximum-Depth-of-Binary-Tree"><a href="#Maximum-Depth-of-Binary-Tree" class="headerlink" title="Maximum Depth of Binary Tree"></a>Maximum Depth of Binary Tree</h4><p>//用递归法主要归纳递归逻辑 开始状态 过程状态 和结果状态<br>开始是用左右两边的最大深度加1（自己）返回结果<br>结束状态是到最下层返回0到上层<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(maxDepth(root.left),maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Remove-Duplicates-from-Sorted-Array"><a href="#Remove-Duplicates-from-Sorted-Array" class="headerlink" title="Remove Duplicates from Sorted Array"></a>Remove Duplicates from Sorted Array</h4><p>//从排序的数组中去除出现过一次以上的元素，由于数组不能修改大小，我们把前m项作为缩减之后的数组<br>example:Given input array A = [1,1,2] Your function should return length = 2, and A is now [1,2].<br>用双指针，一个指当前元素，一个遍历数组，遇到不同的则当前元素下一个元素被赋值为不同的值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] != A[size]) &#123;</span><br><span class="line">                A[++size] = A[i];<span class="comment">//相同则i继续遍历数组，不同则size自增然后赋值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="Remove-Duplicates-from-Sorted-Array-II"><a href="#Remove-Duplicates-from-Sorted-Array-II" class="headerlink" title="Remove Duplicates from Sorted Array II"></a>Remove Duplicates from Sorted Array II</h4><p>//类似上一题，不过这次一个元素可以出现最多两次<br>example:Given sorted array A = [1,1,1,2,2,3] Your function should return length = 5, and A is now [1,1,2,2,3].<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> c =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(index &lt; nums.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[size] == nums[index] )&#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="number">1</span>)&#123;</span><br><span class="line">                nums[++size] = nums[index];</span><br><span class="line">            &#125;</span><br><span class="line">            c++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            nums[++size] = nums[index];</span><br><span class="line">            c = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ++size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Triangle"><a href="#Triangle" class="headerlink" title="Triangle"></a>Triangle</h4><p>//给一个n＊n的矩阵其中对角线及左侧的三角为triangle求从最底层triangle[n-1][*]到triangle[0][0]的合最小值。<br>这里如果用贪心算法可能得不到最优解，还是要全部遍历。转移方程为：<br>f(i,j) = min{f(i+1,j),f(i+1,j+1)} + d(i,j);//最小值线路是之前最小值加上下一个路径中最小一个点<br>由于一共有n个可能线路，所以从下往上遍历计算比较方便。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="keyword">int</span>[][] triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (triangle.length == <span class="number">0</span> || triangle[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = triangle.length - <span class="number">1</span>;i&gt;=<span class="number">1</span>;i--)&#123; <span class="comment">//从最低一行往上遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; i ; j++)&#123; <span class="comment">//每一行遍历每一个元素等于他下面两个元素最小路径加他本身</span></span><br><span class="line"></span><br><span class="line">         triangle[i - <span class="number">1</span>][j] += Math.min(triangle[i][j],triangle[i][j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Minimum-Path-Sum"><a href="#Minimum-Path-Sum" class="headerlink" title="Minimum Path Sum"></a>Minimum Path Sum</h4><p>//给一个m*n的矩阵，矩阵每一个元素有非零值，求从矩阵左上到右下走的通路中花费最小的值。<br>动态规划：转移方程为f(i,j) = min{f(i-1,j),f(i,j-1)}+d(i,j);<br>f(i,j)为到（i,j）点所需要的费用，等于他左边点与上边点中最小费用加上（i，j）点本身的费用。<br>//version1:动态规划<br>建立一个新矩阵，把最左边和最上边的行用原矩阵加合填入。之后遍历中间点，每一个点值由转移方程得出。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> M = grid.length;</span><br><span class="line">    <span class="keyword">int</span> N = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] sum = <span class="keyword">new</span> <span class="keyword">int</span>[M][N];</span><br><span class="line"></span><br><span class="line">    sum[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; M; i++) &#123; <span class="comment">//最左边列</span></span><br><span class="line">        sum[i][<span class="number">0</span>] = sum[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123; <span class="comment">//最上边行</span></span><br><span class="line">        sum[<span class="number">0</span>][i] = sum[<span class="number">0</span>][i - <span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; M; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; N; j++) &#123; <span class="comment">//根据转移方程，遍历填入中心点</span></span><br><span class="line">            sum[i][j] = Math.min(sum[i - <span class="number">1</span>][j], sum[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum[M - <span class="number">1</span>][N - <span class="number">1</span>]; <span class="comment">//矩阵右下点为最后结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Climbing-Stairs"><a href="#Climbing-Stairs" class="headerlink" title="Climbing Stairs"></a>Climbing Stairs</h4><p>//n阶楼梯，每次可以上一次或两次，求到n有多少种走法</p><pre><code>Example：     Given an example n=3 , 1+1+1=2+1=1+2=3     return 3</code></pre><p>用动态规划的思想，第n阶楼梯的走法是由第n-1阶走法加上n-2阶楼梯走法构成，状态方程：<br>     f(n) = f(n-1)+f(n-2);//为fibonacci递推<br>第一阶有1种走法，第二阶有两种走法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//fibonacci 题的变形</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>[] stair = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    stair[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        stair[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n )&#123; <span class="comment">//收敛条件</span></span><br><span class="line">            stair[i] = stair[i-<span class="number">1</span>] + stair[i-<span class="number">2</span>];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">1</span> ? stair[n-<span class="number">1</span>] : stair[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Unique-Paths"><a href="#Unique-Paths" class="headerlink" title="Unique Paths"></a>Unique Paths</h4><p>//一个m*n的矩阵，从左上角走到右下角，只能向左或向下，求不同走法的数量   </p><h5 id="version1-基本算法，动态规划"><a href="#version1-基本算法，动态规划" class="headerlink" title="version1:基本算法，动态规划"></a>version1:基本算法，动态规划</h5><p>转移函数：<br>               f(i,j) = f(i-1,j)+f(i,j-1);//走到(i,j)点的方法为走到(i-1,j)和(i,j-1)点方法的和。           </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( m == <span class="number">0</span> || n == <span class="number">0</span> ||m == <span class="number">1</span>||n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;m;i++)&#123;<span class="comment">//把左边首列填满1</span></span><br><span class="line">        f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;n;j++)&#123;<span class="comment">//把顶行填满1，初始化</span></span><br><span class="line">        f[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            f[i][j] = f[i-<span class="number">1</span>][j] + f[i][j-<span class="number">1</span>];<span class="comment">//转移方程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="version2-动态规划滚动算法。"><a href="#version2-动态规划滚动算法。" class="headerlink" title="version2:动态规划滚动算法。"></a>version2:动态规划滚动算法。</h5><p>利用小技巧，把每一次上门一层线加到下面一层，然后在由左向右加<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">      f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            f[j] = f[j-<span class="number">1</span>] + f[j];<span class="comment">//转移方程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="version3-DFS搜索加缓存"><a href="#version3-DFS搜索加缓存" class="headerlink" title="version3:DFS搜索加缓存"></a>version3:DFS搜索加缓存</h5><p>用DFS迭代搜索，为了减少内存分配，减少不必要运算，线创建一个f[m][n]的矩阵，然后运算，在getOrUpdate()函数中检查，如果元素之前运算过则直接返还之前的值，如果元素之前没运算过（为零）则进行迭代运算，并把结果纪录下来。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.f = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] f; <span class="comment">// 缓存</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(x&lt;<span class="number">1</span>||y&lt;<span class="number">1</span>)return0;<span class="comment">// 数据非法,终止条件</span></span><br><span class="line">     <span class="keyword">if</span> (x == <span class="number">1</span> &amp;&amp; y == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 回到起点,收敛条件</span></span><br><span class="line">     <span class="keyword">return</span> getOrUpdate(x - <span class="number">1</span>, y) + getOrUpdate(x, y - <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getOrUpdate</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="comment">//之前有运算过返还值，否则迭代运算并且储存结果。</span></span><br><span class="line">          <span class="keyword">if</span> (f[x][y] &gt; <span class="number">0</span>) <span class="keyword">return</span> f[x][y];</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">return</span> f[x][y] = dfs(x, y);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p><h4 id="Unique-Paths-II"><a href="#Unique-Paths-II" class="headerlink" title="Unique Paths II"></a>Unique Paths II</h4><p>//在之前Unique Paths 基础上，给你一个矩阵，里面有1的元素表示墙，走不通 还是用之前的动态规划算法，不过这里的缓存矩阵f[][]每当原来矩阵里有1时，f矩阵里要设为0表示没有通路到这个(i,j)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> m = obstacleGrid.length;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] f= <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++)&#123;<span class="comment">//初始化首行 遇到1则设为零，后面值等于前一个值</span></span><br><span class="line">        f[i][<span class="number">0</span>] = obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span> ? <span class="number">0</span> : (i==<span class="number">0</span>?<span class="number">1</span>:f[i-<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;n;j++)&#123;<span class="comment">//初始化列</span></span><br><span class="line">        f[<span class="number">0</span>][j] = obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span> ? <span class="number">0</span> : (j==<span class="number">0</span>?<span class="number">1</span>:f[<span class="number">0</span>][j-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;n;j++)&#123;<span class="comment">//转移方程，当原来矩阵里为1，f矩阵为0，表示到这点路径为0；</span></span><br><span class="line">            f[i][j] = obstacleGrid[i][j] == <span class="number">1</span> ? <span class="number">0</span> :f[i-<span class="number">1</span>][j] +f[i][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Sqrt-x"><a href="#Sqrt-x" class="headerlink" title="Sqrt(x)"></a>Sqrt(x)</h4><p>//实现平方根用逼近函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> g = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">         <span class="keyword">if</span>((g+<span class="number">1</span>)*(g+<span class="number">1</span>) &gt;= x &amp;&amp; g*g &lt;= x)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)g;</span><br><span class="line">        &#125;</span><br><span class="line">        g = (g+x/g)/<span class="number">2</span>; <span class="comment">//逼近函数，</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h4 id="Merge-Two-Sorted-Lists"><a href="#Merge-Two-Sorted-Lists" class="headerlink" title="Merge Two Sorted Lists"></a>Merge Two Sorted Lists</h4><p>//合并两个排序的链表，不用去除重复的元素。使用双指针法，把两个链表拼接起来，不用新建另一个链表<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode result = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode index = result;</span><br><span class="line">     <span class="keyword">while</span>(l2 != <span class="keyword">null</span> &amp;&amp; l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">if</span> (l2.val &lt; l1.val)&#123; <span class="comment">//连个指针依次向后移动，根据大小拼接链表</span></span><br><span class="line">             index.next = l2;</span><br><span class="line">             l2 = l2.next;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             index.next = l1;</span><br><span class="line">             l1 = l1.next;</span><br><span class="line">         &#125;</span><br><span class="line">         index = index.next;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(l1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">         index.next = l2;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         index.next = l1;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> result.next;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h4 id="Nth-to-Last-Node-in-List"><a href="#Nth-to-Last-Node-in-List" class="headerlink" title="Nth to Last Node in List"></a>Nth to Last Node in List</h4><p>//求一个链表中某Node，其到最后（null）有n步；做法位双指针，两指针之前差n步，一起向后移动直到front元素为null<br>例子：3-&gt;2-&gt;1-&gt;5-&gt;null and n = 2，return Node with Node.val == 1;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">nthToLast</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode back = head,front = head;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>( i &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(front != <span class="keyword">null</span>)&#123;</span><br><span class="line">            front = front.next;</span><br><span class="line">            i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">             &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(front != <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">        front = front.next;</span><br><span class="line">        back = back.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> back;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Add-Binary"><a href="#Add-Binary" class="headerlink" title="Add Binary"></a>Add Binary</h4><p>//给两个字符串代表的二进制数，求做二进制加法之后的二进制数组的字符串表示；这里用二进制按位加算法外加字符操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    String result = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> n = a.length() &gt; b.length() ? a.length():b.length();</span><br><span class="line">    a = <span class="keyword">new</span> StringBuffer(a).reverse().toString();   <span class="comment">//为了方便从低位开始遍历所以反转</span></span><br><span class="line">    b = <span class="keyword">new</span> StringBuffer(b).reverse().toString();</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ai = i &lt; a.length() ? a.charAt(i) - <span class="string">'0'</span>: <span class="number">0</span>;<span class="comment">//ai本来是char 为了得到ai位的数字方便计算</span></span><br><span class="line">        <span class="keyword">int</span> bi = i &lt; b.length() ? b.charAt(i) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> val = (ai + bi + carry) % <span class="number">2</span>;     <span class="comment">//算位值</span></span><br><span class="line">        carry = (ai + bi + carry ) / <span class="number">2</span>;      <span class="comment">//算进位</span></span><br><span class="line">        result = <span class="keyword">new</span> StringBuilder(result).insert(<span class="number">0</span>,(<span class="keyword">char</span>)(val+<span class="string">'0'</span>)).toString();<span class="comment">//val加上‘0’ 在asc2中偏移 48 以便得到‘0’或‘1’；</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123; <span class="comment">//如果有进位剩下，则进位</span></span><br><span class="line">        result = <span class="keyword">new</span> StringBuilder(result).insert(<span class="number">0</span>,<span class="string">'1'</span>).toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Add-Two-Numbers"><a href="#Add-Two-Numbers" class="headerlink" title="Add Two Numbers"></a>Add Two Numbers</h4><p>//类似上一题，给两个链表包含反转过的整数 求这两个数的和 按位反转存入另一个链表 ，由于当给的数据太大没有数据类型可以装下时，用这张按位加减的算法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode result = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode index = result;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span> , carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span> ; l1 = l1 == <span class="keyword">null</span> ? <span class="keyword">null</span> : l1.next , l2 = l2 ==  <span class="keyword">null</span> ? <span class="keyword">null</span> : l2.next,index = index.next)&#123;</span><br><span class="line">        <span class="keyword">int</span> i1 = l1 != <span class="keyword">null</span>? l1.val : <span class="number">0</span>;     <span class="comment">//看是已经按位加到头，是则返回零</span></span><br><span class="line">        <span class="keyword">int</span> i2 = l2 != <span class="keyword">null</span>? l2.val : <span class="number">0</span>;</span><br><span class="line">        val = (i1+i2+carry) % <span class="number">10</span>;     <span class="comment">//位值</span></span><br><span class="line">        carry = (i1 + i2 + carry) / <span class="number">10</span>;     <span class="comment">//进位</span></span><br><span class="line">        index.next = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        index.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Remove-Element"><a href="#Remove-Element" class="headerlink" title="Remove Element"></a>Remove Element</h4><p>//给一个数组给一个数，把与这个数相同的数移动到数组最后，返回数组前段不包含这个数到子数组的大小<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> elem)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pointer = A.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= pointer)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] == elem)&#123;</span><br><span class="line">            A[i] = A[pointer];</span><br><span class="line">            pointer--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pointer + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Insertion-Sort-List"><a href="#Insertion-Sort-List" class="headerlink" title="Insertion Sort List"></a>Insertion Sort List</h4><p>//插入排序的链表实现，重要；中心思想是用node.next操作，找到node.next.val &gt;head.val 或 node.next == null的点然后插入head的节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">insertionSortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 这个dummy的作用是，把head开头的链表一个个的插入到dummy开头的链表里</span></span><br><span class="line">  <span class="comment">// 所以这里不需要dummy.next = head;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ListNode node = dummy;</span><br><span class="line">      <span class="keyword">while</span> (node.next != <span class="keyword">null</span> &amp;&amp; node.next.val &lt; head.val) &#123;</span><br><span class="line">          node = node.next;</span><br><span class="line">      &#125;</span><br><span class="line">      ListNode temp = head.next;<span class="comment">//保存head之后的链</span></span><br><span class="line">      head.next = node.next;<span class="comment">//把head连接上之后到链</span></span><br><span class="line">      node.next = head;<span class="comment">//head接到node链里；连着2步把head节点插入到node.next上</span></span><br><span class="line">      head = temp;<span class="comment">//head ＝ head.next；</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="Remove-Nth-Node-From-End-of-List"><a href="#Remove-Nth-Node-From-End-of-List" class="headerlink" title="Remove Nth Node From End of List"></a>Remove Nth Node From End of List</h5><p>//从链表中删除倒数第N个节点，在开头接一个dummy节点，找到倒数第N个点的前一个，删除第N个<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line"></span><br><span class="line">    ListNode preDelete = dummy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">        preDelete = preDelete.next;</span><br><span class="line">    &#125;</span><br><span class="line">    preDelete.next = preDelete.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="Invert-Binary-Tree"><a href="#Invert-Binary-Tree" class="headerlink" title="Invert Binary Tree"></a>Invert Binary Tree</h5><p>//给一个二叉树，把二叉树的所有字节点互换，左变右，右变左；就是二叉树遍历，遍历同时操作就行<br>这里用栈方法遍历二叉树，前面有所有二叉树遍历方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invertBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;<span class="comment">//stack method</span></span><br><span class="line">   <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line"></span><br><span class="line">   stack.push(root);</span><br><span class="line">   <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">       TreeNode curt = stack.pop();</span><br><span class="line">       TreeNode temp = curt.left;</span><br><span class="line">       curt.left = curt.right;</span><br><span class="line">       curt.right = temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(curt.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">           stack.push(curt.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curt.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">           stack.push(curt.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h5 id="Balanced-Binary-Tree"><a href="#Balanced-Binary-Tree" class="headerlink" title="Balanced Binary Tree"></a>Balanced Binary Tree</h5><p>//检查一个binary tree 是不是 AVL tree，是否平衡；根据AVL property 需要每一个node的两个子node高度之差不大于1<br>用迭代方法：当前的node符合的条件是 1.两个子node符合property 2.这两个子node高度差不大于1.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">boolean</span> left = isBalanced(root.left);</span><br><span class="line">      <span class="keyword">boolean</span> right = isBalanced(root.right);</span><br><span class="line">      <span class="keyword">if</span>(left &amp;&amp; right &amp;&amp; Math.abs(maxLength(root.left) - maxLength(root.right))&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxLength</span><span class="params">(TreeNode root)</span></span>&#123; <span class="comment">//计算node高度function</span></span><br><span class="line">      <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> left = maxLength(root.left);</span><br><span class="line">      <span class="keyword">int</span> right = maxLength(root.right);</span><br><span class="line">      <span class="keyword">return</span> Math.max(left,right) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h5 id="Convert-Sorted-Array-to-Binary-Search-Tree-With-Minimal-Height"><a href="#Convert-Sorted-Array-to-Binary-Search-Tree-With-Minimal-Height" class="headerlink" title="Convert Sorted Array to Binary Search Tree With Minimal Height"></a>Convert Sorted Array to Binary Search Tree With Minimal Height</h5><p>//用排过序的数组创建AVL tree<br>一种方法：类似binary search ，把每一个数组中位数当root 然后把root左右当作2个新数组 迭代实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode node = <span class="keyword">new</span> TreeNode(num[(start + end) / <span class="number">2</span>]);</span><br><span class="line">    node.left = buildTree(num, start, (start + end) / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">    node.right = buildTree(num, (start + end) / <span class="number">2</span> + <span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buildTree(num, <span class="number">0</span>, num.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="Plus-One"><a href="#Plus-One" class="headerlink" title="Plus One"></a>Plus One</h5><p>//给一个数组用来表示一个大数，给这个大数加一然后返回装这个大数的数组<br>由于数字太大的话没办法用数据类型装下，一个一个位操作，如果有进位则新建一个数组把数据填入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">    <span class="keyword">int</span> carries = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = digits.length-<span class="number">1</span>; i&gt;=<span class="number">0</span> &amp;&amp; carries &gt; <span class="number">0</span>; i--)&#123;  <span class="comment">// fast break when carries equals zero</span></span><br><span class="line">        <span class="keyword">int</span> sum = digits[i] + carries;</span><br><span class="line">        digits[i] = sum % <span class="number">10</span>;</span><br><span class="line">        carries = sum / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carries == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] rst = <span class="keyword">new</span> <span class="keyword">int</span>[digits.length+<span class="number">1</span>];</span><br><span class="line">    rst[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt; rst.length; i++)&#123;</span><br><span class="line">        rst[i] = digits[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="Reverse-Integer"><a href="#Reverse-Integer" class="headerlink" title="Reverse Integer"></a>Reverse Integer</h5><p>//给一个int数字输出反转int数字，如果反转十进制数字溢出则返回0<br>Example：<br>Given x = 123, return 321</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseInteger</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> reversed_n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = reversed_n * <span class="number">10</span> + n % <span class="number">10</span>; <span class="comment">//一位一位反转</span></span><br><span class="line">        n = n / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (temp / <span class="number">10</span> != reversed_n) &#123; <span class="comment">//当到最后一位，如果溢出则条件不成立</span></span><br><span class="line">            reversed_n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        reversed_n = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reversed_n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Count-and-Say"><a href="#Count-and-Say" class="headerlink" title="Count and Say"></a>Count and Say</h5><p>//似乎是facebook面试题。数组 1, 11, 21, 1211, 111221； 生成方式：第一个为1，第二个为数且说前一个，为1个1即11、第三个为2个1即21，第四个为一个2一个1即1211，第五个为一个1一个2两个1即111221，以此类推。求此数组第n个元素。<br>直接翻译成代码，需要从1开始n次迭代，每一个迭代时从上市次得到的字符串中计算，数一样的元素数量，加上元素本身数值附在临时数组尾，到第n次得到需要的值，转换成字符串。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    String oldString = <span class="string">"1"</span>;</span><br><span class="line">    <span class="comment">//从1到n次迭代</span></span><br><span class="line">    <span class="keyword">while</span> (--n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">char</span> [] oldChars = oldString.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldChars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//每一位i的下一位i＋1不大于字符串长度，且i位与i＋1位值一样</span></span><br><span class="line">            <span class="keyword">while</span> ((i+<span class="number">1</span>) &lt; oldChars.length &amp;&amp; oldChars[i] == oldChars[i+<span class="number">1</span>])</span><br><span class="line">            &#123;   <span class="comment">//纪录一样的值数目，且指针前进</span></span><br><span class="line">                count++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//迭代一次，在临时字符串尾加上 1某个数字出现数目 2数字的值</span></span><br><span class="line">            sb.append(String.valueOf(count) + String.valueOf(oldChars[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        oldString = sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="Length-of-Last-Word"><a href="#Length-of-Last-Word" class="headerlink" title="Length of Last Word"></a>Length of Last Word</h5><p>求给定字符串最后一个单词的长度，直接用指针算出长度即可，要注意字符串最后一个字符有可能不是字母。<br>使用Character单例函数判断是否是字母或者空格。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = s.length() - <span class="number">1</span>,result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(index &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = s.charAt(index);</span><br><span class="line">        <span class="keyword">if</span> (!Character.isLetter(temp) &amp;&amp; result == <span class="number">0</span>)&#123;</span><br><span class="line">            index--;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> ( Character.isLetter(temp))&#123;</span><br><span class="line">            index--;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (Character.isWhitespace(temp))&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="Number-of-Islands"><a href="#Number-of-Islands" class="headerlink" title="Number of Islands"></a>Number of Islands</h5><p>给一个2维布尔数组，为1以及它相邻的1定义为一个岛，为0及相邻的0定义为海，求岛数目。（这里的相邻仅仅为上下左右）<br>解法为要是扫描数组，遇到1则：1、把这个元素归零，结果增加一。2、用迭代找它相邻元素，重复1。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">boolean</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = grid.length - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = grid[<span class="number">0</span>].length - <span class="number">1</span>;j &gt;= <span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="keyword">true</span>)&#123;</span><br><span class="line">                result++;</span><br><span class="line">                blankIt(grid,i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blankIt</span><span class="params">(<span class="keyword">boolean</span>[][] grid,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rowMax = grid.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> coloumMax = grid[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    grid[x][y] = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(x + <span class="number">1</span> &lt;= rowMax &amp;&amp; grid[x + <span class="number">1</span>][y] == <span class="keyword">true</span>)&#123;</span><br><span class="line">        blankIt(grid,x + <span class="number">1</span>,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[x - <span class="number">1</span>][y] == <span class="keyword">true</span>)&#123;</span><br><span class="line">        blankIt(grid,x - <span class="number">1</span>,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(y - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[x][y - <span class="number">1</span>] == <span class="keyword">true</span>)&#123;</span><br><span class="line">        blankIt(grid,x,y - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(y + <span class="number">1</span> &lt;= coloumMax &amp;&amp; grid[x][y + <span class="number">1</span>] == <span class="keyword">true</span>)&#123;</span><br><span class="line">        blankIt(grid,x,y + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="Ugly-Number"><a href="#Ugly-Number" class="headerlink" title="Ugly Number"></a>Ugly Number</h5><p>只有2、3、5因子的正整数数被认为是丑数，比如6，8，10. 其它有其它因子的不是丑数，如14，包含因子7.<br>实现方法是看用2、3、5尽除完一个数后其为不为1。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (num &gt;= <span class="number">2</span> &amp;&amp; num % <span class="number">2</span> == <span class="number">0</span>) num /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (num &gt;= <span class="number">3</span> &amp;&amp; num % <span class="number">3</span> == <span class="number">0</span>) num /= <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span> (num &gt;= <span class="number">5</span> &amp;&amp; num % <span class="number">5</span> == <span class="number">0</span>) num /= <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> Tips For Review </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mac terminal commands</title>
      <link href="/2016/05/01/Unix-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2016/05/01/Unix-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><ul><li><p>ls(list): 显示目录内容</p></li><li><p>cd: 到用户根目录；cd /uer :到相应目录； cd .. cd../.. ：返回上级</p></li><li><p>pwd(present working directory)：本命令用于显示当前的工作目录</p></li><li><p>mkdir／rmdir：本命令用于建立／删除目录</p></li><li><p>cp(copy): 拷贝</p></li><li><p>mv(move): mv [-f] [-i] 文件1 [文件2…] 目标;将文件移动至目标，若目标是文件名，则相当于文件改名</p></li><li><p>rm(remove):用来删除文件或目录</p></li><li><p>diff(differentiate) 本命令比较两个文本文件，将不同的行列出来</p></li><li><p>echo: 回音，输出</p></li><li><p>cat(catenate)：显示编辑文件，或创建文件；显示和连接一个或多个文件至标准输出</p></li><li><p>sort: 以字母顺序、数字大小排序。</p></li><li><p>cut: 从标准输入中切出字段。</p></li><li><p>sed(substitution edite): 用正则表达式从标准输入替换内容。</p></li><li><p>tr(translate characters): 从给定字符或字符集给标准输入替换指定字段。 </p></li><li><p>ifconfig／ping : 显示网络信息。</p></li><li><p>bc(basic calculator): 小计算器</p></li><li><p>find: 在当前目录树下迭代的寻找文件，文件名用正则表达式表示</p></li><li><p>env(environment variable): 显示环境变量</p></li></ul><h1 id="文件权限设置"><a href="#文件权限设置" class="headerlink" title="文件权限设置"></a>文件权限设置</h1><p>用<code>ls -la</code>命令后会显示文件夹内文件具体信息，会得到如下显示：<br><code>-rw-r--r-- 1 root root 302108 11-13 06:03 log2012.log</code><br>drwxrwxrwx表示:第一个字符表示是否是文件夹(d/-),后9个每三个一组，第一组是用户(u)的读(r/-)、写(w/-)、执行(x/-)权限,第二组是组用户(g)的权限，第三组是其他用户(o)的权限。<br>r：读权限，用数字4表示<br>w：写权限，用数字2表示<br>x：执行权限，用数字1表示<br>-：删除权限，用数字0表示</p><ul><li>chmod(change mode):</li></ul><ol><li>数字表示法: chmod 444 filename; 对file设置权限，file为u,g,o用户可读。</li><li>文字设定法: chmod ug+w,o-x filename; 对u,g用户增加写权限，对o用户减少执行权限。</li></ol><h1 id="标准输出重定向"><a href="#标准输出重定向" class="headerlink" title="标准输出重定向"></a>标准输出重定向</h1><p>默认情况下，标准输出、标准错误定向到屏幕，标准输出链接到键盘。</p><ul><li><blockquote><p>/&gt;&gt;: ls -la &gt;&gt; ls-out.tex; 输出重定向到指定文件,<code>&gt;&gt;</code>不覆盖原文件内容。</p></blockquote></li><li><p>2&gt;&gt; : 标准错误重定向。shell用0，1，2表示标准输入、标准输出、标准错误。</p></li></ul><h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><p>管道用<code>|</code>符把一个命令的标准输出传递到下一个命令的标准输入。</p><ul><li>|: Command 1 | Command 2;</li></ul><p>管道过滤器命令：</p><ul><li><p>uniq: 删除列表中重复的行。</p></li><li><p>wc(word counter): 输出输入文件的 行数 字数 字符数</p></li><li><p>grep(grab regular expression) :  grep pattern filename; 用正则表达式从标准输入筛选内容。</p></li><li><p>head / tail : 默认情况 输出 标准输入的前／后 10行。用<code>-n number</code> 来改变输出行数。</p></li></ul><h1 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h1><ul><li><p>ps: 查看运行的进程信息</p></li><li><p>top: 动态显示进程信息</p></li><li><p>[命令]&amp; : 使程序后台运行</p></li><li><p>jobs : 显示用户的正在运行的程序</p></li><li><p>fg %[pid]: 让后台程序进入前台</p></li><li><p>bg %[pid] : 让前台程序进入后台</p></li><li><p>kill [pid] : 杀死进程</p></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Core Data And Core Animation</title>
      <link href="/2016/04/30/coreData/"/>
      <url>/2016/04/30/coreData/</url>
      <content type="html"><![CDATA[<h3 id="Five-step-to-save-and-fetch-DATA-in-coreData"><a href="#Five-step-to-save-and-fetch-DATA-in-coreData" class="headerlink" title="Five step to save and fetch DATA in coreData"></a>Five step to save and fetch DATA in coreData</h3><h4 id="Save-data-to-coreData"><a href="#Save-data-to-coreData" class="headerlink" title="Save data to coreData:"></a>Save data to coreData:</h4><ol><li><p>Get the managedObjectContext from the AppDelegate</p></li><li><p>Get the entity from the managedObjectContext obtained</p></li><li><p>Link a connection between a variable and the managedObject in the MOcontext. Here means define a variable which is constructed using NSMangedObjects construct function with entity equal to the entity obtained from managedObjectContext.</p></li><li><p>Set the value for any attributes in the managedObject,Save any data to the Object.</p></li><li><p>Save the managedContext,using managedContext.save() throw function.</p></li></ol><h4 id="Fetch-data-from-coreData"><a href="#Fetch-data-from-coreData" class="headerlink" title="Fetch data from coreData:"></a>Fetch data from coreData:</h4><ol><li>Get the managedObjectContext from the AppDelegate</li><li>Create a fetching request<pre><code>let fetchRequest = NSFetchRequest(entityName: &quot;Person&quot;);</code></pre></li><li>ExecuteFetchRequest<pre><code>try fetchedResults = managedContext.executeFetchRequest(fetchRequest)</code></pre>fetchedResults is the managedObject to handle</li></ol><h4 id="CoreData-Stack"><a href="#CoreData-Stack" class="headerlink" title="CoreData Stack:"></a>CoreData Stack:</h4><ol><li><h5 id="NSManagedObjectContext"><a href="#NSManagedObjectContext" class="headerlink" title="NSManagedObjectContext:"></a>NSManagedObjectContext:</h5><p>An instance of NSManagedObjectContext represents a single “object space” or scratch pad in an application. Its primary responsibility is to manage a collection of managed objects.The managed object context (NSManagedObjectContext) is the object that your application will be interacting with the most, and therefore it is the one that is exposed to the rest of your application.</p></li><li><h5 id="NSPersistentStoreCoordinator"><a href="#NSPersistentStoreCoordinator" class="headerlink" title="NSPersistentStoreCoordinator:"></a>NSPersistentStoreCoordinator:</h5><p> Instances of NSPersistentStoreCoordinator associate persistent stores (by type) with a model (or more accurately, a configuration of a model) and serve to mediate between the persistent store or stores and the managed object context or contexts.</p></li><li><h5 id="NSManagedObjectModel-An-NSManagedObjectModel-object-describes-a-schema—a-collection-of-entities-data-models-that-you-use-in-your-application-The-model-contains-one-or-more-NSEntityDescription-objects-representing-the-entities-in-the-schema"><a href="#NSManagedObjectModel-An-NSManagedObjectModel-object-describes-a-schema—a-collection-of-entities-data-models-that-you-use-in-your-application-The-model-contains-one-or-more-NSEntityDescription-objects-representing-the-entities-in-the-schema" class="headerlink" title="NSManagedObjectModel:An NSManagedObjectModel object describes a schema—a collection of entities (data models) that you use in your application.The model contains one or more NSEntityDescription objects representing the entities in the schema."></a>NSManagedObjectModel:An NSManagedObjectModel object describes a schema—a collection of entities (data models) that you use in your application.The model contains one or more NSEntityDescription objects representing the entities in the schema.</h5></li><li><h5 id="NSPersistentStore"><a href="#NSPersistentStore" class="headerlink" title="NSPersistentStore:"></a>NSPersistentStore:</h5><p>representing the external storage</p><a id="more"></a><h4 id="Saving-NSManagedObject-Instances"><a href="#Saving-NSManagedObject-Instances" class="headerlink" title="Saving NSManagedObject Instances"></a>Saving NSManagedObject Instances</h4></li></ol><p>OBJECTIVE-C<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSError *error = nil;</span><br><span class="line"> if ([[self managedObjectContext] save:&amp;error] == NO) &#123;</span><br><span class="line">NSAssert(NO, @&quot;Error saving context: %@\n%@&quot;, [error localizedDescription], [error userInfo]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>SWIFT<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">try</span> managedObjectContext.save()</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line"><span class="built_in">fatalError</span>(<span class="string">"Failure to save context: \(error)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Fetching-NSManagedObject-Instances"><a href="#Fetching-NSManagedObject-Instances" class="headerlink" title="Fetching NSManagedObject Instances"></a>Fetching NSManagedObject Instances</h4><p>OC<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSManagedObjectContext *moc = …;</span><br><span class="line">NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@&quot;Employee&quot;];</span><br><span class="line">NSError *error = nil;</span><br><span class="line">NSArray *results = [moc executeFetchRequest:request error:&amp;error];</span><br><span class="line">if (!results) &#123;</span><br><span class="line">DLog(@&quot;Error fetching Employee objects: %@\n%@&quot;, [error localizedDescription], [error userInfo]);</span><br><span class="line">abort();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Swift<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> moc = managedObjectContext</span><br><span class="line"><span class="keyword">let</span> employeesFetch = <span class="type">NSFetchRequest</span>(entityName: <span class="string">"Employee"</span>)</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">let</span> fetchedEmployees = <span class="keyword">try</span> moc.executeFetchRequest(employeesFetch) <span class="keyword">as</span>! [<span class="type">AAAEmployeeMO</span>]</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line"><span class="built_in">fatalError</span>(<span class="string">"Failed to fetch employees: \(error)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Filtering-Results"><a href="#Filtering-Results" class="headerlink" title="Filtering Results"></a>Filtering Results</h4><p>OC<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *firstName = @&quot;Trevor&quot;;</span><br><span class="line">[fetchRequest setPredicate:[NSPredicate predicateWithFormat:@&quot;firstName == %@&quot;, firstName]];</span><br></pre></td></tr></table></figure></p><p>Swift<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="string">"Trevor"</span></span><br><span class="line">fetchRequest.predicate = <span class="type">NSPredicate</span>(format: <span class="string">"firstName == %@"</span>, firstName)</span><br></pre></td></tr></table></figure></p><h3 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h3><p>Animation available in iOS</p><ul><li>Animating UIView Properties:frame,transform,alpha</li><li>Core Animation framework:layer, the window from views to coreAnimation</li><li>OpenGL:3D</li><li>SpriteKit: 2.5D</li><li>Dynamic Animation:Physics based</li></ul><h5 id="UIView"><a href="#UIView" class="headerlink" title="UIView"></a>UIView</h5><p>animations from UIView function</p><ul><li>class func animationWithDuration(duration:NSTimeInterval,delay:NSTimeInterval,options:UIViewAnimationOptions,animation:()-&gt;Void,completion:((finished:Bool)-&gt;Void)?)<br>OC<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIView.animationWithDuration(3.0,delay:2.0 options:[UIViewAnimationOptions.CurveLinear],animations:&#123;block&#125;,completion:&#123;block&#125;)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Summary and review of detailed knowledge of swift</title>
      <link href="/2016/04/29/error-handling/"/>
      <url>/2016/04/29/error-handling/</url>
      <content type="html"><![CDATA[<h2 id="The-error-handling-review-and-conclusion-on-SWIFT-2-on-2016-04-28"><a href="#The-error-handling-review-and-conclusion-on-SWIFT-2-on-2016-04-28" class="headerlink" title="The error handling review and conclusion on SWIFT 2 on 2016/04/28"></a>The error handling review and conclusion on SWIFT 2 on 2016/04/28</h2><h4 id="1-Key-word-Guard"><a href="#1-Key-word-Guard" class="headerlink" title="1. Key word Guard"></a>1. Key word Guard</h4><pre><code>Like If statement  but for guard, if the statement is true then ELSE is not executed, if Guard statement is false execute the ELSEexample:    guard let name = person[&quot;name&quot;] else {bala bala bala};</code></pre><h4 id="2-Catching-and-handling-error"><a href="#2-Catching-and-handling-error" class="headerlink" title="2. Catching and handling error"></a>2. Catching and handling error</h4><p>  2.1 when calling a throwing function which means            it has the key word throw in the function definition, write TRY in front of the function  and the function after TRY might not be executed.</p><p>  2.2 use do-catch statement to catch and handle the errors</p><pre><code>do{          try ...        }catch ...{        }</code></pre><p>  if catch dose not specify a pattern, the clause will match and bind any error to a local constant named error</p><h4 id="3-Assertions"><a href="#3-Assertions" class="headerlink" title="3.Assertions"></a>3.Assertions</h4><p>  If some conditions must be satisfied or the execution must be ended,then use assertions<br>  assert( _:_:)  is a global function which takes two arguments<br>  First argument:condition.  If the condition is not satisfied then trigger the assert();<br>  Second argument: a string to be display at the console. this argument can be omitted<br>  example:</p><pre><code>assert(age &gt;= 0 , “a person`s age must be positive integer.”);</code></pre><h4 id="4-Some-tips-about-and-gt-in-C-C-and-OC"><a href="#4-Some-tips-about-and-gt-in-C-C-and-OC" class="headerlink" title="4.Some tips about . and -&gt; in C,C++ and OC"></a>4.Some tips about . and -&gt; in C,C++ and OC</h4><p>  . operator is used for accessing object member variables and methods via object instance.<br>  Foo foo;<br>  foo.member_var = 10;<br>  foo.member_func();<br>  -&gt; operator is used for accessing object member variables and methods via pointer.<br>  Foo *foo = new Foo();<br>  foo-&gt;member_var = 10;<br>  foo-&gt;member_func();</p><h4 id="5-closure"><a href="#5-closure" class="headerlink" title="5.closure"></a>5.closure</h4><p>  swift syntax:</p><pre><code>{ (parameters) -&gt; return type in             statements           }</code></pre><p>  example:</p><pre><code>func authenticate(URLScheme: NSString,callback error:(NSError) -&gt; Void){   ……  }</code></pre><p>  here second argument error is a closure type, it captures a NSError type and return Void<br><a id="more"></a></p><h4 id="6-singleton"><a href="#6-singleton" class="headerlink" title="6.singleton:"></a>6.singleton:</h4><p>constructor:<br>       6.1</p><pre><code>class AppManager {       private static let _sharedInstance = AppManager()      class func getSharedInstance() -&gt; AppManager {      return _sharedInstance  }  private init() {}  }</code></pre><p>6.2</p><pre><code>class AppManager {  static let sharedInstance = AppManager()  private init() {}  }</code></pre><h4 id="7-unwind-function"><a href="#7-unwind-function" class="headerlink" title="7.unwind function"></a>7.unwind function</h4><pre><code>@IBAction func unwind(segue:UIStoryboardSegue){ }</code></pre><h4 id="8-Multithreading"><a href="#8-Multithreading" class="headerlink" title="8.Multithreading"></a>8.Multithreading</h4><pre><code>8.1 executing a function on another queuelet queue:dispatch_queue_t =  dispatch_get_global_queue( DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);//the queue you want to dispatch//get the main queuelet mainQ: dispatch_queue_t = dispatch_get_main_queue();let mainQ: NSOperationQueue = NSOperationQueue.mainQueue();//another way to write// get the code to executedispatch_async(aQueueWhichIsNotTheMainQueue){theFunctionToExecute();//function not to execute on the main Q     dispatch_async(dispatch_get_main_queue()){         uiFunctionToUpdateUi();// call ui to show the result above     }}</code></pre><p>8.2 some concurrent queues</p><pre><code>QOS_CLASS_USER_INTERACTIVE     //most high priorityQOS_CLASS_USER_INITIATED       //highQOS_CLASS_UTILITY               //long runningQOS_CLASS_BACKGROUND          //low//get the queuelet dos = Int(&lt;one of the QOS above&gt;.value);let queue = dispatch_get_global_queue(qos,0);</code></pre><h4 id="9-Property-Observers"><a href="#9-Property-Observers" class="headerlink" title="9.Property Observers"></a>9.Property Observers</h4><pre><code>the observers are called every time a property`s value is set.You can add property observer to  any stored property apart from lazy stored property.willSet and didSet are not called in the property initialiser.       var steps:Int? {  willSet(newValue){      functionToDoWithNewValue();  }  didSet(oldValue){      functionToDoWithOldValue();  }}</code></pre><h3 id="to-be-continue"><a href="#to-be-continue" class="headerlink" title="to be continue"></a>to be continue</h3>]]></content>
      
      
    </entry>
    
  
  
</search>
